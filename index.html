<!DOCTYPE html>
<html>
  <head>
    <title>Step by Step Guide to React and Redux</title>
    <link rel="stylesheet" href="ddscrollspydemo.css" />
    <link rel="stylesheet" href="github.min.css">
    <link rel="stylesheet" href="index.css">
    <script type="text/javascript" src="jquery.min.js"></script>
    <script type="text/javascript" src="ddscrollspy.js"></script>
    <script src="highlight.min.js"></script>
  </head>
  <body>
    <div class="toc"><ul class="level-h0"><li><a href="#_preface-introduction">Introduction</a></li>
<ul class="level-h1"><li><a href="#_preface-base-software">Base software</a></li>
<li><a href="#_preface-server-side-code">Server side code</a></li>
<li><a href="#_preface-client-side">Client side</a></li>
</ul>
<li><a href="#chapter01-initial-software-setup">Initial software setup</a></li>
<ul class="level-h1"><li><a href="#chapter01-nodejs">NodeJS</a></li>
<li><a href="#chapter01-npm">NPM</a></li>
<li><a href="#chapter01-editor">Editor</a></li>
<li><a href="#chapter01-github">GitHub</a></li>
<li><a href="#chapter01-git">GIT</a></li>
<li><a href="#chapter01-working-with-repositories">Working with repositories</a></li>
<ul class="level-h2"><li><a href="#chapter01-creating-a-repository">Creating a repository</a></li>
<li><a href="#chapter01-cloning-your-repository">Cloning your repository</a></li>
<li><a href="#chapter01-uploading-the-changes">Uploading the changes</a></li>
</ul>
<li><a href="#chapter01-summary">Summary</a></li>
</ul>
<li><a href="#chapter02-creating-a-simple-web-server">Creating a simple web server</a></li>
<ul class="level-h1"><li><a href="#chapter02-important-nodejs-features">Important NodeJS features</a></li>
<ul class="level-h2"><li><a href="#chapter02-modules">Modules</a></li>
<li><a href="#chapter02-event-loop">Event loop</a></li>
<li><a href="#chapter02-callbacks">Callbacks</a></li>
<li><a href="#chapter02-chaining">Chaining</a></li>
</ul>
<li><a href="#chapter02-and-finally">... and finally</a></li>
<li><a href="#chapter02-summary">Summary</a></li>
</ul>
<li><a href="#chapter03-npm-packages">NPM Packages</a></li>
<ul class="level-h1"><li><a href="#chapter03-running-the-script">Running the script</a></li>
<li><a href="#chapter03-installing-dependencies-express">Installing dependencies: Express</a></li>
<li><a href="#chapter03-installing-developer-dependencies-eslint">Installing developer dependencies: ESLint</a></li>
<li><a href="#chapter03-global-installs-eslint">Global installs: ESLint</a></li>
<li><a href="#chapter03-ignored-files">Ignored files</a></li>
<li><a href="#chapter03-summary">Summary</a></li>
</ul>
<li><a href="#chapter04-creating-an-express-web-server">Creating an Express Web Server</a></li>
<ul class="level-h1"><li><a href="#chapter04-request-parameters">Request parameters</a></li>
<li><a href="#chapter04-using-middleware">Using Middleware</a></li>
<li><a href="#chapter04-reading-data-from-a-form">Reading data from a form</a></li>
<li><a href="#chapter04-summary">Summary</a></li>
</ul>
<li><a href="#chapter05-rest">REST</a></li>
<ul class="level-h1"><li><a href="#chapter05-defining-our-rest-api">Defining our REST API</a></li>
<li><a href="#chapter05-loading-sample-data">Loading sample data</a></li>
<li><a href="#chapter05-global-variables">Global variables</a></li>
<li><a href="#chapter05-writing-a-module-to-respond-to-rest-requests">Writing a module to respond to REST requests</a></li>
<li><a href="#chapter05-summary">Summary</a></li>
</ul>
<li><a href="#chapter06-testing-our-server">Testing our server</a></li>
<ul class="level-h1"><li><a href="#chapter06-loading-testing-software">Loading testing software</a></li>
<li><a href="#chapter06-running-the-tests">Running the tests</a></li>
<li><a href="#chapter06-testing-the-data-server">Testing the data server</a></li>
<li><a href="#chapter06-summary">Summary</a></li>
</ul>
<li><a href="#chapter07-code-coverage">Code coverage</a></li>
<ul class="level-h1"><li><a href="#chapter07-installing-istanbul">Installing Istanbul</a></li>
<li><a href="#chapter07-running-istanbul">Running Istanbul</a></li>
<li><a href="#chapter07-improving-coverage">Improving coverage</a></li>
<li><a href="#chapter07-linting">Linting</a></li>
<li><a href="#chapter07-summary">Summary</a></li>
</ul>
<li><a href="#chapter08-switching-to-sql">Switching to SQL</a></li>
<ul class="level-h1"><li><a href="#chapter08-building-sql-statements-dynamically">Building SQL statements dynamically</a></li>
<li><a href="#chapter08-regular-anonymous-functions-vs-fat-arrow-functions">Regular anonymous functions vs. fat arrow functions</a></li>
<li><a href="#chapter08-testing-the-changes">Testing the changes</a></li>
<li><a href="#chapter08-handling-url-query-parameters">Handling URL Query Parameters</a></li>
<li><a href="#chapter08-sql-injection">SQL Injection</a></li>
<li><a href="#chapter08-summary">Summary</a></li>
</ul>
<li><a href="#chapter09-separating-concerns">Separating Concerns</a></li>
<ul class="level-h1"><li><a href="#chapter09-simplifying-validation-with-middleware">Simplifying validation with middleware</a></li>
<li><a href="#chapter09-summary">Summary</a></li>
</ul>
<li><a href="#chapter10-client-side">Client side</a></li>
<ul class="level-h1"><li><a href="#chapter10-the-way-not-to-do-it">The way not to do it</a></li>
<li><a href="#chapter10-polyfills">Polyfills</a></li>
<li><a href="#chapter10-transpiling">Transpiling</a></li>
</ul>
<li><a href="#chapter11-modules-imports-and-exports">Modules, Imports and Exports</a></li>
<ul class="level-h1"><li><a href="#chapter11-webpack">WebPack</a></li>
<li><a href="#chapter11-packaging-and-transpiling">Packaging and Transpiling</a></li>
<li><a href="#chapter11-almost-a-single-page-application">Almost a Single Page Application</a></li>
<li><a href="#chapter11-summary">Summary</a></li>
</ul>
<li><a href="#chapter12-client-side-routing">Client-side Routing</a></li>
<ul class="level-h1"><li><a href="#chapter12-react-router">React Router</a></li>
<li><a href="#chapter12-jsx">JSX</a></li>
<ul class="level-h2"><li><a href="#chapter12-proptypes">PropTypes</a></li>
<li><a href="#chapter12-production-version">Production version</a></li>
<li><a href="#chapter12-watch-for-changes">Watch for changes</a></li>
<li><a href="#chapter12-final-touches">Final touches</a></li>
</ul>
<li><a href="#chapter12-summary">Summary</a></li>
</ul>
<li><a href="#chapter13-events">Events</a></li>
<ul class="level-h1"><li><a href="#chapter13-stateful-components">Stateful components</a></li>
<ul class="level-h2"><li><a href="#chapter13-stateless-or-stateful">Stateless or Stateful</a></li>
</ul>
<li><a href="#chapter13-putting-some-order-into-our-files">Putting some order into our files</a></li>
<li><a href="#chapter13-conditional-rendering">Conditional rendering</a></li>
<li><a href="#chapter13-lodash">Lodash</a></li>
</ul></li></ul></div>
    <div class="contents unfolded"><div class="close">&lt; close</div><h1><a class="self-ref" id="_preface-introduction" href="#_preface-introduction"># </a>Introduction</h1>
<p>With the rapid pace of progress in the creation of libraries and tools for web development, most information comes in brief articles and blog posts.  There are not very many comprehensive guides to all that may be needed from A to Z.</p>
<p>This book intends to fill that gap. We will go step by step gathering the tools and utilities we need for each step and explaining how to use them and coding a full, modern single page application.</p>
<p>We will avoid dumping a whole suite of tools and sample code all at once. There are many full-stack solutions available, however, they are often quite hard to assimilate all at once. They contain too many pieces all strung together without much explanation.  We prefer to go one step at a time.  You may jump ahead and go to the end but then you wouldn't know why we did things the way we did and wouldn't know how to fix it if you disagree.</p>
<p>We won't cover all the alternatives -that would be impossible- but we will present a very good one. We will use Facebook's <a href="https://facebook.github.io/react/index.html">React</a> coupled with <a href="http://redux.js.org/index.html">Redux</a> for data handling.</p>
<p>We will write both server and client code and keep track of its development via <a href="https://github.com/">GitHub</a>.  We will lint, test, check its performance and package it for faster delivery and automate all these processes.  We will turn our app isomorphic, that is, able to render fully formed pages straight from the server for faster rendering on slow devices or for SEO purposes.  We will also internationalize it.</p>
<p>A brief itinerary of what we will go through follows, however, you may skip straight into chapter 1.</p>
<h2><a class="self-ref" id="_preface-base-software" href="#_preface-base-software"># </a>Base software</h2>
<p>There is some software we need to make sure we have installed.  You might already have it or not.  We'll check that in the first chapter.  To begin with we will need NodeJS, which gives us the ability to leverage our knowledge of JavaScript at both ends.  It is fair to say that JavaScript is not the only alternative on the server side, you might have already used or heard about PHP or Java but unless you have any legacy system and/or experience, nowadays JavaScript is the way to go, one single language across all the application.</p>
<p>Then, we need to create a repository on <a href="http://github.com">GitHub</a>. A repository is the place up in the cloud where all the development team can store and share their work.  GitHub is one major provider of such shared space. Even if we work alone, GitHub will help us to keep track of the progress of the project, report and respond to issues and keep a nice set of safe copies of our job up there in the cloud. It not only works with code, documentation can be stored there as well; after all both this book and the accompanying code are up there in GitHub.</p>
<p>To use GitHub we need to install a GIT client.</p>
<h2><a class="self-ref" id="_preface-server-side-code" href="#_preface-server-side-code"># </a>Server side code</h2>
<p>In the next few chapters we will work on the server-side. Our browser will show whatever information the server is able to provide so it makes sense to start on that side. Most of what we learn on the server side we will later use on the client side.</p>
<p>Moreover, the server is also a simpler environment.   When we are on the client side we need to take into account too many other issues. This can make it all very confusing.  In the simpler environment of the server, we can go a step at a time.</p>
<p>We will learn to install and create a web server using Express and how to serve data from it by using REST (Representational state transfer) architecture.</p>
<p>To avoid unintended errors, we will do a static check of our code using a <em>linter</em>, a sort of compiler that checks the syntax and formatting of our code and only produces a listing of errors, if any.  This will also help us keep a consistent style on the code we produce.  When developing in teams, it is better to have a consistent coding style everyone can easily recognize.</p>
<p>Before releasing this server-side software to the world, it is better to test it dynamically, not just do a static syntax check, which we will do by setting an automated testing system.  This not only ensures that our code works as we meant it to, but also that during development, any changes we make do not break any functionality that was already there.</p>
<p>Once we are sure our code is good, we send the new version back to the GitHub repository.  In this way we share it with the rest of the team so that it can all rejoice and celebrate or, at least, get on with the rest of the project.</p>
<p>Up to this point, in our examples, we would have been storing our data in-memory within the web server.  This would have allowed us to concentrate on the topics described above, however, for any meaningful amount of data, memory storage is not a good idea. There are very many ways to store data server-side.  The first big decision to make is whether to go for an SQL server or a non-SQL or <em>NoSQL</em> one. Then, within each of those, which particular implementation.</p>
<p>For the purpose of this book, we will use a simple SQL database, <a href="https://www.sqlite.org/">SQLite</a>. The SQL language is quite standard, in fact, it is both an ANSI (American) and ISO (international) standard. Admittedly, there are small inconsistencies in between actual implementations, but at least there is a solid base, which NoSQL databases lack.  Within all the SQL databases available, we will use SQLite because it is the simplest one to set up and install.  It is not apt for a serious web service, but for teaching purposes, it works fine.</p>
<p>Once we do the conversion to SQL, we will run the tests again, to make sure we didn't break anything in the migration.  Here, we can clearly see the benefit of having a set of tests made.  We have completely changed our back end software and we can still assure that our server still works as it did before.</p>
<p>As always, after testing, we save it in our GitHub repository.</p>
<h2><a class="self-ref" id="_preface-client-side" href="#_preface-client-side"># </a>Client side</h2>
<p>First of all we will learn how to retrieve the data from the server we have been building in the previous chapters.  Our first renderings will be rather crude, but we'll fix that in a moment.</p>
<p>For the browser, we have opted to use Facebook's <a href="http://facebook.github.io/react/">React</a> as the rendering library.  This is just one of very many options out there and plenty of books could be devoted to praising one or the other.  Many articles certainly have.  It would be easy to say that it handles the V in the MVC model, but that would get us into equally endless discussions about MVC and the many abbreviations derived from it and which of them applies.</p>
<p>A web developer should be able to reach all users using any sort of browser.  It is not admissible to have an application that only works in the most recent release of a particular browser.  The great majority of browsers do not support the latest version of JavaScript, formally EcmaScript 2015, often shortened to ES6.  To deal with that, and the various incompatibilities amongst browsers we will use <a href="http://babeljs.io/">Babel</a>, what is now know as a <em>transpiler</em>, that is, a compiler that reads ES6 code and translates it to ES5 code that can run in any browser.</p>
<p>Browsers don't know about <em>modules</em> and <em>packages</em> as NodeJS does. ES6-style modules are not supported in most browsers, if any. To be able to use modules in the client side, we will use a packager called <a href="http://webpack.github.io/">WebPack</a> which will produce a single bundle that any browser can easily load and simulate NodeJS-style modules for us.</p>
<p>We will use <a href="https://github.com/rackt/react-router">React-Router</a> to be able to convert our separate pages into a Single-Page Application (SPA) by allowing the user to navigate across all of our application without resorting to the server.</p>
<p>We will then see how we can consolidate all our data into various models (the M in MVC), separate from the rendering components (the V in MVC) so we can avoid duplication of data and ensure proper synchronization of information across all of our application.</p>
<p>Now that we have the data properly managed, we can start changing it by responding to user interaction. We will do that by using <a href="http://redux.js.org/index.html">Redux</a> one of the various implementations of the <a href="https://facebook.github.io/flux/">Flux</a> uni-directional data-flow architecture.   Flux, as originally defined, is a good concept but its implementation as a library is somewhat lacking. Redux, is very well documented and while it is an amazingly small piece of code, it is quite complete and has a good number of tools that supplement it when needed.</p>
<p>As we progress in our application we will see how to improve its looks by using an external style library.  We will use the popular <a href="http://getbootstrap.com/">Bootstrap</a> though there are many alternatives. We will just use its built-in styles and avoid using its active components so as to show how to code working components.  In practice, once you settled on a user interface style library, you would use its components.</p>
<p>One of the advantages or having JavaScript on the server is that we may run the very same code that runs in the browser. One reason to do that is to improve the user perception of speed.  On slow devices on slow connections, which usually means smart phones, a complex page might take quite a while to load and render.  If a static image of that same page can be produced on the server, it can be immediately displayed to the user even before the application has been loaded.  The other reason is that search engines won't execute your application to find out what it produces in order to index it. A page composed on the fly at the browser is invisible to search engines. Producing a static version of it at the server is the way to have it indexed.  This is called isomorphism, the ability to look the same at either end. We will see what needs to be done to turn our application into an isomorphic one.</p>
<p>Finally we will deal with internationalization, the ability of an application to show up in different languages and using regional conventions to display numbers or dates.</p>
<p>All along we will make an aside on writing the code to check it by linting and testing it.</p>
<p>It is unfortunate that we will not be able to show any utility to provide automated documentation.  The existing utilities lag behind the tools we will be using, the docs they provide fall quite short of really describing the code.  The best ones analyze the code itself to fill in part of the documentation.  While this is a good idea to reduce the work of the programmer, many of these are unable to understand ES6 or JSX (more on JSX later) so they get totally confused.  The results are quite unsatisfactory so we will not cover them.  We will just hold on to the basic principle of writing small modules in separate files with sensible names placed in a logical folder structure and providing self-describing identifiers to any named thing.</p>
<h1><a class="self-ref" id="chapter01-initial-software-setup" href="#chapter01-initial-software-setup"># </a>Initial software setup</h1>
<h2><a class="self-ref" id="chapter01-nodejs" href="#chapter01-nodejs"># </a>NodeJS</h2>
<p>For a long time, Web developers had to learn one of several languages to code on the server, usually PHP, Python, Java or whatever your company had available.  Shyly, some developers started adding some interactivity to web pages using JavaScript.  JavaScript started to grow with sophisticated web applications such as Google Maps or fancy email clients. Thus, developers ended up having to use two different languages, one for the client, JavaScript, and another for the server.</p>
<p>All that changed in 2009 when Ryan Dahl adapted Google's open source V8 JavaScript engine to work in Linux. With later versions made to work in all popular platforms, NodeJS allowed web developers to use one single language everywhere: JavaScript.</p>
<p>We need to check if we have NodeJS already installed. At a command prompt we can type <code>node --version</code> or <code>node --help</code> which will either fail if NodeJS is not installed or produce a suitable response.  At the time of reviewing this chapter, the version for NodeJS is 4.4.2.  If you do have an older NodeJS it means you already know how to install it and hopefully how to upgrade it.</p>
<p>To install NodeJS simply go to the download page on their <a href="https://nodejs.org/">site</a>. The home page will detect which download is suitable for your computer and offer it as a download.  NodeJS offers two versions, the <code>LTS</code> (Long Term Support) which is the safest one, which is what we will be using, and a more adventurous one for developers willing to experiment with the upcoming features.</p>
<h2><a class="self-ref" id="chapter01-npm" href="#chapter01-npm"># </a>NPM</h2>
<p>NodeJS became quite a success and suddenly lots of developers were writing software to run on it.  NodeJS promotes a very modular way of writing code.  Instead of big source files containing hundreds of lines of code, it is much better to split the code in small, very maintainable pieces called <em>modules</em>. Several of those <em>modules</em> can be grouped together to make a <em>package</em>.  To help in managing those packages, Isaac Z. Schlueter wrote <code>npm</code>, NodeJS Package Manager. Initially, <code>npm</code> had to be installed separately, currently it is installed along NodeJS so there is nothing you have to do, if you installed NodeJS, you have <code>npm</code>.</p>
<p>NPM is not just software, there is also a web site <a href="https://www.npmjs.com/">npmjs.com</a> that contains above two hundred thousand free packages. Npm, Inc, the company that runs the site, does not evaluate the quality of those packages but it provides good information to evaluate its worth. There are very many well known excellent packages. We will use several of those.</p>
<h2><a class="self-ref" id="chapter01-editor" href="#chapter01-editor"># </a>Editor</h2>
<p>Comprehensive IDEs such as Eclipse or Microsoft's Visual Studio have fallen out of favor mostly because they are too heavy and slow. As Web development changes fast, it is impossible for the large IDEs to keep pace. The current trend is towards smaller and fast text-editors with a flexible plugin architecture so, whatever the original designers left out, someone else can add.</p>
<p>If you don't have a beloved text editor installed in your system I'd like to suggest a couple of interesting options Adobe <a href="http://brackets.io/">Brackets</a> and GitHub <a href="https://atom.io/">Atom</a>.  Both are very capable and fast editors and both have a large list of plugins to add any features not already built-in.  The most interesting feature of both is that they are written mostly in JavaScript running in NodeJS, which you should have installed by now.</p>
<p>Both editors are also open source and anyone of us can contribute to its development or add plugins.  As any such large collaborative project, they are both hosted in GitHub (<a href="https://github.com/adobe/brackets"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /> Brackets</a> and <a href="https://github.com/atom/atom"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /> Atom</a>)</p>
<h2><a class="self-ref" id="chapter01-github" href="#chapter01-github"># </a>GitHub</h2>
<p>Teams of developers, possibly continents apart, need somewhere to put their source code which they can all reach. GitHub has become the place of choice for that. The last two links in the previous section point to software stored in GitHub. The little icon before each name is Octocat, GitHub's mascot. Lots of people got creative with this little creature and there is the Octocat Index or <a href="https://octodex.github.com/">Octodex</a> showing many of its personalities. We will use that icon along links pointing to code residing in GitHub.</p>
<p>It is now time to setup your GitHub account.  Go to <a href="https://github.com/">GitHub</a> and create your account. Just follow the instructions on the screen.  To finish the account creation process, GitHub will send an e-Mail message to validate the address you have provided. GitHub will recognize you by your e-Mail address so it is vital that it works but it will not make it public unless you tell it to.</p>
<p>All your postings in GitHub will show the user name you have given when you created the account.  Do provide a good user name because that is how everyone will refer to you and, hopefully, make you famous.  Your Twitter handle or similar known alias would be a good choice. GitHub will use your name for a folder where all your stuff will be stored.  Unfortunately, many good, short names are already taken, some of which you don't even see because they might be private projects.</p>
<p>Software in GitHub is stored in <em>repositories</em>.  Repositories can be public or private.  Public repositories are free. Absolutely everyone can see what you store in them but only those you set as collaborators can modify it.  If you want to keep your code secret, then you have to create a private repository and pay a fee.</p>
<p>Though we will use GitHub to store computer code, it can actually be used for any kind of text, such as this book <a href="https://github.com/Satyam/book-react-redux">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> or all sorts of documents like those issued by government agencies <a href="https://github.com/GSA">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. Many legal firms, editors and publishers, translators and others sharing large amounts of documents also use it though, understandably, they tend to use private repositories.</p>
<p>Though everyone can see and download anything in public repositories, to actually change anything, besides having permission to do so, you can either use the on-line editor, which is only practical for minor modifications, or use a git client which lets you synchronize your local working copy and the one in the remote repository.</p>
<h2><a class="self-ref" id="chapter01-git" href="#chapter01-git"># </a>GIT</h2>
<p>Git is a source control system. It allows a distributed team of people to share and keep track of changes in source code over time. It was initially designed in 2005 by Linus Torvalds to manage the Linux kernel, the version of Unix he wrote and named after himself.  Linux which, at the time, was the largest open source project in the world, needed a safe, secure and fast means of allowing its collaborators to work together.  None of the existing systems satisfied all the expectations of the team so they developed one of their own.</p>
<p>The basic Git client software can be downloaded from their <a href="http://git-scm.com/downloads">download page</a>.  The basic Git client software is a command-line utility with no user interface.  Several <a href="http://git-scm.com/downloads/guis">GUI clients</a> are listed in the same site. In this book, however, we will use the command-line commands, since they are the standard. For Windows or Mac users I would suggest <a href="https://desktop.github.com/">GitHub's own desktop</a> since that is where we will store our code. Many popular coding text editors and IDEs (Integrated development environment) have plugins for Git.</p>
<p>Once Git is installed, we need to set it up.  Since Git will interact with remote servers, you need to provide it with information about you.</p>
<p><code>git config --global user.name &quot;YOUR USER NAME&quot;</code></p>
<p><code>git config --global user.email &quot;YOUR EMAIL ADDRESS&quot;</code></p>
<p>It is best to use the same user name and e-mail address you used on your GitHub account. GitHub will use the e-Mail address to associate your commits with your GitHub account. GitHub will not make your e-Mail public unless you explicitly tell it to. Do not change the e-Mail address once you set it up, otherwise, GitHub will no longer recognize you.  The user name you give to your git client may or may not match your GitHub account name, but then, why wouldn't it?</p>
<p>In order to prevent GitHub from requesting your login information too often, you might want to tell git to temporary remember you.</p>
<p><code>git config --global credential.helper cache</code></p>
<p>Git will remember you for about 15 minutes after a login, if you want to change that, you can do:</p>
<p><code>git config --global credential.helper 'cache --timeout=3600'</code></p>
<p>Timeout is measured in seconds so the above gives you one hour.</p>
<p>If you have a Git GUI or a plugin for your editor, they will usually offer to save your credentials for you.</p>
<h2><a class="self-ref" id="chapter01-working-with-repositories" href="#chapter01-working-with-repositories"># </a>Working with repositories</h2>
<h3><a class="self-ref" id="chapter01-creating-a-repository" href="#chapter01-creating-a-repository"># </a>Creating a repository</h3>
<p>Go to <a href="https://github.com">GitHub</a> and, if you are a new user, you will see a mostly empty page except for some pictures linking to some tutorials.  Somewhere on that page (the design might vary over time) there will be a button to create a <kbd>New repository</kbd>. Click on it (nothing will happen until you confirm it) and fill in the name and description.  Select a public (free) repository, opt to have a README file and select a <code>.gitignore</code> for <code>Node</code> and a license.</p>
<p>As Nicholas C. Zakas explains in a recent <a href="https://www.nczonline.net/blog/2015/12/why-im-not-using-your-open-source-project/">article</a> selecting a license is vital.  You might assume that by not imposing a license requirement you are leaving your code open for anybody to use.  Quite the opposite, in most countries unless you explicitly surrender your rights, the copyright is yours.  You can either pick one of the very many licenses on offer (I suggest the MIT License) or state your own terms. Don't try to be funny with the terms of your license if you make your own.  A well known piece of software added the clause &quot;The Software shall be used for Good, not Evil&quot; and caused quite a <a href="https://en.wikipedia.org/wiki/JSLint#License">lot of trouble</a>.</p>
<p>Finally, click on the <kbd>Create repository</kbd> button.  You can actually add both the <code>README</code>, <code>.gitignore</code> and license files later on and if you are not happy with the name or description, you can change it as well.  And if you don't like anything in it, you can delete it though, once you start working on your project, it would be a shame.</p>
<h3><a class="self-ref" id="chapter01-cloning-your-repository" href="#chapter01-cloning-your-repository"># </a>Cloning your repository</h3>
<p>So far you have the basic structure of a project but it is only up there in GitHub, you have nothing in your own computer.  The first thing we need to do is to make a local working copy of it and to do that we will <em>clone</em> it.</p>
<p>Somewhere in the page (now it is above the file listing but it used to be on the right so, just look for it) there is a dropdown that lets you pick either <kbd>SSH</kbd> or <kbd>HTTPS</kbd> and to its right there will be a long string that looks like an URL, for example, if you select <kbd>HTTPS</kbd> you might see:</p>
<p><code>https://github.com/MyUserName/MyNewRepository.git</code></p>
<p>Copy that string.</p>
<p>In a terminal, command prompt or whatever you call it in your operating system type <code>git clone</code> and then paste the URL you copied from GitHub. The <code>git clone</code> command  will create a folder with the repository name under your current folder and  download everything in the repository.  It will also add a <code>.git</code> folder with some configuration information related to the repository.</p>
<p>If you now do a <code>cd MyNewRepository</code> (or whatever you called it) you will see your <code>README.md</code>, <code>LICENSE</code> and <code>.gitignore</code> files.  Unix-based systems, by default will not show files starting with a dot so you might not see the <code>.gitignore</code> file.  We will see the purpose of this file later on.</p>
<p>The <code>LICENSE</code> file is a plain text file containing the terms of the license you have selected.</p>
<p>The <code>README.md</code> file is what contains the text that is shown right below the file listing in the GitHub repository.  It is a plain text file written in <a href="https://guides.github.com/features/mastering-markdown/">Markdown</a> format, the same used in writing this book.  The sample file will contain the name of the repository as its main heading and the description provided when you created the repository as its content.</p>
<p>You might want to change some of the text in that README.md file to try out some of the styles shown in the <a href="https://help.github.com/articles/markdown-basics/">guide</a>. Markdown was <a href="https://daringfireball.net/projects/markdown/">originally designed</a> to be an easier way to generate simple HTML, improving on the usual <code>readme.txt</code> files that used to be distributed along software packages.</p>
<p>If you are using the <a href="http://brackets.io/">Brackets</a> editor you might want to install the <a href="https://github.com/gruehle/MarkdownPreview">MarkdownPreview</a> extension.  If you are using <a href="https://atom.io/">Atom</a> you already have the <a href="https://atom.io/packages/markdown-preview">markdown-preview</a> plugin installed. Either will let you see a preview of how your README.md will look once uploaded to GitHub.   GitHub uses a particular <a href="https://help.github.com/articles/github-flavored-markdown/">flavor</a> of Markdown so except for the Atom previewer the results shown on others might be slightly different.</p>
<h3><a class="self-ref" id="chapter01-uploading-the-changes" href="#chapter01-uploading-the-changes"># </a>Uploading the changes</h3>
<p>We want to change something in our working copy so we can see how to upload our changes to GitHub. We have already played a little bit with our README.md.  Now, lets go and create a folder called <code>server</code> where we will put the code we are about to write. Lets put a file there, an empty file called <code>index.js</code>.  We will fill it up later, but for now, lets just see how git works.</p>
<p>Go to the terminal or command prompt and type <code>git status</code>.  This will show which files have been modified such as the README.md, and which files are <em>untracked</em> which means they have been newly created and git has no clue about them yet.  This already tells us something, git keeps track of the files it knows about, namely, those that have been brought from your GitHub repository.</p>
<p>Uploading files to your remote repository is a process similar to sending a package through the mail.  First you put everything into a box. In git parlance this is called <em>staging</em>. Git already knows about those files you have received, however, it doesn't know about the new files you have added or which files you want to include in the box. For whatever reason, you might want to ship your files in separate packages but, if you know that everything in your working folder should go, you can simply do a <code>git add .</code> .  Note the dot after <code>add</code>, meaning the current working folder.  This will add to the box every file and folder it finds in the current folder and in those below.</p>
<p>If you repeat the <code>git status</code> command, you will see the files previously listed in red (if your terminal/command prompt supports such coloring) now showing in green meaning that they are in the box, that is, <em>staged</em>. <code>git status</code> is always a handy command to use. Another useful one is <code>git diff README.md</code> which will show a list of the differences in between your working version of the README.md file (or any other you ask for) and the copy in the repository.</p>
<p>Now that you have everything in the box, you have to close it and label it.  You do that with <code>git commit -m &quot;my first commmit&quot;</code>.  The <code>-m &quot;whatever&quot;</code> is optional and if you don't provide that option, git will fire up whichever your default text editor might be configured in your system (notepad, gedit, etc.) and let you write a brief description of what you have changed in this commit.</p>
<p>Finally, you just have to dispatch it.  You do this by pushing it: <code>git push origin master</code>. You will then be asked for your user name and password.  So far there had been no need for identifying yourself. Since the repository is public, everyone can read it and clone it.  All the changes you then do in your local workspace are of no concern to git, however, when you <code>push</code> your changes back GitHub needs to make sure you are authorized to do that.</p>
<p>The basic command is <code>git push</code> but you need to add some destination address to your shipment.  We won't deal with that right now but suffice it to say that git is able to manage multiple versions or <em>branches</em> of the same project and also deal with hierarchies of repositories so that, for example, in our case a sub-team might deal with server-side development and another with client-side development and each have a sub-repository from the main repository. That is the reason for those extra options.  Since, for the time being, we are the only users of our single repository, we will always do <code>git push origin master</code>.</p>
<p>If we go to <a href="https://github.com">GitHub</a> we will now see our changes reflected in the repository.  If we did any changes in the README.md file, the home page of the project, shown right below the file listing, will display the new text.  We can also dig down into the <code>server</code> folder where we will find the <code>index.js</code>.  The description we provided when we issued the <code>git commit</code> command with the <code>-m</code> option will be shown along the files affected as well as the date of the change.</p>
<p>If we open the README.md file, we will see its raw, unformatted contents and at the top we can see there is a button labeled <code>History</code>.  This will show us each of the changes done on the file (not many right now) each accompanied with its commit description and time stamp and, if we click on any of the entries, we will see the file with its changes marked green for the additions and red for the deletions. Two columns of line numbers on the left correspond to the before and after source files.</p>
<p>There is not much to see right now but try it out later on once we have done some few changes. There is far more to git and GitHub than what we have mentioned so far.  It really shines when used with large teams in big projects but, for the time being, it is good to becomes somewhat familiar with it.</p>
<h2><a class="self-ref" id="chapter01-summary" href="#chapter01-summary"># </a>Summary</h2>
<p>We have learned how to install several of the tools we will need to develop our application: NodeJS, NPM and optionally some JavaScript editors written in JavaScript.</p>
<p>We have also installed GIT which allows us to work with GitHub, a place where we can store our code, keep track of the changes, share it with others, track bugs and issues and, in general, manage much of the process of creating an application.</p>
<p>Finally, we created a <em>repository</em> within GitHub to test these tools.</p>
<h1><a class="self-ref" id="chapter02-creating-a-simple-web-server" href="#chapter02-creating-a-simple-web-server"># </a>Creating a simple web server</h1>
<p>NodeJS has been designed to be used primarily in web sites so creating a web server is pretty easy. In many other languages such as PHP we would need to have a web server, such as <a href="https://httpd.apache.org/">Apache</a> plus the interpreter for <a href="http://www.php.net/">PHP</a>. Not so in NodeJS. The following code is all we need to start with:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const http = require('http');

const PORT = 8080;

const server = http.createServer();

server.on('request', (req, res) =&gt; {
  console.log(`Received request for ${req.url}`);
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.write('Hello World!\n');
  res.end(`Received request for ${req.url}`);
});

server.on('listening', (error) =&gt; {
  if (error) {
    console.error(error);
  } else {
    console.log(`Server running at http://localhost:${PORT}/`);
  }
});

server.listen(PORT);</code></pre></div>
<blockquote>
<p>All the code for the book is available at <a href="https://github.com/Satyam/book-react-redux">https://github.com/Satyam/book-react-redux</a> which includes <a href="https://github.com/Satyam/book-react-redux#sample-code-for-each-chapter">instructions</a> on how to see or download the code for any of the chapters. You can see the original of the segments of code included in this book by clicking on the <em>Octocat</em> <img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /> icon in the frame.  The Octocat is GitHub's mascot.</p>
</blockquote>
<p>NodeJS programs are made of <em>modules</em>, little bits of code that provide useful functionality.  NodeJS already offers a good number of such <a href="https://nodejs.org/docs/latest/api/index.html">modules</a>.  One of them is <code>http</code> and to load it we do:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">const http = require('http');</code></pre></div>
<p>We save a reference to that module in the <code>http</code> constant.  It is usual, though not required, to name the references to the modules after the name of the module itself.</p>
<p>We are using the <code>const</code> keyword instead of a simple <code>var</code> because we want to make sure we don't accidentally change its contents later on.  It might surprise C programmers because in in C constants are numeric or string literals.  In JavaScript any variable can contain anything, numbers, booleans, functions or full objects.  By declaring it as <code>const</code> we just mean that we want to protect it from accidental changes later on.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">const PORT = 8080;</code></pre></div>
<p><code>PORT</code> is more of a traditional constant in the C sense, a plain numeric value.  Following the regular convention, we use an all-uppercase name for it.  This is not mandatory, just a convention.  The <code>PORT</code> will be the part after the <code>:</code> in the URL:</p>
<p><code>http://localhost:8080</code></p>
<p>We might already have an active web server running on our machine which will be listening in the standard port number of 80.  We don't want to interfere with any existing web server so we put ours to listen on another port.  The low port numbers (below 1024) are mostly reserved for <a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports">well known services</a>.  It is customary to use 8080 for temporary test web servers.  If we get an error stating that the port is already in use, we can simply use some other number.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-js">const server = http.createServer();</code></pre></div>
<p>The <code>http.createServer</code>  function creates an instance of a web server, which we save into the variable <code>server</code> declared as a constant to keep it safe.</p>
<p>We want to know when our server receives any request, that is, a user has navigated to an URL on this web server.  So, we tell  the <code>server</code> that <code>on</code> receiving a <code>'request'</code> it should let us know.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L7-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">server.on('request', (req, res) =&gt; {
  console.log(`Received request for ${req.url}`);
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.write('Hello World!\n');
  res.end(`Received request for ${req.url}`);
});</code></pre></div>
<p>It will do so by calling the function we provide.  We are using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow functions</a> which were incorporated in ECMAScript 2015 or <em>ES6</em> as it is often called (<code>const</code> is also new to ES6). Basically, the two fragments below are more or less equivalent:</p>
<pre><code class="language-js">(req, res) =&gt; {

function (req, res) {
</code></pre>
<p>So, for each request our web server receives it will call our function providing it with two arguments, a request <code>req</code>, containing information about the request just received such as the URL (<code>req.url</code>) or the headers.  It also provides a response object <code>res</code> that allows us to return a response to the browser.</p>
<p>We use <code>res.writeHead</code> to start the reply to the browser by giving it the 200 HTTP response code for Ok, then we add one header to change the default <code>Content-Type</code> of <code>text/html</code>.  We want to send back plain text instead of HTML so we change it to <code>text/plain</code>.</p>
<p>With <code>res.write</code> we start sending the text we mean to show on the browser. The <em>response</em> object <code>res</code> will keep accepting text as long as we keep writing into it.  To tell it we are done we do a final call to <code>res.end</code>. We are using the same <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">template string</a> as in the earlier <code>console.log</code> where we tell JavaScript to interpolate the value of <code>req.url</code> into the template.</p>
<p>We also want to know when the server becomes ready to start listening so we ask the <code>server</code> that <code>on</code> <code>'listening'</code>, it should let us know by calling the function we provide.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L14-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">server.on('listening', (error) =&gt; {
  if (error) {
    console.error(error);
  } else {
    console.log(`Server running at http://localhost:${PORT}/`);
  }
});</code></pre></div>
<p>This is also an <em>arrow function</em>. It receives an <code>error</code> argument which, if not null, will contain an error message, otherwise, it means the server is ready.</p>
<p>Finally we tell the <code>server</code> we want to <code>listen</code> on the given <code>PORT</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-js">server.listen(PORT);</code></pre></div>
<p>If you clicked in any of the OctoCat <img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /> links above you might have noticed that they point  to highlighted lines or ranges of lines in the sample code in GitHub.  This is just one of many features in GitHub that makes it great when doing development in teams, we can use these links to talk about code with other people, as we are doing here.</p>
<p>We can run this brief script by typing <code>node server</code>.  Since <code>server</code> is a folder, NodeJS will try to run a file named <code>index.js</code>.  The program will soon print</p>
<p><code>Server running at http://localhost:8080/</code>.</p>
<p>Now, if we go to a browser and navigate to that URL, the server script will print:</p>
<pre><code>Received request for /
Received request for /favicon.ico
</code></pre>
<p>The first line is due to the URL we requested.  The second is because most modern browsers look for a file called <code>favicon.ico</code> at the root of the site, which it will use as the icon to associate with the site.</p>
<p>On the browser, we will see the reply from the server:</p>
<pre><code>Hello World!
Received request for /
</code></pre>
<p>We can add whatever we want to that URL and the server will report whatever else we asked after the site root.  Thus <code>http://localhost:8080/this/that?something=else</code> will produce:</p>
<pre><code>Hello World!
Received request for /this/that?something=else
</code></pre>
<p>By parsing and analyzing the URL and the rest of the information the <code>request</code> object provides we can respond in any way we want by sending back files, presumably HTML files or images, or assembling web pages on the fly.  Doing all these would be somewhat tiresome, like re-inventing the wheel.  Instead, in the next chapter, we will use a <em>package</em> which will do much of the work for us.</p>
<h2><a class="self-ref" id="chapter02-important-nodejs-features" href="#chapter02-important-nodejs-features"># </a>Important NodeJS features</h2>
<p>This simple example allows us to learn about some of the goodies that JavaScript and NodeJS gives us.</p>
<h3><a class="self-ref" id="chapter02-modules" href="#chapter02-modules"># </a>Modules</h3>
<p>NodeJS allows us to break up a big project into little pieces called <em>modules</em>, each a piece of JavaScript code that does very well a very simple thing.  This is great for working in teams because each individual can concentrate on a simple, well-defined module and not be concerned with anything beyond.  Even a single solitary developer benefits from Modules because it makes it easy to know where the various parts of a project go.  It also allows us to reuse the same code over and over again.</p>
<p>Modules are gathered into <em>packages</em>. NodeJS comes with NPM, its own package manager.  A public repository of packages <a href="https://www.npmjs.com/">npmjs.com</a> collects thousands of packages.  We will use one of those in the next chapter to improve on our web server.  <a href="https://www.npmjs.com/package/express">Express</a> is actually one of the most popular packages for NodeJS.</p>
<p>Let us have a look at the entry for <a href="https://www.npmjs.com/package/express">Express</a> in the NPM registry.  On the right hand there is a column with plenty of information. They are on a 4.xx version, which means it is a mature product that has gone through many major revisions. It has an MIT license meaning we can freely use it. There is a link to the GitHub repository <a href="https://github.com/expressjs/express">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> where we can find the source code and all the history of its development.  We can see that in the last month it had millions of downloads, which speaks of its popularity.</p>
<p>If we scroll further down, we can see a list of Dependencies and Dependents.  Here lies the beauty of packages and of the whole NPM ecosystem.  Each developer does something that depends on the code done by someone else and will see his/her own package used by others and depended upon by many other packages.</p>
<p>This is open source at its best.</p>
<h3><a class="self-ref" id="chapter02-event-loop" href="#chapter02-event-loop"># </a>Event loop</h3>
<p>Much of the efficiency and simplicity of NodeJS comes from the <em>event loop</em>. <em>Events</em> are simply things that happen.  We are used to events such as button clicks in the browser.  We don't know when or even if an event will happen, it is up to the user of the browser. This has proved a powerful concept in interfacing with the user.  Instead of prompting the user for information one piece at a time as we did in the age of teletypewriters (well, at least some of us did), we give the user freedom to interact with our pages in multiple ways and have our applications respond to that.</p>
<p>It seems a little bit of a stretch to extend this to the server, where there is no user, however, it works wonderfully well, as we've seen.  In our simple web server, we don't know when a request from a browser will come.  Thus, we tell our <code>server</code> that <code>on</code> receiving a <code>'request'</code> it should let us know.  Likewise, we don't know how long will it take to setup the server and get it ready to <code>listen</code> to requests so, we tell the <code>server</code> that <code>on</code> becoming ready to start <code>'listening'</code>, it should tell us.</p>
<p>This is thanks to the <em>event loop</em>. After initializing, NodeJS reads and executes the script and then enters what is called the <em>event loop</em>. If there is anything listening <code>on</code> something else, it just stays there waiting for that something to happen.  When an event happens, it notifies whomever it might concern by executing the function provided as a callback and loops back to the event loop.  While NodeJS is executing those callbacks, events get queued so on returning to the event loop NodeJS first checks the queue and processes the events queued in it.</p>
<p>NodeJS changes the way we do many other operations, for example, reading a file.  In most other languages, we have to open the file and read it.  When we tell the operating system (<em>OS</em>) to open the file, our application is temporarily frozen until the OS does get the file open and returns a handle.  Then, when we order the OS to read the file, our program gets frozen once again until the file is actually read and its contents made available somehow to our program.  NodeJS doesn't work like that (it can, but it is not encouraged).</p>
<p>In NodeJS, we tell the OS that we wish to have the file opened and tell it to let us know when it has complied.  Likewise, when we read from a file, we tell the OS to read the file for us and let us know when the chunk we have requested is available.  Our program is never frozen. Once we place our requests to the OS, we are free to continue doing something else or, most likely, go idle, allowing NodeJS to return to the event loop and see if something else has happened that might be of interest to some other application.</p>
<p>Contrast this to, for example, PHP.  It has the library functions to write a simple web server just like NodeJS but it cannot deal with concurrency, that is, multiple request coming from various sources.  It can easily do one at a time and, in principle, it seems NodeJS does the same.  However, there is a big difference. When the incoming request needs a file to be read, PHP freezes until the read operation is done and no other request can be processed.  NodeJS doesn't freeze, it simply returns to the event loop and allows other events to be processed, be them further HTTP requests or files read by previous requests that are still pending.  That is why PHP and so many other languages require complex environments such as an <a href="http://httpd.apache.org/">Apache web server</a> or Microsoft's <a href="https://www.iis.net/">IIS</a> to juggle with the various PHP processes each dealing with a single request.</p>
<h3><a class="self-ref" id="chapter02-callbacks" href="#chapter02-callbacks"># </a>Callbacks</h3>
<p>Unlike in most other languages, functions in JavaScript are just one more type of object and they can be assigned to variables, passed as arguments to functions and, of course, called.  This sits nicely with the event loop because that is the way to tell NodeJS or the browser what to do when an event happens.  We just give it a function.  Basically, we are saying &quot;when <em>this</em> happens, call me back&quot;. It is the kind of thing we would wish we could do when calling customer support; instead of listening to the &quot;All our customer support representatives are busy ... yada yada ...&quot; we let them know we need help and have them call us back. That is why we have <em>callback</em> functions.</p>
<p>In the code above, we have supplied both our event listeners with callback functions.  In one we print suitable messages depending on whether the server succeeded in listening to incoming requests, in the other we process those requests.</p>
<p>In other languages, for example, Java, we cannot use functions so freely because we cannot pass functions as arguments.  Instead we have to define a class which implements a particular interface that declares a method which will be called when the event occurs, then we pass the whole class instance to the event listener.  Sounds complicated?  Well, you get used to it, but the JavaScript way is so much easier!  And since ES6 and its <em>arrow functions</em> it is even easier.  In JavaScript, when we need a function, we write it right there.</p>
<h3><a class="self-ref" id="chapter02-chaining" href="#chapter02-chaining"># </a>Chaining</h3>
<p>Functions don't always return values.  In other languages we had <em>functions</em>, which always return some value, and <em>subroutines</em> or <em>procedures</em> which we call (often using the <code>call</code> statement) to do something, but that don't return anything.</p>
<p>In JavaScript there are only functions and they always return something, even if that something is <code>undefined</code>.  Someone, and I think it was John Resig in jQuery, thought that returning <code>undefined</code> was a waste so all the methods (functions in object instances) that have nothing better to return will return a reference to itself.
In our sample web server, we call several functions within the <code>server</code> instance (that is, <em>methods</em>) and never use any return from those functions.  Actually, all those functions return a reference to the same object they belong to.</p>
<p>Using those references to the very same object they belong to allow for what is called <em>chaining</em> where we can chain one function call right after the other.</p>
<p>We can see this in action in the following example:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-02/server/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-02</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const http = require('http');

const PORT = 8080;

http.createServer()
  .on('request', (req, res) =&gt; {
    console.log(`Received request for ${req.url}`);
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.write('Hello World!\n');
    res.end(`Received request for ${req.url}`);
  })
  .on('listening', (error) =&gt; {
    if (error) {
      console.error(error);
    } else {
      console.log(`Server running at http://localhost:${PORT}/`);
    }
  })
  .listen(PORT);</code></pre></div>
<p>It is our very same web server changed to use chaining.  First thing to notice is that we are no longer declaring a variable <code>server</code>.  The <code>http.createServer()</code> function already returns an instance of an HTTP server and all the functions, such as <code>on</code>, that would otherwise have nothing better to return, keep returning references to the same HTTP server instance they belong to.  We have chained several operations one after another to the same instance.</p>
<p>Good styling dictates that when doing chaining the chained functions (<code>.on</code> or <code>.listen</code>) to start with the dot on a separate line indented one position from the original source of the object instance.  All functions chained to the same object should be at the same depth.  Also note that there are no semicolons at the end of the chained functions because otherwise the statement would be finished and the object reference lost.</p>
<p>You might expect <code>res</code> to be similarly chainable but, unfortunately it is not. the <code>write</code> method does return information while the other two used here return <code>undefined</code>, which is a waste.</p>
<h2><a class="self-ref" id="chapter02-and-finally" href="#chapter02-and-finally"># </a>... and finally</h2>
<p>We can shorten our code even more:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-03/server/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-03</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const http = require('http');

const PORT = 8080;

http.createServer((req, res) =&gt; {
    console.log(`Received request for ${req.url}`);
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.write('Hello World!\n');
    res.end(`Received request for ${req.url}`);
  })
  .listen(PORT, () =&gt; {
    console.log(`Server running at http://localhost:${PORT}/`);
  });</code></pre>:</div>
<p>Subscribing to the <code>request</code> and <code>listening</code> events is such a frequent thing to do that the developers of the <code>http</code> module have made it easier, we just pass the request handler function to the <code>createServer</code> method and the <code>listening</code> callback to the <code>listen</code> method.  Also, we don't actually need to check for the <code>error</code> argument because most of the errors at that stage simply produce fatal errors and the application will terminate before we have any chance to do something about it.</p>
<h2><a class="self-ref" id="chapter02-summary" href="#chapter02-summary"># </a>Summary</h2>
<p>We have seen how easy it is to have a web server up and running using plain NodeJS without any extras, which is due to several features built into NodeJS, such as its <em>module</em> system, and, most important of all, the <em>event loop</em>.</p>
<p>We have also seen some standard coding practices such as the use of <em>callbacks</em> and <em>chaining</em>.</p>
<h1><a class="self-ref" id="chapter03-npm-packages" href="#chapter03-npm-packages"># </a>NPM Packages</h1>
<p>So far we have written a very primitive web server and we could go on and make it really useful, but that would be a real waste of effort to repeat standard behavior and we don't want to re-invent the wheel.  Instead, we will use one of NPM's most popular packages, <a href="https://www.npmjs.com/package/express">Express</a>.</p>
<p>We also want to keep a record of what packages we install for our application so that anyone else can set it up in the same way.  NPM uses a file called <code>package.json</code> to do that.</p>
<p>To create our <code>package.json</code> file, we go to the root of our project and type <code>npm init</code> and answer a few questions.  It is not crucial that we answer them right the first time, the file is editable and we can change much of it later on.  NPM will offer defaults for each answer which we might accept by pressing <kbd>Enter</kbd> so, if you are not sure about something, simply accept what NPM offers.</p>
<p>NPM knows about Git and GitHub so it will link to the repository created in chapter 1.  It also adds an entry for bug tracking:</p>
<pre><code class="language-json">&quot;bugs&quot;: {
  &quot;url&quot;: &quot;https://github.com/Satyam/book-react-redux/issues&quot;
},
</code></pre>
<p>Bug tracking is one of many extras offered by GitHub beyond serving Git requests.  In the current version of GitHub, a series of tabs at the top of the page allow you to access several features of any project.  So far we have seen the <code>Code</code> tab but there are several others such as <code>Issues</code>, <code>Wiki</code> or <code>Graphs</code> that are very useful.  The <code>Settings</code> tab allows us to decide which of these features we want in our repositories.</p>
<p>The <code>package.json</code> file is in <a href="http://www.json.org/">JSON</a> format, a data -interchange format first devised by Douglas Crockford and now an ECMA standard. The file is made of simple text so it is editable.  Open it up to have a look at it.  You will easily find out where most of the responses you provided to <code>npm init</code> have gone.</p>
<p>Now we may fix some of them.  NPM suggests version <code>1.0.0</code>.  Those numbers follow the <a href="http://semver.org/">semver</a> <em>semantic versioning</em> standard. The first number is called the <em>major version</em>.  A major version of 1 at this point would be somewhat presumptuous from us since it would suggest it is a finished product in its first release.  We can change that to <code>0.1.0</code> or something like that.  A major version of 0 clearly states that it is still a prototype.</p>
<h2><a class="self-ref" id="chapter03-running-the-script" href="#chapter03-running-the-script"># </a>Running the script</h2>
<p>Something else we might want to change is the <code>&quot;main&quot; : &quot;index.js&quot;</code> entry.  That came from the prompt <code>entry point: (index.js)</code>.  Lets change it to <code>&quot;main&quot; : &quot;server/index.js&quot;</code>. Save the change and go to a terminal/ command prompt and type <code>node .</code>.  The server will now be started.  Originally, we had to do <code>node server</code> or <code>node server/index.js</code>.  When given a folder instead of a full file name, NodeJS actually looks first for a file called <code>package.json</code> for the <code>main</code> entry and if it doesn't find it, only then it goes searching for an <code>index.js</code> which is what we've been doing so far.  Now that we do have a <code>package.json</code> we can let NodeJS find it for us.  Note the dot at the end of <code>node .</code>, otherwise, NodeJS runs in interactive mode and prompts us for input.</p>
<p>The main entry point declared in <code>package.json</code> is mostly used for libraries, that is, when your code is meant to be depended upon, not when doing an application.  To start running an application, it is much better to use the <code>scripts.start</code> property.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-01/package.json#L6-L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
},</code></pre></div>
<p>The <code>npm init</code> command already created a <code>scripts.test</code> property which we will use later on.  We simply add the <code>start</code> entry whose value is the command to start the server.  Then we can do:</p>
<pre><code class="language-bash">npm start
</code></pre>
<p>and the server will start.  Using the <code>npm start</code> command for running applications is  the recommended way. Most developers, when looking at your application, on seeing a <code>package.json</code> file will expect to find the command to start your application there.</p>
<p>Actually, <code>npm start</code> is a shortened form of <code>npm run start</code>. The <code>npm run xxxx</code> command will look for a <code>xxxx</code> property in the <code>scripts</code> object and execute the string it finds there. Doing <code>npm run</code> without any extra arguments will list all the available scripts. Only a few of them have shortened forms: <code>npm start</code>, <code>npm restart</code>, <code>npm stop</code> and <code>npm test</code>.</p>
<p>There are also a series of <em>pre</em> and <em>post</em> entries that, if found, will be executed automatically before and after some other commands are run.  You can check them out in the <a href="https://docs.npmjs.com/misc/scripts">NPM manual</a>.</p>
<p>There is an extra benefit of running commands from NPM.  All of the information in the <code>package.json</code> file will be available to the program being run with the <code>npm_package_</code> prefix with underscores instead of dots separating the properties.  For example, you can read <code>npm_package_version</code> or <code>npm_package_scripts_start</code>.</p>
<p>You can freely add your own properties though, to avoid conflicts with existing options, it is better to use your own property object name. The <code>config</code> property already exists so avoid using that one.  Existing properties are all lowercase so mixing some uppercase characters is a good idea, for example:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-01/package.json#L10-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 10</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-json">"myWebServer": {
  "port": 8080
},</code></pre></div>
<p>Our server program can now have:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-01/server/index.js#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">const PORT = process.env.npm_package_myWebServer_port || 8080;</code></pre></div>
<p>This will allow other team members to easily find configuration options without having to go looking into the source files.</p>
<h2><a class="self-ref" id="chapter03-installing-dependencies-express" href="#chapter03-installing-dependencies-express"># </a>Installing dependencies: Express</h2>
<p>As mentioned earlier, NodeJS comes with some packages pre-installed such as <code>http</code> which we have used earlier.  For extra packages, we have to use NPM to install them.  For <a href="https://www.npmjs.com/package/express">Express</a>, we do:</p>
<pre><code class="language-bash">npm install express --save
</code></pre>
<p>The command <code>npm install</code> will look for the package name in the <a href="https://www.npmjs.com/">NPM registry</a> and, if found, download and install it. The name given in the command should be exactly as in the heading of the entry in the NPM registry for Express it should be <a href="https://www.npmjs.com/package/express">express</a>.  The <code>--save</code> option instructs the installer to save the reference to that package in our <code>package.json</code> file.  If we take a look at it, we may see that it now has the following added:</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;express&quot;: &quot;^4.13.4&quot;
}
</code></pre>
<p>This is how NPM keeps track of the extra modules it loads, it means that our app needs the <code>express</code> package version <code>4.13.4</code> or higher up to, but not including, any <code>5.y.z</code>.  Changes in the major version usually mean there might be some incompatible changes with the previous one so, once you program for a particular major version, you want to keep within that one.</p>
<p>Once the <code>npm install</code> command finishes, it shows what it has done, listing the module it has downloaded plus all its dependencies.  Each entry contains the registered name of the package and the version it has actually installed.</p>
<p>Now you will find an extra folder in your project called <code>node_modules</code> and inside it, a folder called <code>express</code>.  That is where the downloaded package has gone.  Each package will also have its own <code>package.json</code> file and its <code>node_modules</code> folder with its dependencies, each of which will have its <code>package.json</code> file and its <code>node_modules</code> and so on.</p>
<p>Let us add some other packages.  The following are optional sub-modules of Express itself which we will use later on.  Do:</p>
<pre><code class="language-bash">npm install body-parser --save
npm install cookie-parser --save
</code></pre>
<p>The <code>package.json</code> file will now show more dependencies:</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;body-parser&quot;: &quot;^1.15.0&quot;,
  &quot;cookie-parser&quot;: &quot;^1.4.1&quot;,
  &quot;express&quot;: &quot;^4.13.4&quot;
}
</code></pre>
<p>and the <code>node_modules</code> folder will contain a folder for each of those extra packages.</p>
<p>One of the benefits of the <code>package.json</code> files is that it records all the dependencies so that anyone can recall them.  Lets go and delete the <code>node_modules</code> folder. Now, we don't have any of the dependencies. However, we still have the <code>package.json</code> file so we can reestablish all the dependencies.  If we now do:</p>
<pre><code class="language-bash">npm install
</code></pre>
<p>with no extra arguments, NPM looks into the <code>package.json</code> file and installs all the dependencies listed in it.</p>
<h2><a class="self-ref" id="chapter03-installing-developer-dependencies-eslint" href="#chapter03-installing-developer-dependencies-eslint"># </a>Installing developer dependencies: ESLint</h2>
<p>The <a href="https://www.npmjs.com/">NPM registry</a> not only contains many packages we can use in our application, it also contains plenty of packages that can help us in the development process.  We will install one such utility: <a href="http://eslint.org/">ESLint</a>.   A <em>linter</em> is a sort of compiler that doesn't actually produce any code, instead, it checks the syntax of the code to warn us of any possible errors and may check style, such as whether the indentation for each line is right.  ESLint is such a <em>linter</em> for <strong>E</strong>CMA<strong>S</strong>cript, thus ESLint.</p>
<p>ESLint is the third generation of linters for JavaScript.  The first one, <a href="http://www.jslint.com/">JSLint</a> was written by the same Douglas Crockford that gave us JSON. However, it had always been a very opinionated product.  It has a limited number of options and many rules are fixed to follow Crockford's preferences, admitting no alternatives.  A more customizable <a href="http://jshint.com/">JSHint</a> followed years later and ESLint, by Nicholas Zakas, is the newest and, by far, the most customizable and flexible of the lot.</p>
<p>Do:</p>
<pre><code class="language-sh">npm install eslint --save-dev
</code></pre>
<p>We have used the <code>--save-dev</code> option instead of simply <code>--save</code>.  This means that this package dependency is meant to help us in development, not for the final product. Using the <code>--production</code> option when doing <code>npm install</code> will not install them (the default is to install all dependencies). In <code>package.json</code> we now have:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/package.json#L35-L40"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 35</div>
    <div class="to">To: 40</div>
  </div>
  <pre><code class="language-json">"devDependencies": {
  "eslint": "^2.7.0",
  "eslint-config-standard": "^5.1.0",
  "eslint-plugin-promise": "^1.1.0",
  "eslint-plugin-standard": "^1.3.2"
}</code></pre></div>
<p>Let us go and add another script <code>lint</code> to <code>package.json</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/package.json#L6-L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "lint": "eslint . || exit 0",
  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
},</code></pre></div>
<p>If we now do:</p>
<pre><code class="language-sh">npm run lint
</code></pre>
<p>We will get one fatal error message on the first <code>const</code> because it is an ES6 keyword and ESLint cannot parse it with its default rules. To find  why there is that <code>|| exit 0</code> after the <code>eslint .</code> command simply delete it and run it again.</p>
<p>To tell ESLint what we want it to do we need to add a <em>rules</em> file.  We can write one of our own or pick one of several standard ones available in the NPM registry, for example:</p>
<pre><code class="language-sh">npm install eslint-config-standard --save-dev
</code></pre>
<p>Though this ESLint rule set is named <code>standard</code> there is no actual standard backing it.  It is a reasonable compilation of many often-used rules but it is not endorsed by any standards body or group.  However, it wouldn't be bad if it were.</p>
<p>This downloads and installs the rules, but it does not tell ESLint that it should follow them.  There are various ways to do that.  In this book we will  add a configuration file <code>.eslintrc.json</code>  containing:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: .eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "extends": "standard",
  "env": {
    "node": true
  },
  "rules": {
    "semi": [1, "always"]
  }
}</code></pre></div>
<p>This tells ESLint that</p>
<ul>
<li>our rules will be an extension of those in <code>eslint-config-standard</code> (the <code>eslint-config</code> prefix can be omited)</li>
<li>that our code is meant to be executed by NodeJS, which helps it make some assumptions about features we will use</li>
<li>that we will customize those same rules by requiring that <a href="http://eslint.org/docs/rules/semi.html">semicolons are always present</a> at the end of statements.</li>
</ul>
<p>There are very many <a href="http://eslint.org/docs/rules/">rules</a> that really allow us to customize our code in any way we want.  Many companies have their internal standards available in the NPM registry, just search for <a href="https://www.npmjs.com/search?q=eslint-config">eslint-config</a> and, at the time or writing this, almost five hundred of such rules are listed.</p>
<p>Though we are using the <code>.json</code> extension on the  ESLint configuration files, ESLint  can do without the extension, figuring out the internal format from reading the contents. It can actually accept files in YAML format instead of JSON and it is quite relaxed about what it accepts as JSON.</p>
<p>Now we can repeat the <code>npm run lint</code> command and it should show no errors.  Change the <code>server/index.js</code> file making some errors and lint it again to see the effect.</p>
<p>Both Brackets and Atom have plugins to have ESLint integrated into the editor window.</p>
<p>JavaScript can manage without semicolons at the end of its statements, it is what is called ASI, <em>Automatic Semicolon Insertion</em>.  It has become fashionable to write code without semicolons and let JavaScript figure out when a statement ends.  It was originally designed to make it more forgiving to sloppy first time coders and it works quite well, but it implies some degree of guessing from the JavaScript interpreter and I don't like ambiguities. Anyway, I can't imagine what could I possibly do in a life already full of much reveling and frolicking with the half a minute or so a day I could shave off my coding time by skipping the semicolons.</p>
<h2><a class="self-ref" id="chapter03-global-installs-eslint" href="#chapter03-global-installs-eslint"># </a>Global installs: ESLint</h2>
<p>Usually, ESLint is installed <em>globally</em> to make it accessible directly as a command in your terminal/command prompt window.  We haven't done it this way to avoid polluting our global space.  <em>Global</em> in NPM parlance means it is installed in a way that can be shared in between all applications within our computer.  It also saves some disk space since only one copy of it is needed for all apps instead of one for each.</p>
<p>To install applications <em>globally</em> we use the <code>-g</code> option on <code>npm install</code> and we don't use the <code>--save</code> or <code>--save-dev</code> options because we don't actually want it listed on our <code>package.json</code> file.  Thus, we would do:</p>
<pre><code class="language-bash">npm install -g eslint
npm install -g eslint-config-standard
</code></pre>
<p>These two commands will install both ESLint and the <code>standard</code> set of rules in a shared folder (<code>/usr/lib/node_modules</code> for Linux users).  We can still have a <code>.eslintrc.json</code> file in our home folder (<code>~/.eslintrc.json</code>) with our preferences so that we can use the <code>eslint .</code> command right from the terminal in any project and check anything anywhere with our home set of rules.</p>
<p>We can still set per-project rules by creating a local <code>eslintrc</code> file extending our own defaults plus adding our own, as we already did:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/.eslintrc.json#L2"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: .eslintrc.json</div>
    <div class="from">From: 2</div>
    <div class="to">To: 2</div>
  </div>
  <pre><code class="language-json">"extends": "standard",</code></pre></div>
<p>ESLint configuration files can go on forever extending one another with the later rules overriding the previous settings.</p>
<h2><a class="self-ref" id="chapter03-ignored-files" href="#chapter03-ignored-files"># </a>Ignored files</h2>
<p>Looking at our GitHub repository <a href="https://github.com/Satyam/book-react-redux/tree/chapter-03-02">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> once we committed and pushed all these changes, we can see that there is no <code>node_modules</code> folder, which is a good thing since, at this point, it has about 17MB of data and it makes no sense to put a copy of all that in GitHub.  After all, the <code>npm install</code> command can easily reconstruct it from the dependencies listed in <code>package.json</code>.</p>
<p>That trick is thanks to the <code>.gitignore</code> file which is a list of file patterns of files and/or folders that Git should ignore, with comments preceded by sharp <code>#</code> signs.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/.gitignore"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: .gitignore</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-"># Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directory
# https://www.npmjs.org/doc/misc/npm-faq.html#should-i-check-my-node_modules-folder-into-git
node_modules</code></pre></div>
<p><code>node_modules</code> is listed down at the end of the list.  This file was produced by GitHub when we originally created our repository and asked for a <code>.gitignore</code> file for <code>Node</code> which adds NodeJS-specific entries such as <code>node_modules</code>.</p>
<h2><a class="self-ref" id="chapter03-summary" href="#chapter03-summary"># </a>Summary</h2>
<p>We have seen how NPM, the Node Package Manager allows us to leverage thousands of NodeJS packages, in this case, to improve on our previous very basic web server.  We installed Express to add advanced features to our server.</p>
<p>NPM uses the <code>package.json</code> file to store its configuration and it also allows us to use it to store our own application configuration and the commands to start, test and run any script we might need to help in developing or running our application.</p>
<p>There are tools both to run our application as well as to help us develop it.  A <em>linter</em> is one such development tool.  It helps us check our code statically, that is just looking at the source without running it. We installed ESLint and some associated plugins and configurations, saw how this was recorded in <code>package.json</code> and added a script to run it.</p>
<p>Finally, we had a look at <code>.gitignore</code> and how it spares us from uploading unnecessary large volumes of data to GitHub.</p>
<h1><a class="self-ref" id="chapter04-creating-an-express-web-server" href="#chapter04-creating-an-express-web-server"># </a>Creating an Express Web Server</h1>
<p>We will modify our previous web server <a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-03/server/index.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> to use Express:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-01/server/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const http = require('http');
const express = require('express');
const app = express();

const PORT = process.env.npm_package_myServerApp_port || 8080;

app.get('*', (req, res) =&gt; {
  console.log(`Received request for ${req.url}`);
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.write('Hello World!\n');
  res.end(`Received request for ${req.url}`);
});

http.createServer(app)
  .listen(PORT, () =&gt; {
    console.log(`Server running at http://localhost:${PORT}/`);
  });</code></pre></div>
<p>It really doesn't look that much different, we can actually see the difference <a href="https://github.com/Satyam/book-react-redux/commit/aecc6b2b8c800f3be18ab90ac1b03da4c1d63075#diff-0861d6d6b50d7d695344bf2d86d6e5e6">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> in GitHub.</p>
<p>First we load the Express package into the constant <code>express</code> and then create an instance of the Express server by running the default function in the package, which we store in <code>app</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-01/server/index.js#L2-L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 2</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">const express = require('express');
const app = express();</code></pre></div>
<p>That <code>app</code> will handle the requests for us.  When we call <code>createServer</code>, instead of providing a function to handle the <code>'request'</code> event as we did before <a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-03/server/index.js#L5">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we let the Express request handler <code>app</code> to do it for us:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-01/server/index.js#L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-js">http.createServer(app)</code></pre></div>
<p>That allows us to use the <a href="http://expressjs.com/en/guide/routing.html">Express router</a>.  There are four basic methods in the <code>app</code> object that corresponds to HTTP request methods: <code>app.get</code>, <code>app.post</code>, <code>app.put</code> and <code>app.delete</code>. These methods register a callback function to listen to a particular type of request. Each gets as its arguments the path they should respond to and the function to call back when the path is matched.</p>
<p>Here, we have used <code>app.get</code> which is the standard request you get when navigating to a URL.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-01/server/index.js#L7"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 7</div>
  </div>
  <pre><code class="language-js">app.get('*', (req, res) =&gt; {</code></pre></div>
<p>The first argument is a wildcard <code>'*'</code> which means we want to respond to a request for any URL, the second is the very same arrow function we used earlier.  It still receives the very same <code>req</code> and <code>res</code> objects as before, but greatly augmented with very many extra properties and methods.   Using those new methods, we could now write our callback function like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-02/server/index.js#L11-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-02</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">app.get('*', (req, res) =&gt; {
  console.log(`Received request for ${req.url}`);
  res.type('text')
    .status(200)
    .send(`Received request for ${req.url}`);
});</code></pre></div>
<p>The first thing to highlight is that the new methods are now chainable. The <code>type</code> method allows us to set the content type in a far easier way than <code>writeHead</code> did and likewise with <code>status</code>. Though the <code>send</code> method doesn't look that much different from <code>write</code> or <code>end</code> it is actually able to do some extra magic which we will use later on.</p>
<p>There is no limit to the number of routes you can register with the router.  We have added a couple of extra routes:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-02/server/index.js#L7-L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-02</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-js">app.get('/hello', (req, res) =&gt; res.send('Hi, long time no see!'));

app.get('/bye', (req, res) =&gt; res.send('See you later'));</code></pre></div>
<p>Now, if we navigate to <code>http://localhost:8080/hello</code> we will get <code>Hi, long time no see!</code> and if we go to <code>http://localhost:8080/bye</code> we get <code>See you later</code>. Since we haven't used neither <code>type</code> or <code>status</code>, Express will assume the default <code>text/html</code> content type and a 200 response status code. Since now the reply is HTML, the browser will show it in a different typeface than it did with the <code>text/plain</code> response.</p>
<p>The syntax of the new ES6 arrow functions allows us to write the callback far more succinctly than before.</p>
<p>Whatever other URL we navigate to, it will fall through to the wildcard response. Express matches the routes in the order they are registered so we should never put a the wildcard first because it would then match all requests and never reach the other responses.  We will rarely use such a catch-all wildcard route except for diagnostics.  The Express router will reply with a regular <code>404 Not Found</code> page if no route matches the requested URL.</p>
<p>The router also supports a <a href="http://expressjs.com/en/guide/routing.html#route-paths">limited form</a> of regular expressions.</p>
<h2><a class="self-ref" id="chapter04-request-parameters" href="#chapter04-request-parameters"># </a>Request parameters</h2>
<p>It would be impossible to plan for routes matching all possible queries with variable parts.  Express allows for parameters within the routes.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-03/server/index.js#L7"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-03</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 7</div>
  </div>
  <pre><code class="language-js">app.get('/hello/:name?', (req, res) =&gt; res.send(`Hi ${req.params.name}, long time no see!`));</code></pre></div>
<p>A segment of a path with a leading colon <code>:</code> and up to the next slash <code>/</code> represents a parameter. Express will accept anything in that position and will save it in the <code>req.params</code> object under the given parameter name.  The above will match <code>http://localhost:8080/hello/John</code> and reply with <code>Hi John, long time no see!</code>, however it will not match our previous <code>http://localhost:8080/hello</code> because there is no <code>/:name</code> parameter.  Parameters must be there for the route to match. However, a question mark <code>?</code> after the parameter name makes it optional.</p>
<p>Express will also accept any mix of fixed and variable parts:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-03/server/index.js#L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-03</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 9</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-js">app.get('/elect/:fname/:lname?/for/:position', (req, res) =&gt; res.send(req.params));</code></pre></div>
<p>With such a route, navigating to <code>http://localhost:8080/elect/joe/doe/for/mayor</code> will produce <code>{&quot;fname&quot;:&quot;joe&quot;,&quot;lname&quot;:&quot;doe&quot;,&quot;position&quot;:&quot;mayor&quot;}</code> and it will also accept <code>http://localhost:8080/elect/joe/for/mayor</code> resulting in <code>{&quot;fname&quot;:&quot;joe&quot;,&quot;position&quot;:&quot;mayor&quot;}</code>. The <code>send</code> method is smart enough to convert the <code>req.params</code> object to JSON when sending it.</p>
<p>Express will also look for query parameters (the part of the URL after the question mark). Query parameters do not affect the route.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-03/server/index.js#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-03</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-js">app.get('/search', (req, res) =&gt; res.send(`You are searching for "${req.query.q}"`));</code></pre></div>
<p>In response to <code>http://localhost:8080/search?q=whatever</code>, it will respond with <code>You are searching for &quot;whatever&quot;</code>.  In response to <code>http://localhost:8080/search</code> it will reply <code>You are searching for &quot;undefined&quot;</code>.</p>
<p>Express cannot retrieve the part of the URL after the hash <code>#</code> mark since browsers do not send that to the server but handle it locally once the page has arrived.</p>
<h2><a class="self-ref" id="chapter04-using-middleware" href="#chapter04-using-middleware"># </a>Using Middleware</h2>
<p>The functionality offered by Express can be extended via <em>middleware</em>. Only one comes prepackaged, <a href="http://expressjs.com/en/4x/api.html#express.static"><code>express.static</code></a>:</p>
<pre><code class="language-js">app.use(express.static(path.join(__dirname, '../public')));
</code></pre>
<p>We are telling Express to <code>use</code> the <code>express.static</code> middleware which should serve static files from the <code>/public</code> folder within our project folder.  Middleware is registered in Express just like routes so the order is important. In general, our dynamic responses have to go first, otherwise Express might assume they are file requests.  Only if no route matches should Express look for static files.</p>
<p>The <code>path.join</code> function is part of NodeJS but it is not loaded by default so we had to add <code>const path = require('path');</code> to make it available.</p>
<p>We have dropped the wildcard route at the end of the list of routes because we are now serving actual files for everything but our matched routes or returning a <code>404 Not Found</code> error otherwise.  We now have a home page at <code>/public/index.html</code> <a href="https://github.com/Satyam/book-react-redux/tree/chapter-04-04/public">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. We could also put a <code>favicon.ico</code> there so it gets shown in the address bar.</p>
<p>We will add more middleware to our server which we first load:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L5-L6"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 6</div>
  </div>
  <pre><code class="language-js">const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');</code></pre></div>
<p>and then use:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L12-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 12</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">app.use(bodyParser.urlencoded({extended: false}));
app.use(cookieParser());</code></pre></div>
<p>Unlike the <code>express.static</code> middleware, we put these two before our dynamic routes because we want them to have the request processed for any request. They don't send anything back to the browser. They act like filters, pre-processing the information received before it gets acted upon.</p>
<p>So far we have only dealt with HTTP GET requests and the information that comes encoded in the URL itself.  <a href="https://github.com/expressjs/body-parser#body-parser"><code>body-parser</code></a> allows us to access the information sent in the body of the request. When there is information sent in the body and it can be decoded, <code>body-parser</code> will populate the <code>req.body</code> object.</p>
<p>The body can be sent encoded in various ways and the <code>body-parser</code> middleware provides several decoders.  The original middleware tried to figure out how the body was encoded and produce some sort of result, which wasted processing time.  Now, we have to explicitly state which parser to use.  All parsers can be added and each will give it a try in turn. If a filter fails, it doesn't reject a request, it simply lets it pass through so other filter, if there is any other one after, can try.</p>
<h2><a class="self-ref" id="chapter04-reading-data-from-a-form" href="#chapter04-reading-data-from-a-form"># </a>Reading data from a form</h2>
<p>Our home page now has a form with a single input field in it:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/public/index.html#L10-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: 10</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-html">&lt;form method="post" action="form"&gt;
  &lt;input name="field1"/&gt;
&lt;/form&gt;</code></pre></div>
<p>The value of that field will be posted to the <code>/form</code> path, where we can read it:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 23</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">app.post('/form', (req, res) =&gt; res.send(`You have entered "${req.body.field1}"`));</code></pre></div>
<p>Here we have used <code>app.post</code> instead of <code>app.get</code> as we've done so far since that is the method declared in the <code>&lt;form method=&quot;post&quot;&gt;</code> tag.</p>
<p>Middleware can also be restricted to respond to specific routes.  For example, all our data <em>post</em>s and <em>put</em>s will go in JSON to the <code>/data</code> route so we limit our decoding to just that route leaving the rest to be url-decoded:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-js">app.use('/data', bodyParser.json());</code></pre></div>
<p>We have also added the <a href="https://github.com/expressjs/cookie-parser"><code>cookie-parser</code></a> middleware which reads the cookies we might have sent in earlier responses via <a href="http://expressjs.com/en/api.html#res.cookie"><code>res.cookie</code></a> and makes them available in the <code>req.cookies</code> object.</p>
<p>We now have the <code>http://localhost:8080/cookie</code> path to read and increment the <code>chocolateChip</code> cookie count and <code>http://localhost:8080/naughtyChild</code> to clear it.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L25-L36"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 25</div>
    <div class="to">To: 36</div>
  </div>
  <pre><code class="language-js">app.get('/cookie', (req, res) =&gt; {
  var chocolateChips = parseInt(req.cookies.chocolateChip || 0, 10);
  res
    .cookie('chocolateChip', chocolateChips + 1)
    .send(`I now have ${chocolateChips} chocolate chip cookies`);
});

app.get('/naughtyChild', (req, res) =&gt; {
  res
    .clearCookie('chocolateChip')
    .send('No cookies for you');
});</code></pre></div>
<h2><a class="self-ref" id="chapter04-summary" href="#chapter04-summary"># </a>Summary</h2>
<p>We have seen how to create an Express server and tell it how to respond to various URLs and how to read extra query parameters.</p>
<p>We have also learned about <em>middleware</em> how to load it and use it in our web server.  We've seen how to load and use the body and cookie parser middleware besides the built int <em>static</em> middleware.</p>
<p>We have used the body parser middleware to be able to decode information received from an HTML form and manipulated information in <em>cookies</em> via the cookie parser.</p>
<h1><a class="self-ref" id="chapter05-rest" href="#chapter05-rest"># </a>REST</h1>
<p>Representational State Transfer, <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> is the standard way in which plain data, that is, not formatted for human consumption, is requested and transfered in the Web.</p>
<p>Every piece of data in the web can have an URL (or more precisely an URI, but we won't dwell on the difference) and from previous chapters, we know how we can respond to any URL our server receives.</p>
<p>Once we identified the data, we need to tell the server what to do with it. We have the HTTP request codes for that.  In data handling terms we have four basic operations known by their initials: Create, Read, Update and Delete (CRUD).  These map one to one with the HTTP request methods we've already mentioned though, unfortunately, they don't result in any acronym we could use:</p>
<ul>
<li>Create: POST</li>
<li>Read: GET</li>
<li>Update: PUT</li>
<li>Delete: DELETE</li>
</ul>
<p>So, if we do a GET to our server for, say, <code>/employees</code> we will get a list of all employees, but if we ask for <code>/employees/123435</code> we will get more detailed information about an employee with that record number.  If we POST an employee record to <code>/employees</code> it means we want to create a record for a new hire.  The server will respond with the record number it assigned to that employee (assuming, as it is often the case, that it is the server that assigns the record identifier). If we do a DELETE on <code>/employees/123435</code> that record would be deleted while if we do a PUT along some information, for example, a new home address because the employee has moved, the record for that employee would get updated.  In theory this scheme can be stretched to absurd limits <code>/employees/12345/lname/2</code> might mean the second character of the last name of that particular employee which just serves to show how generic and flexible URIs can be though it would be impractical to stretch it that far.</p>
<p>REST requests can be further qualified with query parameters.  For example, a GET on <code>/employees?search=lname%3DSmith</code> instead of bringing up the list of all employees, it would only return the results of performing the database search for employees whose last name is Smith: <code>lname=Smith</code> (the <code>%3D</code> is the url-encoding of the equals sign).</p>
<p>We might handle further qualifiers, for example, <code>/employees?search=lname%3DSmith&amp;fields=fname,ZIPcode</code> would return the names and postal codes for all the Smiths in the database.</p>
<p>It is also important to know who is asking for the information.  Nobody wants their salaries disclosed to just about anyone.  So, beyond what the URL says, the server has to decide whether someone can access or change some particular piece of information.  Usually this is done through <em>cookies</em>.  In the previous chapter we have already seen how to deal with cookies <a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L25-L36">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> using the <code>cookie-parser</code> middleware.  After the user is positively identified (logs in) we send as a cookie some temporary token that allows us to recognize that user during one particular session, and know his/her permissions.</p>
<p>Defining what URLs we support and the expected responses is a very important part of defining a project.  Many large web services companies have very well defined public APIs, for example <a href="https://developer.github.com/v3/repos/">GitHub</a> or <a href="https://developers.google.com/gmail/api/v1/reference/">Google</a>, though some might adopt some <a href="http://wiki.freebase.com/wiki/Mql">proprietary format</a>.</p>
<p>Defining our API also allows us to split the responsibility of the project in between separate people, the server-side team dealing with responding to these requests and the client-side team taking care of requesting and presenting this information to the user and translating the user commands into server requests. The REST API is the contract in between these two teams.</p>
<h2><a class="self-ref" id="chapter05-defining-our-rest-api" href="#chapter05-defining-our-rest-api"># </a>Defining our REST API</h2>
<p>First, we have to separate our data requests from any other request our web-server might have to serve. Thus, the root for all our data requests will be <code>/data</code>.  This doesn't mean we have to create a folder of that name, it is simply a path our server will respond to.</p>
<p>Occasionally, it is a good idea to reflect on our own fallibility. We might get things wrong and if we define our API too rigidly, we might get in trouble. To be able to change our API in the future it is better to include a version number in our API requests so, if we ever have to change it, we change the version number. For a certain time, we can respond to requests in either format, both versions coexisting until everything gets updated and the old version finally gets dropped.  For this API we will then use the prefix <code>/data/v1</code>.</p>
<p>For our application, we will have a series of projects and for each project a series of tasks to perform.  This is just a twist on the popular TODO list application with one such TODO list for each of our projects.  This would be our API:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>URL</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><code>/projects</code></td>
<td>Returns a list of project ids, names and descriptions</td>
</tr>
<tr>
<td>GET</td>
<td><code>/projects/:pid</code></td>
<td>Returns the name and description of the given project and its list of tasks, providing their id, description and completion status</td>
</tr>
<tr>
<td>GET</td>
<td><code>projects/:pid/:tid</code></td>
<td>Returns the task id, description and completion status for a particular task within a particular project</td>
</tr>
<tr>
<td>POST</td>
<td><code>/projects</code></td>
<td>Accepts the name and description for a new project, returns project id</td>
</tr>
<tr>
<td>POST</td>
<td><code>/projects/:pid</code></td>
<td>Accepts the description and completion status for a new task for a given project, returns the id for the new task. Completion status defaults to false.</td>
</tr>
<tr>
<td>PUT</td>
<td><code>/projects/:pid/:tid</code></td>
<td>Updates the given task with the information in the body</td>
</tr>
<tr>
<td>DELETE</td>
<td><code>/projects/:pid/:tid</code></td>
<td>Deletes the given task</td>
</tr>
<tr>
<td>DELETE</td>
<td><code>/projects/:pid</code></td>
<td>Deletes the given project and all its tasks</td>
</tr>
</tbody>
</table>
<p>The REST standard doesn't really force you to do things in any particular way.  For example, deleting a project should also delete all existing tasks or should it fail if the task list is not empty?  When creating a new record, which fields are mandatory and which have defaults?  That behavior has to be described.</p>
<p>Optional query parameters should also be specified such as those that allow queries by field value or to enumerate the fields to be returned, as we commented earlier.</p>
<h2><a class="self-ref" id="chapter05-loading-sample-data" href="#chapter05-loading-sample-data"># </a>Loading sample data</h2>
<p>For the time being, we will store our information in memory.  This is certainly not practical for any real-life application, but it will help us concentrate on issues other than data storage. Our data comes from a JSON file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/data.json">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which we will read and keep in memory.</p>
<p>We need to load the <a href="https://nodejs.org/docs/latest/api/fs.html">File System</a> package which is included in the NodeJS distribution so we don't need to install it via NPM.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L6"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 6</div>
    <div class="to">To: 6</div>
  </div>
  <pre><code class="language-js">const fs = require('fs');</code></pre></div>
<p>We then use the <code>readFile</code> method to read the full file.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L10-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">fs.readFile(path.join(__dirname, 'data.json'), (err, data) =&gt; {
  if (err) {
    console.error(err);
    process.exit(1);
  }
  global.data = JSON.parse(data);</code></pre></div>
<p>To compose the pathname to the file we use the <a href="https://nodejs.org/docs/latest/api/path.html#path_path_join_path1_path2"><code>path.join</code></a> method in a similar way we did when we set the folder to fetch static content from.</p>
<p>The <code>readFile</code> method is asynchronous so we have to provide a callback for it to tell us when the read has succeeded.  In most NodeJS async methods, the first argument is an error object which, if it is not <code>null</code>, means the operation has not succeeded.  If that is the case, we show the error and exit.  Otherwise, the second argument <code>data</code> will contain the full contents of the file.  Since it is in JSON, we parse it and save it to <code>global.data</code>.</p>
<h2><a class="self-ref" id="chapter05-global-variables" href="#chapter05-global-variables"># </a>Global variables</h2>
<p>As it name implies, <a href="https://nodejs.org/docs/latest/api/globals.html"><code>global</code></a> is NodeJS global object, available everywhere, much as the <code>window</code> object is in a browser.  Every property of <code>global</code> is accessible just by name, for example, there is <code>global.setTimeout</code> just like there is a <code>window.setTimeout</code> in the browser and both can be called by its name, <code>setTimeout</code>, the global name being implicit.  We have already used a couple of such properties.  Both <code>__dirname</code> and, to some extent, <code>require</code> are properties of <code>global</code>.</p>
<p>We can make our own properties globally accessible just by setting them as properties of <code>global</code>, we just have to make sure we are not colliding with an existing property.  Since we are going to use the data we've just read everywhere, it makes sense to make it globally accessible.</p>
<p>ESLint will complain about using the global variable <code>data</code>.  ESLint knows about the standard, well-known global names for <a href="http://eslint.org/docs/user-guide/configuring#specifying-environments">whichever environment</a> we are working on, that is why we specified that our environment would be <code>node</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/.eslintrc.json#L3-L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: .eslintrc.json</div>
    <div class="from">From: 3</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-json">"env": {
  "node": true
},</code></pre>.</div>
<p>If there is anything beyond those globals, it will flag it as an <em>undeclared</em> variable, which usually signals a typo.  To prevent that, we add our own list of globals (for the time being just <code>data</code>) to <code>eslintrc.json</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/.eslintrc.json#L9-L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: .eslintrc.json</div>
    <div class="from">From: 9</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"globals": {
  "data": false
}</code></pre></div>
<p>The <code>false</code> value means we don't want this global variable written, only read.  This might sound strange, how do we set it if it is read-only?  When we set it we did <code>global.data = .... whatever</code>. ESLint doesn't mind us changing the <code>data</code> property of the <code>global</code> object, it would have complained if we did <code>data = ...</code> even though both amount to the same thing.</p>
<p>Our earlier server code has been trimmed of all those <code>app.get( ...</code> routes we had put there to try out different features, which we don't need any more.  There is another change that might pass unnoticed, the earlier code is now contained within the callback function <a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L11-L30">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  This is because only if and when we succeed reading the <code>data.json</code> file it makes any sense to start the web server.  It would make no sense to start it if there is no data to serve.</p>
<h2><a class="self-ref" id="chapter05-writing-a-module-to-respond-to-rest-requests" href="#chapter05-writing-a-module-to-respond-to-rest-requests"># </a>Writing a module to respond to REST requests</h2>
<p>The Express server has a default router which we have been using so far.  All those <code>app.get</code> we wrote earlier are registered with the default router which will dispatch each of the callbacks according to the full path in the URL received.  When we have many routes sharing the very same prefix, in this case <code>/data/v1</code>, it is inefficient (and boring) to repeat it over and over again.  For these cases we can create an additional router that will respond to that prefix and will deal with the rest of the path from that point on.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L19-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 19</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">const projectsRouter = express.Router();
  app.use('/data/v1/projects', projectsRouter);

  const projects = require('./projects.js');
  projects(projectsRouter);</code></pre></div>
<p>First, we request a new router instance from Express which we call <code>projectsRouter</code>.  We tell our instance of the Express server to <code>use</code> that router to deal with paths starting with <code>/data/v1/projects</code>.  Finally, we call <code>projects</code> and provide it with this router instance.</p>
<p>Where did <code>projects</code> came from?  It is a module we created ourselves. We loaded it right before we used it via:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-js">const projects = require('./projects.js');</code></pre></div>
<p>The <code>projects</code> come from the file <code>./projects.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which we created ourselves.  When the <code>require</code> function gets a module name starting with <code>.</code> or <code>/</code> it will not search for that module in the usual places ( NodeJS built-in library or <code>node_modules</code>) but will assume you are providing a full file name to a very specific file and load that one instead.</p>
<p>Loading modules in NodeJS is not the same as loading them in the browser via the <code>&lt;script&gt;</code> tag. In the browser, everything in the loaded file gets merged into whatever is already there, as if all those JavaScript files were concatenated together. This can get quite messy as all the variables declared in all files get into the same name space, possibly colliding with one another.</p>
<p>In NodeJS when you <code>require</code> another module, you only get to see whatever the loaded file exports.  In our sample, we export a <em>fat arrow</em> function which will receive our router instance.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">module.exports = (router) =&gt; {</code></pre></div>
<p>Since what we exported is a function, on the other side, we can execute it:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 23</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">projects(projectsRouter);</code></pre></div>
<p>For example, if we receive a request for <code>/data/v1/projects</code> the <code>projectsRouter</code> will recognize it is the path it is meant to respond to and pass on the implicit <code>/</code> at the end.  We then respond to the <code>/</code> path like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L5-L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-js">router.get('/', (req, res) =&gt; {
  res.json(Object.keys(data).map((pid) =&gt; ({
    pid: pid,
    name: data[pid].name,
    descr: data[pid].descr
  })));
});</code></pre></div>
<p>We use <code>Object.keys</code> list all the keys in the <code>data</code> object, which happen to be the <code>pid</code>s.  <code>Object.keys</code> returns an array and we use the <code>map</code> method of this Array instance.  We then use the <code>pid</code> to assemble each item in the response with the <code>pid</code> then the <code>name</code> and description <code>descr</code>.  Since <code>data</code> was set as a global earlier we can use it freely here.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L15"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 15</div>
  </div>
  <pre><code class="language-js">global.data = JSON.parse(data);</code></pre></div>
<p>We can use <code>res.send</code> instead of <code>res.json</code> since when Express is requested to send an Object or an Array, it will send it JSON-encoded.  However, it is better to state our intent as clearly as possible.</p>
<p>We can try it out by starting our server via <code>npm start</code> and then, in a browser go to <code>http://localhost:8080/data/v1/projects</code> which will show in our browser more or less like this:</p>
<pre><code class="language-json">[{&quot;pid&quot;:&quot;25&quot;,&quot;name&quot;:&quot;Writing a Book on Web Dev Tools&quot;,&quot;descr&quot;:&quot;Tasks required to write a book on the tools required to develop a web application&quot;},{&quot;pid&quot;:&quot;34&quot;,&quot;name&quot;:&quot;Cook a Spanish omelette&quot;,&quot;descr&quot;:&quot;Steps to cook a Spanish omelette or 'tortilla'&quot;}]
</code></pre>
<p>It might not look good but it is not meant to be seen by humans, it is meant for our client-side code to read.</p>
<p>For our second route <code>'/:pid'</code> we need to access the <code>pid</code> which we do by using <code>req.params.pid</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L13-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">router.get('/:pid', (req, res) =&gt; {
  const prj = data[req.params.pid];
  if (prj) {
    res.json(prj);
  } else {
    res.status(404).send(`Project ${req.params.pid} not found`);
  }
});</code></pre></div>
<p>If we find no actual project for that number, we respond with a regular <code>404</code> HTTP response code, however, in this case it is not a page that was not found but a specific project.</p>
<p>We respond very much the same way for the next route either with the task data or a 404 error when the project or the task is not found.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L22-L34"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 34</div>
  </div>
  <pre><code class="language-js">router.get('/:pid/:tid', (req, res) =&gt; {
  const prj = data[req.params.pid];
  if (prj) {
    const task = prj.tasks[req.params.tid];
    if (task) {
      res.json(task);
    } else {
      res.status(404).send(`Task ${req.params.tid} not found`);
    }
  } else {
    res.status(404).send(`Project ${req.params.pid} not found`);
  }
});</code></pre></div>
<p>For a POST operation, i.e.: adding a new record, we have to receive data, not send it.  We cannot receive large amounts of data via the URL as we have been doing with the few parameters we have been using so far.  To be able to receive data we need to access it from the body.</p>
<p>We have access to <code>req.body</code> because we already loaded the <code>body-parser</code> middleware.  Since we are only going to use JSON on the REST data exchanges, we will parse JSON  only on the <code>/data</code> path.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L17"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 17</div>
    <div class="to">To: 17</div>
  </div>
  <pre><code class="language-js">app.use('/data', bodyParser.json());</code></pre></div>
<p>We don't include the version part of the path since it is fair to assume that other versions would use the same data format.  Most middleware such as <code>body-parser</code> is quite versatile and tolerant.  If in a later version  we decide to use another data format, instead of failing, <code>body-parse</code> will let it go through, expecting that some later parser might deal with it.  Also, if we want to parse JSON on another path, we can add as many instances of <code>body-parser</code> elsewhere as needed.</p>
<p>To create a new project  we first try to create a new project id <code>pid</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L36-L41"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 36</div>
    <div class="to">To: 41</div>
  </div>
  <pre><code class="language-js">router.post('/', (req, res) =&gt; {
  const pid = nextId++;
  const prj = Object.assign({name: '', descr: ''}, req.body || {});
  data[pid] = prj;
  res.json({pid: pid});
});</code></pre></div>
<p>We get it from the variable <code>nextId</code> which we set at the very top of the file to a number larger than any ID in the data file.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">var nextId = 100;</code></pre></div>
<p>We increment that value as soon as we read from it.  It might seem strange that we go through so much trouble to get a <code>pid</code> when we might as well push the new record into an Array of projects and figure out its position.  As it happens, we don't want to use an Array even though our indexes are numeric, because items within an array can move and what now has index 10 may become 9 after record 5 is deleted.  Though within JavaScript empty Array slots take no memory, there is no way to skip over empty slots in JSON.  We want our <code>pid</code>s and <code>tid</code>s to be permanent and not be just temporary indexes.  That is why we take the trouble of producing unique, permanent IDs.  In an SQL database, we would use an auto-increment integer field, in a noSQL database, we would take whatever unique record identifier that the database generated for us.</p>
<p>We build our new record using <code>Object.assign</code> to merge a couple of default values with the data coming from the client in <code>req.body</code>.  Since there might be no data (we might want to validate for that) we also default to an empty object.</p>
<p>We then store that project record into the array at the position given by our new <code>pid</code> and return that <code>pid</code> to the client.</p>
<p>For updating records via <code>put</code> we first locate the existing record (project or task) and use <code>Object.assign</code> to merge the new values from <code>req.body</code> into the existing record.  We return an error if the record does not exist.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L54-L62"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 54</div>
    <div class="to">To: 62</div>
  </div>
  <pre><code class="language-js">router.put('/:pid', (req, res) =&gt; {
  const prj = data[req.params.pid];
  if (prj) {
    Object.assign(prj, req.body || {});
    res.json(prj);
  } else {
    res.status(404).send(`Project ${req.params.pid} not found`);
  }
});</code></pre></div>
<p>For deleting we simply delete the whole entry.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L79-L86"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 79</div>
    <div class="to">To: 86</div>
  </div>
  <pre><code class="language-js">router.delete('/:pid', (req, res) =&gt; {
  if (req.params.pid in data) {
    delete data[req.params.pid];
    res.send();
  } else {
    res.status(404).send(`Project ${req.params.pid} not found`);
  }
});</code></pre></div>
<p>We first try to locate the record to be deleted and return an error if not found.  We might have handled things differently.  We might not check for the existence of the record assuming that if not found it has already been deleted, which should be fine as that is what the user wanted.  We might have also returned the old record as it was before deletion though, being a potentially big piece of data, it might be a waste of bandwidth.  If the client code wanted it, it might have gotten it first.</p>
<h2><a class="self-ref" id="chapter05-summary" href="#chapter05-summary"># </a>Summary</h2>
<p>We have learned about the REST (<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer) protocol to accept and respond to data requests from the client.  We have defined the API we will be using in our application.</p>
<p>We have loaded a sample of data and showed how we can read it via suitable URLs.</p>
<p>We have learned how to write our own modules which we can use as well as the ones loaded via NPM.  We wrote one such module to  handle our REST request.</p>
<p>By separating our code into various modules we keep each modules small, focused and thus easy to understand and maintain.</p>
<h1><a class="self-ref" id="chapter06-testing-our-server" href="#chapter06-testing-our-server"># </a>Testing our server</h1>
<p>So far we've tested the server we wrote in a very primitive and limited manner.  We can issue some HTTP GET requests from any browser and get a few responses from our server.  We can even test the REST API, at least the <code>get</code> requests but we can't test much else unless we create actual HTML pages with <code>&lt;form&gt;</code> tags for any of the other methods and input fields with suitable values.  Still, browsers transmit the form's contents url-encoded, not JSON-encoded which is what we will be using, so we can't really do much.</p>
<p>We can just keep going ahead, hoping for the best, and use the client, the one we haven't written so far, to do the testing.  The problem is, we would be testing two previously un-tested elements at once.  If we find something doesn't work, which of them is at fault?  This can be harder if development is split in between two teams.</p>
<p>Testing the REST API is like verifying the deliverables of a contract.  The server-side developers know what is required of their code and they can show it complies.  The client-side developers know that, once tested, the server-code can be trusted.</p>
<p>Moreover, software tends to have a life longer than we could expect. Over that time, issues and bugs might show up and, in attempting to fix them, we might mess up something else.  It is really hard to try this kind of collateral damage because when we fix something and then manually test whether it is fixed we tend to forget or prefer to avoid testing everything else. So, the best thing to do is to automate testing so we can ensure all works as it had before.</p>
<p>Once the basic testing infrastructure is in place, adding further tests is easy.  The first step to fix an issue is to reproduce it, and a new test is the easiest way to do so.  Adding a test to our existing battery can help us understand what went wrong and ensures it won't happen again. Thus, testing also helps us fix new issues by reproducing them and lets us know we have fixed them when they no longer fail.</p>
<p>Looking at our <code>pakage.json</code> file, we can see that the <code>npm init</code> command has already created an entry for a script test.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-01/package.json#L6-L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
},</code></pre></div>
<p>It hasn't added any other placeholders for any of the other possible scripts.  Moreover, the <code>npm test</code> command can be shortened to <code>npm t</code>.  These are indications that at least NPM takes testing seriously.  And so should we.</p>
<h2><a class="self-ref" id="chapter06-loading-testing-software" href="#chapter06-loading-testing-software"># </a>Loading testing software</h2>
<p>We will load several NodeJS packages that will help us in testing.  First of all, <a href="https://mochajs.org/">Mocha</a>, the basic testing framework to run our tests.  The <a href="http://chaijs.com/">Chai</a> package lets us make assertions, that is, ensure our expectations are fulfilled.  Finally, <a href="https://www.npmjs.com/package/axios">Axios</a> allows us to create any kind of HTTP request.  We use NPM to install them:</p>
<pre><code class="language-sh">npm i mocha --save-dev
npm i chai --save-dev
npm i axios --save
</code></pre>
<p>The <code>npm install</code> command can be shortened to <code>npm i</code>.  We have installed the first two packages with the <code>--save-dev</code> options so that they are saved  into <code>package-json</code> as development dependencies along ESLint, all listed in alphabetical order.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/package.json#L36-L43"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 36</div>
    <div class="to">To: 43</div>
  </div>
  <pre><code class="language-json">"devDependencies": {
  "chai": "^3.5.0",
  "eslint": "^2.7.0",
  "eslint-config-standard": "^5.1.0",
  "eslint-plugin-promise": "^1.1.0",
  "eslint-plugin-standard": "^1.3.2",
  "mocha": "^2.4.5"
}</code></pre></div>
<p>Axios, however, was installed with the <code>--save</code> option since it is a package that we will end up using in production so it is a regular dependency.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/package.json#L36-L43"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 36</div>
    <div class="to">To: 43</div>
  </div>
  <pre><code class="language-json">"devDependencies": {
  "chai": "^3.5.0",
  "eslint": "^2.7.0",
  "eslint-config-standard": "^5.1.0",
  "eslint-plugin-promise": "^1.1.0",
  "eslint-plugin-standard": "^1.3.2",
  "mocha": "^2.4.5"
}</code></pre>)</div>
<p>We also need to replace that test script in <code>package.json</code> with something useful.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/package.json#L6-L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "lint": "eslint . || exit 0",
  "test": "mocha"
},</code></pre></div>
<p>It is customary to separate test files from those used in production code so our test files will go into a separate folder.  Unless we explicitly tell Mocha which script file or files to run, it will search for files using the pattern <code>./test/*.js</code> and run all the scripts it finds.</p>
<p>We will place all our test scripts into the <code>/test</code> folder <a href="https://github.com/Satyam/book-react-redux/tree/chapter-06-01/test">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and will start with <code>server.js</code>.</p>
<p>Mocha will add serveral <em>global</em> methods such as <code>describe</code> and <code>it</code> that ESLint doesn't know about, so it will complain about them.  We could add a comment at the beginning of our source files to give instructions to ESLint:</p>
<pre><code class="language-js">/*globals describe:false, it:false, before:false, after:false*/
</code></pre>
<p>However, doing this on each and every test file would become tedious.  ESLint allows us to add extra <code>.eslintrc</code> files in any folder with extra configuration options. When ESLint enters a folder, it first checks for an <code>.eslintrc</code> file there and, if it finds one, it will merge the configuration options in that file with the options it is already working with.  Thus, by adding a <code>.eslintrc.json</code> file in the <code>/test</code> folder we can tell ESLint about our new <em>globals</em>. Actually, this is even easier because ESLint already knows about Mocha so we can just tell it to assume the environment these files are meant to run in is, besides NodeJS, Mocha so that it will immediately accept all of Mocha's globals.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/.eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "env": {
    "node": true,
    "mocha": true
  }
}</code></pre></div>
<p>Then we load the two NPM packages that will help us do the testing, <code>axios</code> and <code>chai</code>.  Chai offers several different syntaxes for writing our assertions, we will use the <code>expect</code> syntax.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L1-L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">const chai = require('chai');
const expect = chai.expect;
const axios = require('axios');</code></pre></div>
<p>To avoid having to repeat the connection configuration over and over again, Axios lets us create a pre-configured http connection instance. Here we can appreciate the advantages of placing our configuration parameters in <code>package.json</code>, both the server and the server testing software can read the <em>port</em> number from the same location.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L7-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">const PORT = process.env.npm_package_myServerApp_port || 8080;

const http = axios.create({
  baseURL: `http://localhost:${PORT}`,
  responseType: 'json'
});</code></pre></div>
<p>To write a test, we start with a description and what should be expected.</p>
<pre><code class="language-js">describe('Static pages test', function () {
  it('Get / should return home page', function () {
</code></pre>
<p>Both <code>describe</code> and <code>it</code> accept a string which will be printed as the tests are executed, in green for success, in red for failed ones.  As the second argument, both expect a callback function. The documentation for Mocha states that we should not use <em>fat arrow</em> functions because Mocha forces <code>this</code> within the callback to a value of its choice that allows us access to several functions. However, if we don't need to use any of those functions (and right now, we don't), we may use <em>fat arrow</em> functions.</p>
<p>Mocha allows for synchronous or asynchronous tests.  All HTTP operations are asynchronous because we don't actually know when the server will respond.  If we don't tell Mocha that a test is asynchronous, it will assume the test is passed when the test function reaches the end without errors, even if the reply from the server is still to arrive.</p>
<p>There are two ways to tell Mocha that a test is asynchronous.  If a test returns a <code>Promise</code>, Mocha will wait for its resolution and report on its success. This is great since Axios returns a Promise. We will explain the other mechanism later on.</p>
<p>Each test file can contain any number of <code>describe</code> calls and each one of those any number of <code>it</code> calls or further <code>describe</code>. Each <code>describe</code> is a <em>test suite</em> and Mocha allows us to define setup and tear down operations that can be done for each suite. We will use those later on.</p>
<p>Our first test is very simple, we will simply check that the server can respond with our simple home page.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L21-L28"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 21</div>
    <div class="to">To: 28</div>
  </div>
  <pre><code class="language-js">it('Get / should return home page', () =&gt;
  http.get('/')
    .then((response) =&gt; {
      expect(response.status).to.equal(200);
      expect(response.headers['content-type']).to.contain('text/html');
      expect(response.data).to.contain('&lt;title&gt;Sample Web Page&lt;/title&gt;');
    })
);</code></pre></div>
<p>We are sending an <code>http</code> <code>get</code> request on the root <code>'/'</code> and we expect the server to respond with a 200 status code, a content type of HTML and somewhere in the body to be that <code>&lt;title&gt;</code> tag. The <a href="http://chaijs.com/api/bdd/">syntax</a> of the calls chained after <code>expect</code> is provided by Chai as a series of keywords that turn out quite readable.</p>
<p>Axios returns a <code>Promise</code> which will be resolved when a reply arrives. The function at the <code>then</code> part of the Promise will then be called. The <code>then</code> is also chainable so it still returns a Promise which we return  so that Mocha itself can chain to it, wait for its completion and report on its success or failure.</p>
<p>It does not look as if we are returning anything to Mocha since there is no <code>return</code> statement, however, one of the changes in <em>fat arrow</em> functions is that if the body of the function is an expression, the <em>fat arrow</em> function implicitly  returns its value.  Normal <code>function</code> functions return <code>undefined</code> if nothing is returned explicitly, which was always somewhat of a waste. These functions are all equivalent:</p>
<pre><code class="language-js">function (x, y) {
  return x * y;
}

(x, y) =&gt; {
  return x * y;
}

(x, y) =&gt; x * y;
</code></pre>
<p>For the last test, we have to somehow turn around the normal response of Mocha because we do expect an error.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L37-L47"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 37</div>
    <div class="to">To: 47</div>
  </div>
  <pre><code class="language-js">it('Get /xyz should return a "page not found" error', () =&gt;
  http.get('/xyz')
    .then(
      (response) =&gt; {
        throw new Error('Should not have found it');
      },
      (response) =&gt; {
        expect(response.status).to.equal(404);
      }
    )
);</code></pre></div>
<p>The <code>then</code> method of a <code>Promise</code> actually accepts two callbacks, one for success, which is the one we usually use, and a second one for failure.  Here, we listen to both outcomes.  In the <em>success</em> callback, which is invalid in this case, we throw an error which Mocha will report.  In the second, we check that the status code on the <em>failed</em> response is, indeed, 404.  Since the failure is caught and supposedly fixed (unless the status code is something else but 404), the <code>Promise</code> is now considered successful and that is what Mocha will report.</p>
<h2><a class="self-ref" id="chapter06-running-the-tests" href="#chapter06-running-the-tests"># </a>Running the tests</h2>
<p>We have to run both the server and the test.  To do that we may either open two terminal windows and run the server via <code>npm start</code> in one of them and then <code>npm t</code> (shorthand for <code>npm test</code>) in the other.  Alternatively, if the operating system allows it, we could run the server in the background doing <code>npm start &amp;</code> and then <code>npm t</code>.</p>
<p>Unfortunately, we cannot simply chain one command after the other <code>npm start &amp;&amp; npm t</code>  because <code>npm start</code> exits when the server may not yet be listening to requests, and the tests might fail. It might succeed, but it is a matter of chance and how fast the machine is.</p>
<p>All these options are really messy.  What we want is for the tests to start and stop the web server when needed.  To do that, we first need to do some minor changes to our server code.</p>
<p>We need to <code>export</code> the server instance so our test has access to it. Before, we had:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L27-L30"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 27</div>
    <div class="to">To: 30</div>
  </div>
  <pre><code class="language-js">http.createServer(app)
  .listen(PORT, () =&gt; {
    console.log(`Server running at http://localhost:${PORT}/`);
  });</code></pre></div>
<p>This created and set the server to listen to requests all at once.  We have to break that into two so we can export the server.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/server/index.js#L8-L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 8</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-js">const server = http.createServer(app);

module.exports = server;</code></pre></div>
<p>We now create the server instance and export it.  Later on, when the data file <code>data.json</code> has been read, we start listening but only if the script was executed directly and not loaded as a module.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/server/index.js#L31-L35"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 31</div>
    <div class="to">To: 35</div>
  </div>
  <pre><code class="language-js">if (require.main === module) {
  server.listen(PORT, () =&gt; {
    console.log(`Server running at http://localhost:${PORT}/`);
  });
};</code></pre></div>
<p>In NodeJS, when <code>require.main</code>, that is the main module, that which has not been required by any other module is this very same <code>module</code> it means it was run from NodeJS.  Only then we call the <code>listen</code> method to set the server to listen for requests.  This prevents the server to start listening immediately when our tests start.</p>
<p>In our test script we require the server as if it was just any other module.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-js">const server = require('..');</code></pre></div>
<pre><code class="language-js">/* Any of these would do just as well:
const server = require('../server');
const server = require('..');
*/
</code></pre>
<p>Since the server, when loaded as a module, will not start listening, we add these two extra commands to our test suite:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L15-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">before('Starting server', (done) =&gt; {
  server.listen(PORT, done);
});
after('Closing the server', (done) =&gt; {
  server.close(done);
});</code></pre></div>
<p>Within each <code>describe</code>, Mocha will look for and execute <code>before</code> callbacks, then it will look for the <code>it</code> tests or further <code>describe</code> test suites and execute those and finally it will call the <code>after</code> callback, if there is any.  There are also <code>beforeEach</code> and <code>afterEach</code> that, if present, will be called not just once per test suite but for each and every individual test within the suite.  We are not using those here.</p>
<p>In our <code>before</code> callback we are telling our server to start listening.  It is the same <code>listen</code> method we used earlier in our web server which accepts a PORT and a callback to let us know when it is ready.  It is an asynchronous operation so we have to tell Mocha to wait until it is finished.  We cannot use the <code>Promise</code> mechanism because we have no <code>Promise</code> to return.  Instead we will use the <code>done</code> mechanism.  When Mocha detects that the test callbacks have accepted an argument, it assumes the test is async and waits for <code>done</code> to be called.  So, we call that <code>done</code> method once the server is ready to listen.  Likewise, we <code>close</code> the server <code>after</code> we are done with the tests.  <code>close</code> is also asynchronous so we accept the <code>done</code> argument and let <code>close</code> call it when it is done.</p>
<p>Now, with <code>npm start</code> we can run the server and with <code>npm t</code> we can run the tests, which will start the server as well. NodeJS allows us to have a script act as both an executable script and a library module.</p>
<p>Time to give it a try and, after that, make it fail. We can try changing the test script to expect a different status code, content type or text within the file or ask for non existing files and see how Mocha reports that.  Change the server script, for example, comment out the <code>express.static</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/server/index.js#L29">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> middleware or change the folder it points to.</p>
<p>Someone might have noticed that while we have dealt with the asynchronicity of the <code>listen</code> method of the server, we have not dealt with that of reading the data file.  There are a few ways to deal with that but, in the end, it really doesn't matter as the use of that <code>data.json</code> file is just an interim way to just get going with the parts of the application we really care about at this point.  Since it works anyway and, in the long run, it will be replaced, we won't deal with this issue right now.  It is noticeable in that the first test is somewhat slow and Mocha reports the delay in yellow as a warning or red as unacceptable.</p>
<h2><a class="self-ref" id="chapter06-testing-the-data-server" href="#chapter06-testing-the-data-server"># </a>Testing the data server</h2>
<p>Testing the REST API has made our <code>server.js</code> test script grow five-fold, even though we haven't tested everything that could possibly be tested.  Later on, we will see how to find out what we have checked and what not.  Most of the test code is quite repetitive, it usually goes like this:</p>
<pre><code class="language-js">it('whatever the test ...', () =&gt;
  http.method(URL /* possible object with data: {descr: 'changed description'} */)
    .then((response) =&gt; {
      expect(response.status).to.equal(200);
      expect(response.headers['content-type']).to.contain('application/json');
      let data = response.data;
      // further tests on the data
    })
);
</code></pre>
<p>Most tests will call some <code>method</code> (<code>get</code>, <code>post</code>, <code>put</code> or <code>delete</code>) on the <code>http</code> object which is a pre-configured Axios instance such as the one we use for static pages:</p>
<pre><code class="language-js">const http = axios.create({
  baseURL: `http://localhost:${PORT}`
});
</code></pre>
<p>Or the one we use to access the REST API, which already points to <code>/data/v1</code></p>
<pre><code class="language-js">const http = axios.create({
  baseURL: `http://localhost:${PORT}/data/v1/projects`,
  responseType: 'json'
});
</code></pre>
<p>Depending on the <em>method</em> we may need to add further information, for example, both the POST and PUT methods need an object with the data to insert or modify, which Axios will take care to JSON-encode.</p>
<p>For all responses, we check whether the response status code is 200 and the content-type is JSON, except for DELETE operations which return no data.  This might not seem strictly necessary since it is to be expected that if one GET returns JSON, all GETs will.  However, testing doesn't happen that often and does not affect response times in production so, why not waste a little time now and spare us trouble later?  After all we are chaining plenty of <code>to</code>, <code>be</code> and other Chai <em>readability</em> methods to our <code>expect</code> assertions though they are completely useless, just to make our tests as clear as possible.</p>
<p>The first few tests <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L60-L114">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> check for the data already contained in the <code>data.json</code> file. Since later testing relies on us being able to read the data we have inserted or changed, it makes sense to ensure we get GETs right.</p>
<p>For later tests, we</p>
<ul>
<li>create a new project <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L158-L171">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
<li>manipulate it <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L181-L267">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
<li>and then delete it <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L173-L179">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</li>
</ul>
<p>Likewise, for tasks, we</p>
<ul>
<li>create a new one <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L223-L235">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
<li>manipulate it <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L245-L265">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
<li>and then delete it <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L237-L243">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</li>
</ul>
<p>For each kind of manipulation test, we repeat the creation and deletion so we have used the <code>beforeEach</code> to create the project or task to manipulate and the <code>afterEach</code> to delete it when done.</p>
<p>In all the tests we return the <code>Promise</code> that Axios creates for each operation so Mocha can check it.  Even the <code>beforeEach</code> and <code>afterEach</code> callbacks are checked for success.</p>
<p>When running the test script, the various tests are shown indented according to the context they are in, as marked by the <code>describe</code> enclosing it. It is interesting to see how Mocha makes it easy for us.  For example, when changing the completion status of a particular tasks within a project, Mocha would have gone through all these steps:</p>
<ul>
<li>Start the server <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L10-L12">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>
<ul>
<li>Create the pre-configured Axios connection <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L55-L58">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>
<ul>
<li>Create a new project <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L158-L171">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>
<ul>
<li>Create a new task within the newly created project <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L223-L235">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>
<ul>
<li>Change the completion status <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L256-L265">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
</ul>
</li>
<li>Delete the task <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L237-L243">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
</ul>
</li>
<li>Delete the project <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L173-L179">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
</ul>
</li>
</ul>
</li>
<li>Stop the server <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L14-L16">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
</ul>
<p>What are we missing? Plenty, for example:</p>
<ul>
<li>Add a second project and make sure it gets a different pid</li>
<li>Add another task to a project and make sure it gets its own tid</li>
<li>Do an actual GET on a changed project or task instead of relying on what the PUT method reports back</li>
<li>Delete a project or task to check it actually fails</li>
<li>Do a GET on a deleted project or tasks and check it fails</li>
<li>Change the information on a project with tasks in it and make sure we don't mess with those tasks</li>
</ul>
<p>Our tests have already paid off.  We were mishandling our tasks.  When creating a new project, we forgot to initialize the tasks list to an empty object. Later on, both when creating a new task or when deleting an existing one, we forgot that they go under the <code>tasks</code> member of the project object and not as part of the project itself. We got it right for changing it, but forgot on the other two operations. GitHub can show us the changes <a href="https://github.com/Satyam/book-react-redux/commit/caf19f304babb96242891b8fda57576c65cf2e13#diff-296f6c56d5ea1830255e4354f0b43f66">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> we did to <code>server/projects.js</code> to fix those errors, the green lines replacing the mistaken red lines.</p>
<p>That is what testing is for.</p>
<h2><a class="self-ref" id="chapter06-summary" href="#chapter06-summary"># </a>Summary</h2>
<p>We have learned how to use Mocha and Chai to automatically test our code and found an error while doing so.</p>
<p>We have modified our server code to enable it to be automatically started when run directly and to control when to start and stop it when run from other code, such as our test scripts.</p>
<p>We have modified our ESLint environment to accept Mocha's globals.</p>
<p>We have also started using Axios, the HTTP client library that we will eventually use in the actual client-side production code. After all, our test code is acting as a client would so it is better to use the same modules our client would.</p>
<h1><a class="self-ref" id="chapter07-code-coverage" href="#chapter07-code-coverage"># </a>Code coverage</h1>
<p>In the previous chapter, we made a brief list of some of the things we had not checked in our test script.  Those are the <em>known unknowns</em> which is bad enough, but then, as expected, there are the <em>unknown unknowns</em>.</p>
<p>As exhausting as writing all those tests might have been, they are not yet as exhaustive as they should be. That is because we have not covered all the alternatives.  There are two great subsets of errors, the application logic errors, most of which we have checked and others we haven't, such as those we listed towards the end of the last chapter.</p>
<p>Then, there are coding errors, most of which we have already checked, but several might lay hidden in code that rarely executes, which not even our tests have exercised.  In a compiled language, most of those are discovered at compilation time, but in an interpreted language, if one particular piece of code is never reached, it might never cause the application to fail.  A Linter certainly helps but, as compilers, they are only static checkers, they can't know what the value of the variables are going to be at the time of execution. So, the best alternative is to actually exercise each and every part of the code.</p>
<p>Plenty of times, we check conditions in our code to make sure we only proceed when things are fine.  We may or may not have an <em>else</em> for those conditions that are invalid.  We tend to think linearly, we rarely cover all the alternatives in our minds.  What happens when those <em>elses</em> run?   Quite often, we even forget to check them.  That is exactly what we've done here, most of those <em>elses</em>  returning <code>404</code> errors have not been checked.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/server/projects.js#L71-L75"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-02</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 71</div>
    <div class="to">To: 75</div>
  </div>
  <pre><code class="language-js">} else {
    res.status(404).send(`Task ${req.params.tid} not found`);
  }
} else {
  res.status(404).send(`Project ${req.params.pid} not found`);</code></pre></div>
<p>That is why we need a tool to check our code <em>coverage</em>. We need to make sure that our tests have gone through each end every line of code so that we are sure they all behave correctly.</p>
<p><a href="https://github.com/gotwarlost/istanbul#istanbul---a-js-code-coverage-tool-written-in-js">Istanbul</a> is such a tool. Coupled with Mocha, it makes sure there is not line of code that has not been checked at least once.</p>
<p>Istanbul produces an excellent report.  In order not to waste space in GitHub uploading coverage report for our code, we can have a look at <a href="http://gotwarlost.github.io/istanbul/public/coverage/lcov-report/index.html">Istanbul's own coverage report</a>.  The filenames on the left are links which expand to more and more detail.  Lets take a look at the ones that have the worst coverage, those will show the abundance of information Istanbul can provide.</p>
<p>Beyond the statistics, the uncovered parts of the code are shown highlighted in color <a href="http://gotwarlost.github.io/istanbul/public/coverage/lcov-report/istanbul/lib/reporter.js.html">for each file</a> individually.  When placing the cursor over each highlighted segment, Istanbul will show a brief description of the error.</p>
<p>The column to the right of the line numbers show the number of times each line has been executed.  This can also help us determine which lines are executed the most and thus can most affect our application performance.</p>
<p>Coverage is such a standard operation that the <code>.gitignore</code> file that GitHub automatically generated for us already lists  the standard folder for our coverage report.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/.gitignore#L13-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-02</div>
    <div class="filename">File: .gitignore</div>
    <div class="from">From: 13</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-"># Coverage directory used by tools like istanbul
coverage</code></pre></div>
<h2><a class="self-ref" id="chapter07-installing-istanbul" href="#chapter07-installing-istanbul"># </a>Installing Istanbul</h2>
<p>To set up Istanbul we first need to load it.  Just as ESLint, we may load it globally with <code>npm i -g istanbul</code> as recommended in its <a href="https://github.com/gotwarlost/istanbul#getting-started">home page</a> so we share the same copy for all our applications.  However, we can also load it locally.</p>
<pre><code class="language-sh">npm i --save-dev istanbul@1.0.0-alpha.2
</code></pre>
<p>The part after the package name <code>@1.0.0-alpha.2</code> tells NPM to load that particular version of the package.  The default (without the @ part) is to load the latest stale published version. The problem in this case is that the current stable version of Istanbul does not handle some features we will use later on in this book so we have to go for a pre-release version.  Perhaps by the time you read this book, the <code>1.0.0</code> is the stable release and specifying the version is no longer needed</p>
<p>Anyway, this helps to explain why we are installing it locally instead of globally.  If we were to install a single global version of Istanbul, which one should we install?  The stable or the experimental?  It would be risky to install an experimental version globally, but then, what do we do with this particular application?  That is why it is better to install the tools locally for each application. Each app gets the version it needs.</p>
<p>Besides, local installs get recorded into <code>package.json</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/package.json#L43">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which makes it easier to set up the development environment by simply doing <code>npm install</code> on a fresh download of the application.  Global installs don't get recorded so we have to tell each new developer about all the globals we expect, and those developers might not be happy about us forcing them to provide our preferences.</p>
<h2><a class="self-ref" id="chapter07-running-istanbul" href="#chapter07-running-istanbul"># </a>Running Istanbul</h2>
<p>To execute it, we need to add another command  to the <code>scripts</code> section of our <code>package.json</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/package.json#L6-L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-07-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "lint": "eslint . || exit 0",
  "test": "mocha",
  "coverage": "istanbul cover node_modules/.bin/_mocha"
},</code></pre></div>
<p>That is it.  Now, we can simply run it.</p>
<pre><code class="language-sh">npm run coverage
</code></pre>
<p>A <code>coverage</code> folder will be created in our project.  Look for <code>/coverage/lcov-report/index.html</code>. Doble-clicking on it will show the report for our application.  We haven't done that bad, the report shows mostly green indicating we have a reasonably good coverage.  Still, what is missing?</p>
<h2><a class="self-ref" id="chapter07-improving-coverage" href="#chapter07-improving-coverage"># </a>Improving coverage</h2>
<p>If we look at the coverage for <code>projects.js</code> we can see that we mostly missed the 404 error returns for non-existing projects or tasks.  We checked that for the GET method, but we haven't checked for wrong <code>pid</code>s or <code>tid</code>s for the other methods.</p>
<p>Once we get those covered, basically by copying and pasting the error-inducing code for the GET method <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L116-L153">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and changing the method on each copy <a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/test/server.js#L154-L243">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we go from this:</p>
<pre><code>=============================== Coverage summary ===============================
Statements   : 86.42% ( 70/81 )
Branches     : 61.76% ( 21/34 )
Functions    : 100% ( 0/0 )
Lines        : 86.25% ( 69/80 )
================================================================================
</code></pre>
<p>To this level of coverage:</p>
<pre><code>=============================== Coverage summary ===============================
Statements   : 95.06% ( 77/81 )
Branches     : 82.35% ( 28/34 )
Functions    : 100% ( 0/0 )
Lines        : 95% ( 76/80 )
================================================================================
</code></pre>
<p>Since our source code is relatively small, any extra line of code we get covered really makes a whole lot of difference.</p>
<p>Another remaining uncovered branch is the default for non-existing bodies, which is repeated in several places:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/server/projects.js#L57"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-02</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 57</div>
    <div class="to">To: 57</div>
  </div>
  <pre><code class="language-js">Object.assign(prj, req.body || {});</code></pre></div>
<p>If <code>req.body</code> is <code>null</code> or <code>undefined</code>, we provide an empty object.  We haven't done any tests for PUT and POST with no data.  So, we add those tests and, surprisingly, our coverage results don't improve.  The <code>|| {}</code> alternative is never used.  What is going on?  As it turns out, the <code>body-parser</code> middleware kindly provides an empty object when none is received, thus our default is completely unnecessary. It is not that we missed a test for that condition, it is a condition that can't ever happen. When we drop those:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/server/projects.js#L57"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-07-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 57</div>
    <div class="to">To: 57</div>
  </div>
  <pre><code class="language-js">Object.assign(prj, req.body);</code></pre></div>
<p>our coverage of the branches taken improve further as we got rid of a bunch of useless code.</p>
<pre><code>=============================== Coverage summary ===============================
Statements   : 95.06% ( 77/81 )
Branches     : 92.31% ( 24/26 )
Functions    : 100% ( 0/0 )
Lines        : 95% ( 76/80 )
================================================================================
</code></pre>
<h2><a class="self-ref" id="chapter07-linting" href="#chapter07-linting"># </a>Linting</h2>
<p>If we now run our linter, we will get thousands of errors, all of them from the folder used for the output of Istanbul. The <code>.gitignore</code> file that GitHub produced for us already knows about Istanbul and similar tools <a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/.gitignore#L14">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> so GIT won't bother uploading those files.  We need to do something similar for ESLint.  By providing a <code>.eslintignore</code> file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/.eslintignore">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> listing the file and folder patterns of files we don't want checked, we can tell ESLint to ignore those files.</p>
<h2><a class="self-ref" id="chapter07-summary" href="#chapter07-summary"># </a>Summary</h2>
<p>Hopefully, these few examples have shown how code coverage can help us improve the quality of our code.  Istanbul is very easy to set up once we have our tests in place and it provides us with plenty of information.  It allows us to be confident that we have every alternative covered as well as strip unnecessary code that will never be executed.</p>
<h1><a class="self-ref" id="chapter08-switching-to-sql" href="#chapter08-switching-to-sql"># </a>Switching to SQL</h1>
<p>Our server has been working from data stored in memory, a solution workable only for the smallest data set.  To go any further we should go to some more serious data management system. We have to switch to SQL.</p>
<p>Why not a NoSQL database? The information we have been using so far looks pretty much like the hierarchical information that is usually stored in NoSQL databases so it should be easy to store it in one such.</p>
<p>One reason to go the way of SQL is that it is, indeed, a challenge. We must support the agreed interface so we might as well prove that it can still be supported with any technology.  As long as it complies with the test suite we have written to validate our API, it really doesn't matter what is behind.</p>
<p>A second reason is that there is no NoSQL standard.  If we look at an SQL statement, we know what it means.  NoSQL databases are plagued with a wide variety of proprietary languages.  The purpose of this book is to look into React and Redux, not analyzing particular NoSQL dialects.</p>
<p>Finally, out of the many SQL variants, we will use <a href="https://www.sqlite.org">SQLite</a> for its simplicity. It still falls short of any large-scale database management system or DBMS like the popular and also free <a href="http://www.mysql.com/">MySQL</a>, <a href="http://www.postgresql.org/">PostgreSQL</a> or some larger commercial ones, but for the purpose of this book, it has the benefit of requiring no other installation than using NPM to load the corresponding package. SQLite manages its databases out of a simple file.  Opening a database simply means telling the SQLite driver which file to use. It is also so small that many applications use it to store its own data. For example, <a href="https://www.mozilla.org/en-US/thunderbird/">Mozilla Thunderbird</a>, a popular Open Source eMail client, creates several files with extension <code>.sqlite</code> that are SQLite databases just to hold configuration information.</p>
<p>Moreover, SQLite can use both temporary files or a memory store.  Both are valid through the duration of the application execution, which is all we need for the purpose of this book.</p>
<p>In our earlier version, we loaded the content of the <code>data.json</code> file in memory and handled all the data as a big global <code>data</code> object. Except for loading the <code>data.json</code> file into memory, all data operations where synchronous.  Now, using SQL, all our operations are asynchronous, which more closely resembles a real life scenario, and the purpose of this chapter is to explore that more thoroughly.</p>
<p>To load SQLite we follow the usual procedure. First, we use <code>npm i --save sqlite3</code> to download the package from the NPM registry.  Since we will use SQL in production, we use the <code>--save</code> option instead of <code>--save-dev</code> so it will be saved as a regular dependency in <code>package.json</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/package.json#L37">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Then, in our <code>server/index.js</code> file we add <code>const sqlite3 = require('sqlite3');</code> to load it as we have done with all the packages.  No news there.</p>
<p>So far, the only asynchronous operation we have seriously dealt with has been to put the HTTP server to listen.  We have ignored reading the <code>data.json</code> file, which is also an asynchronous operation, because we were going to drop it.  We are now dropping it but have added some more asynchronous operations.  Now, we do the following operations:</p>
<ul>
<li>Connect to the SQL database</li>
<li>Load the <code>data.sql</code> file containing the database setup</li>
<li>Make SQLite execute that file</li>
<li>Setup some SQL <em>Prepared Statements</em></li>
<li>Set the HTTP server to listen to requests</li>
</ul>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L22-L46"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 46</div>
  </div>
  <pre><code class="language-js">const webServer = {
  start: (done) =&gt; {
    global.db = new sqlite3.Database(':memory:', (err) =&gt; {
      if (err) return done(err);
      fs.readFile(path.join(__dirname, 'data.sql'), 'utf8', (err, data) =&gt; {
        if (err) return done(err);
        db.exec(data, (err) =&gt; {
          if (err) return done(err);
          projects(projectsRouter, (err) =&gt; {
            if (err) return done(err);
            server.listen(PORT, () =&gt; {
              console.log(`Server running at http://localhost:${PORT}/`);
              done();
            });
          });
        });
      });
    });
  },
  stop: (done) =&gt; {
    server.close(done);
  }
};

module.exports = webServer;</code></pre></div>
<p>To make all those operations available both to run the server regularly via <code>npm start</code> or to test it via <code>npm t</code> or <code>npm run coverage</code> we create a <code>webServer object</code> containing a <code>start</code> and a <code>stop</code> function.  We export that <code>webServer</code> object for the benefit of our test script.</p>
<p>In the <code>start</code> method, we create a <code>new sqlite3.Database</code> which will be kept in memory.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L24"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 24</div>
    <div class="to">To: 24</div>
  </div>
  <pre><code class="language-js">global.db = new sqlite3.Database(':memory:', (err) =&gt; {</code></pre></div>
<p>We could use an actual file or pass an empty string which will tell SQLite to create a temporary file, but we don't really have that much data. We make that <code>db</code> instance global by assigning it to <code>global.db</code>.</p>
<p>Then, we use the FileSystem <code>fs</code> module to read <code>data.sql</code> which contains standard SQL statements to create and populate the tables to store our data.  Once read, we tell the <code>db</code> to execute <code>db.exec</code> all those statements at once.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L26-L28"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 26</div>
    <div class="to">To: 28</div>
  </div>
  <pre><code class="language-js">fs.readFile(path.join(__dirname, 'data.sql'), 'utf8', (err, data) =&gt; {
  if (err) return done(err);
  db.exec(data, (err) =&gt; {</code></pre></div>
<p>We need to do some further setup in <code>server/projects.js</code> which is also asynchronous so we have added an extra argument to <code>projects</code>, we give it the router instance and now we also add a callback so it can tell us when it is done.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L30"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 30</div>
    <div class="to">To: 30</div>
  </div>
  <pre><code class="language-js">projects(projectsRouter, (err) =&gt; {</code></pre></div>
<p>Finally, we set our HTTP server to listen.</p>
<p>We do each operation sequentially. Each asynchronous operation takes a callback function whose first argument is an error object.  So, to proceed with each step we first check that the previous step has had no errors.  If <code>err</code> is not null, we call <code>done(err)</code> to notify our caller that there has been an error.  We have used a shortcut, we might have written this like this:</p>
<pre><code class="language-js">if (err) {
  done(err);
  return;
}
</code></pre>
<p>But we know that <code>done</code> does not return anything, thus, we are free to write:</p>
<pre><code class="language-js">if (err) return done(err);
</code></pre>
<p>Since <code>done</code> returns <code>undefined</code> and a solitary <code>return</code> is like <code>return undefined</code>, our shortcut works just the same.  We have not used this kind of shortcut elsewhere because we don't know what the callback might return.</p>
<p>For <code>close</code> we simply close the HTTP server.  Since the database is a temporary one in memory, it really doesn't matter if we close it or not.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L42"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 42</div>
    <div class="to">To: 42</div>
  </div>
  <pre><code class="language-js">server.close(done);</code></pre></div>
<p>To start the server in production mode using <code>npm start</code>, we have:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L48-L55"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 48</div>
    <div class="to">To: 55</div>
  </div>
  <pre><code class="language-js">if (require.main === module) {
  webServer.start((err) =&gt; {
    if (err) {
      console.error(err);
      process.exit(1);
    }
  });
}</code></pre></div>
<p>Once again, we check if this module is the main one and, if so, we call <code>webServer.start</code> to get everything up and running.  We provide a callback function which <code>start</code> would receive as the <code>done</code> argument that, if it does receive an error, it shows it in the console and exits with an error code.</p>
<p>We have made the function which is the default export of <code>server/projects.js</code> an asynchronous one by adding just one more argument to it, the <code>done</code> callback. We had to do this because all SQL operations are asynchronous so at initialization time, when we setup the <em>prepared statements</em> we can let our caller know when we are done or otherwise signal an error.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">module.exports = (router, done) =&gt; {</code></pre></div>
<p>A prepared statement is an optimization present in most varieties of SQL which allows the SQL engine to pre-compile and possibly optimize an SQL statement for future execution. For example, <code>selectAllProjects</code> contains the prepared statement <code>'select * from projects'</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L1-L7"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 7</div>
  </div>
  <pre><code class="language-js">module.exports = (router, done) =&gt; {
  const selectAllProjects = db.prepare('select * from projects', (err) =&gt; {
    if (err) return done(err);
  });
  const selectProjectByPid = db.prepare('select * from projects where pid = $pid', (err) =&gt; {
    if (err) return done(err);
  });</code></pre></div>
<p>Prepared statements can have variable parts which will be filled in when they are executed.  Variable parts can be represented in various ways, we have opted to use an identifier preceded by a <code>$</code> sign.  Thus when we want to execute <code>selectProjectByPid</code>, we have to provide an actual value for <code>$pid</code>.</p>
<p>Now, in response to a request for <code>/data/v1/projects</code>, we ask the <code>selectAllProjects</code> prepared statement to give us <code>all</code> the projects it can find.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L30-L38"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 30</div>
    <div class="to">To: 38</div>
  </div>
  <pre><code class="language-js">router.get('/', (req, res) =&gt; {
  selectAllProjects.all((err, prjs) =&gt; {
    if (err) {
      res.status(500).send(err);
    } else {
      res.json(prjs);
    }
  });
});</code></pre></div>
<p>We give '/' as the path since our <code>projectsRouter</code> already passes on only the requests to <code>/data/v1/projects</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 16</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">app.use('/data/v1/projects', projectsRouter);</code></pre></div>
<p>We call the <code>all</code> method on our <code>selectAllProjects</code> prepared statement, meaning, we want all the records it returns instead of one at a time. We provide it with a callback that will receive an error, if any, and an array containing all the projects if there is no error.  If we do get an error, we reply with a 500 HTTP error code along the text of the error or otherwise we send back those projects JSON-encoded.</p>
<p>We use a 500 error code here instead of the 404 we have used so far because the only reason for an error is a serious server-side error which fits the error standard description &quot;500: Internal Server Error&quot;.  There are plenty of standard <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">HTTP Status Codes</a> already defined that cover most needs. It is better to use the correct HTTP error code.</p>
<p>Creating a new project via a POST to <code>/data/v1/projects</code> uses parameters:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L82-L93"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 82</div>
    <div class="to">To: 93</div>
  </div>
  <pre><code class="language-js">router.post('/', (req, res) =&gt; {
  createProject.run({
    $name: req.body.name,
    $descr: req.body.descr
  }, function (err) {
    if (err) {
      res.status(500).send(err);
      return;
    }
    res.json({pid: this.lastID});
  });
});</code></pre></div>
<p>Here we run the <code>createProject</code> prepared statement filling in the <code>$name</code> and <code>$descr</code> variables with the corresponding information from the body of the request.  If there is an error, we report it back to the client with a 500 error code, otherwise, we get the <code>pid</code> of the newly inserted record which SQLite stores in <code>this.lastID</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L91"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 91</div>
    <div class="to">To: 91</div>
  </div>
  <pre><code class="language-js">res.json({pid: this.lastID});</code></pre></div>
<p>SQLite has two such variables <code>lastID</code> which represents the row ID of the last record inserted and <code>changes</code> which returns a count of the number of records affected in an insert, update or delete statement.  There is only one copy of each per connection so they must be read immediately after the SQL operation and before any new operation is attempted.  Different SQL engines have different names for these variables but they are always there in one way or another.</p>
<p>We are not using any shortcut to return when an error is found.  The following may work, but it is not safe:</p>
<pre><code class="language-js">if (err) return res.status(500).send(err);
</code></pre>
<p>If we did this, we would be returning a copy of <code>res</code> but we don't know what the Express router might do with that.  We might use:</p>
<pre><code class="language-js">if (err) return void res.status(500).send(err);
</code></pre>
<p>But it lacks clarity, which is important for maintainability, unless the practice is standardized across the organization. One-off hacks are never a good idea but if it becomes standard practice, it would be OK (and it would allow us to improve our coverage statistics).</p>
<h2><a class="self-ref" id="chapter08-building-sql-statements-dynamically" href="#chapter08-building-sql-statements-dynamically"># </a>Building SQL statements dynamically</h2>
<p>We can't use SQL prepared statements everywhere. In an update, what is it we are updating, all of the record or just part of it? In a project, we might independently update the project name or its description.  In a task we might change the description or its completion status. Just two fields per record  would require three prepared statements, one with both SQL field names and another two, each for a separate field.  This is not acceptable.  With more fields the situation would be even worst. So, we build it dynamically by concatenating as many fields as values arrive in the request body:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L119-L143"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 119</div>
    <div class="to">To: 143</div>
  </div>
  <pre><code class="language-js">router.put('/:pid', (req, res) =&gt; {
    const sql = 'update projects set ' +
      Object.keys(req.body).map((column) =&gt; `${column} = $${column}`).join(',') +
     ' where pid = $pid';

    db.run(sql, {
      $name: req.body.name,
      $descr: req.body.descr,
      $pid: req.params.pid
    }, function (err) {
      if (err) {
        if (err.errno === 25) {
          res.status(404).send(`project ${req.params.pid} not found`);
        } else {
          res.status(500).send(err);
        }
        return;
      }
      if (this.changes) {
        res.json({pid: req.params.pid});
      } else {
        res.status(404).send(`Project ${req.params.pid} not found`);
      }
    });
  });</code></pre></div>
<p>Since we have no prepared statement, we ask the <code>db</code> to <code>run</code> the <code>sql</code> statement we have just built by concatenating it in bits and pieces. We then provide the parameters to fill into the placeholders in the statement. If either of <code>name</code> or <code>descr</code> is <code>undefined</code> it will not show in the parameter list, but neither will it be in the statement so SQLite won't be expecting it.</p>
<h2><a class="self-ref" id="chapter08-regular-anonymous-functions-vs-fat-arrow-functions" href="#chapter08-regular-anonymous-functions-vs-fat-arrow-functions"># </a>Regular anonymous functions vs. fat arrow functions</h2>
<p>Our use of regular anonymous functions like in the code above and fat arrow functions elsewhere might seem capricious but it is not so. Fat arrow functions are the preferred choice because of their compact syntax and the way they handle <code>this</code>, which has always been an inconvenience in JavaScript.  Regular functions have their <code>this</code> either undefined or set to the global object. This was a problem for callbacks because they lost track of the <code>this</code> from the object instance they were contained in.  In contrast, fat arrow functions retain the <code>this</code> of their containing object.</p>
<p>Many developers have turned this <em>issue</em> into an advantage. Both Mocha and the SQLite driver set the context (the value of <code>this</code>) to a value of their choice which gives access to properties or methods useful to the callback.  Within an <code>it</code> test in Mocha, <code>this.timeout(nnn)</code> allows delays in tests.  In <code>sqlite3</code>, <code>this.lastID</code> and <code>this.changes</code> are accessible to the callback of the SQL operations.  If we were to use fat arrow functions, the <code>this</code> that those utilities give us would be lost.</p>
<h2><a class="self-ref" id="chapter08-testing-the-changes" href="#chapter08-testing-the-changes"># </a>Testing the changes</h2>
<p>We won't go through all of the changes in <code>projects.js</code>, it is basically SQL data handling.  Once all the changes are done, we have to check them and we have two ways of doing so. As always, we run ESLint via <code>npm run lint</code>.  Even if we have added linting to our editor, it is better to do a full check anyway because editors usually lint only the files they actually show.</p>
<p>Then, we need to run the tests via <code>npm t</code>.  These don't come good. Though 10 errors are reported, after analyzing them, it turns out they are only three different types.</p>
<ol>
<li>
<p>We changed the way we report the error messages.  Before, we had <code>Project nnn not found</code> and <code>Task nnn not found</code>, now we have more descriptive messages such as <code>Task nnn in project nnn not found</code> which is better for debugging. This is not a big deal of a change since the message is informative and useful only for debugging but it hardly matters to our client software which will simply check for the 404 error, not for the message.</p>
</li>
<li>
<p>When we are testing whether the server returns a proper error when we are updating a non-existing record, we expect a <code>404 Not Found</code> error, however, we are getting a <code>500 Internal Server Error</code>.  This is because in our tests, we didn't bother sending any actual data to update since we expected an error.  This no longer works with SQL because we are generating the SQL statement dynamically and, if there are no fields to update, the statement is invalid and won't compile. This was an error on our test suite which caused an error different from what we expected.  However the server did report an error so, it is hardly questionable.</p>
</li>
<li>
<p>When doing an update we used to reply with the updated record. This is easy when the data is in memory, but it requires one more SQL operation. Retaining the original behavior would be costly.  Is that cost worth preserving the compatibility? This is not an unusual decision to take at an earlier stage as we are now at.</p>
</li>
</ol>
<p>The first two errors are backward-compatible, a client would not complain about those.  The last one is not. However, it is hard to see an application that would complain about it, after all, the client already has the information, the server reply was just a confirmation, an expensive one at that.  So, we opt to accept the change in behavior.  We will not be providing the changed record on our updates, if we want it, you can always ask for it, which is what we do in our tests. Instead of just expecting the data to arrive with the reply to our update, we do an additional query to verify they were properly done  <a href="https://github.com/Satyam/book-react-redux/commit/f1fcd70b708e832e3e98872dd27728cef5eef8b5#diff-ad3c25167d0354b9b277e3ab6f375274L289">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>Many such changes in behavior are not so simple. The important lesson here is that to do this properly, we need to change the version number in <code>package.json</code>  from <code>&quot;version&quot;: &quot;0.1.0&quot;</code> to:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-02/package.json#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-json">"version": "0.2.0",</code></pre></div>
<p>Whenever we change the first non-zero number part in our version, it means there has been a compatibility change.  If our module were to be listed as a dependency in some other <code>package.json</code> like this:</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;how_to_do_a_todo_app&quot;: &quot;^0.1.0&quot;
}
</code></pre>
<p>NPM would load any version <code>0.1.0</code> or later, such as <code>0.1.1</code> or <code>0.1.999999</code> but it would never load <code>0.2.0</code> because when the first non-zero number changes, it means there is a compatibility issue.</p>
<p>Since we are still in the <code>0.x.x</code> version numbers, it means we are not yet in production so we are still free to do this kind of changes.  Later on, we would need to gently migrate our users to the new version. This would require us to handle two versions at once, the old one on the <code>/data/v1</code> route and the new one in <code>/data/v2</code>.</p>
<h2><a class="self-ref" id="chapter08-handling-url-query-parameters" href="#chapter08-handling-url-query-parameters"># </a>Handling URL Query Parameters</h2>
<p>Within a REST request, each part has a clear function. We have dealt with most of them, namely:</p>
<ul>
<li>
<p>The method (GET, POST, PUT, DELETE) tells the server what to do.</p>
</li>
<li>
<p>The path (<code>projects/34/5</code>) identifies the item we mean to operate upon.</p>
</li>
<li>
<p>The optional body of the request carries non-key data associated with that item, usually for insert or update operations.</p>
</li>
<li>
<p>The optional query parameters (the part following the query mark in the URL) indicate options.</p>
</li>
</ul>
<p>We may add query parameters to our REST API such as search conditions or which fields to return. Often, to handle those cases we need to build the SQL statement dynamically.  However, since the query parameters are usually an exception, we will still use the generic SQL prepared statement for the usual condition and a built one for the exceptional cases.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L30-L50"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-03</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 30</div>
    <div class="to">To: 50</div>
  </div>
  <pre><code class="language-js">router.get('/', (req, res) =&gt; {
  const cb = (err, prjs) =&gt; {
    if (err) {
      res.status(500).send(err);
    } else {
      res.json(prjs);
    }
  };
  if (Object.keys(req.query).length === 0) {
    selectAllProjects.all(cb);
  } else {
    const sql = 'select ' +
      (req.query.fields || '*') +
      ' from projects' +
       (req.query.search
         ? ' where ' + req.query.search.replace(/([^=]+)=(.+)/, '$1 like "%$2%"')
         : ''
       );
    db.all(sql, cb);
  }
});</code></pre></div>
<p>We changed the route handler for the GET on <code>/</code> to handle query parameters.  Since one way or another we are going to use the same callback for queries with or without parameters, we first define the callback function <code>cb</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L31-L37"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-03</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 31</div>
    <div class="to">To: 37</div>
  </div>
  <pre><code class="language-js">const cb = (err, prjs) =&gt; {
  if (err) {
    res.status(500).send(err);
  } else {
    res.json(prjs);
  }
};</code></pre></div>
<p>We check whether there are any query parameters.  Express already parses the query parameters and places them in an object at <code>req.query</code>. If there are none, it will give us an empty object.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L38"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-03</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 38</div>
    <div class="to">To: 38</div>
  </div>
  <pre><code class="language-js">if (Object.keys(req.query).length === 0) {</code></pre></div>
<p>If there are no keys in <code>req.query</code> we use the <code>selectAllProjects</code> prepared statement, otherwise, we build the SQL statement into <code>sql</code> and run it.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L41-L48"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-03</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 41</div>
    <div class="to">To: 48</div>
  </div>
  <pre><code class="language-js">const sql = 'select ' +
  (req.query.fields || '*') +
  ' from projects' +
   (req.query.search
     ? ' where ' + req.query.search.replace(/([^=]+)=(.+)/, '$1 like "%$2%"')
     : ''
   );
db.all(sql, cb);</code></pre></div>
<p>If there is a <code>fields</code> key, we expect it to be a comma separated list of fields to list, such as <code>name,descr</code> and we concatenate that list, otherwise, we ask for all fields <code>'*'</code>.</p>
<p>If there is a <code>search</code> key, we assemble an SQL <code>where</code> clause.  We expect the search to be of the form <code>field=value</code> which we translate, via a regular expression, into <code>field like &quot;%value%&quot;</code> which is an SQL  <em>wildcard</em> search for that value anywhere within the field. This is just an example of how a search could be translated, many others would be just as good.  The REST API we are dealing with is not meant for direct human consumption so its syntax could be far more complex and/or cryptic,  after all, there will be client-side software to translate it from the user request.</p>
<p>As expected, we then test our changes <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/test/server.js#L89-L143">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<h2><a class="self-ref" id="chapter08-sql-injection" href="#chapter08-sql-injection"># </a>SQL Injection</h2>
<p>The previous example shows us the danger of relying on information coming from a remote client to build an SQL statement. We may add the following test to our suite to see how it can be done:</p>
<pre><code class="language-js">it('SQL injection ', () =&gt; http.get('/?fields=* from sqlite_master;select *')
  .then((response) =&gt; {
    expect(response.status).to.equal(200);
    expect(response.headers['content-type']).to.contain('application/json');
    const data = response.data;
    expect(data).to.be.an.instanceof(Array);
    console.log(data);
  })
);
</code></pre>
<p>Our server code accepts two query parameters, <code>fields</code> and <code>search</code>.  The first is expected to contain a comma-separated list of field names such as <code>?fields=name,pid</code> but what if it doesn't? In the code above we cheated the server and injected an extra SQL statement for the server to execute.  When that request is executed, the server code <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L41-L47">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> will produce the following SQL statement:</p>
<pre><code class="language-sql">select * from sqlite_master;select * from projects
</code></pre>
<p>Many database engines can return the result of two queries at once or will return one or the other.  In this case, SQLite returns the first and ignores the second. The table <code>sqlite_master</code> is an internal table within SQLite that actually contains the information about all the other elements in the database.</p>
<pre><code class="language-js">[ { type: 'table',
    name: 'projects',
    tbl_name: 'projects',
    rootpage: 2,
    sql: 'CREATE TABLE projects (\n  pid INTEGER PRIMARY KEY,\n  name TEXT,\n  descr TEXT\n)' },
  { type: 'table',
    name: 'tasks',
    tbl_name: 'tasks',
    rootpage: 3,
    sql: 'CREATE TABLE tasks (\n  tid INTEGER PRIMARY KEY,\n  pid INTEGER,\n  descr TEXT,\n  completed TINYINT\n)' } ]
</code></pre>
<p>It lists the only two elements we have created, the two tables <code>projects</code> and <code>tasks</code> and the SQL statements used for the creation of each, listing the fields and constraints for each.</p>
<p>Once we know the tables available in the server, we could then issue a HTTP GET request to  <code>'/projects?fields=* from projects;select *'</code> or any other table we had and steal whatever information is within reach.</p>
<p>This process is called SQL Injection and it is one of the main exploits to steal data from servers. We should always check the data received.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/server/projects.js#L41-L48"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-04</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 41</div>
    <div class="to">To: 48</div>
  </div>
  <pre><code class="language-js">if (req.query.fields &amp;&amp; !/^\s*\w+\s*(,\s*\w+\s*)*$/.test(req.query.fields)) {
  res.status(400).send('Bad request');
  return;
}
if (req.query.search &amp;&amp; !/^\s*\w+\s*=\s*\w[\w\s]*$/.test(req.query.search)) {
  res.status(400).send('Bad request');
  return;
}</code></pre></div>
<p>Our test now shows that trying to inject anything unexpected fails.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/test/server.js#L145-L155"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-04</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 145</div>
    <div class="to">To: 155</div>
  </div>
  <pre><code class="language-js">it('SQL injection ', () =&gt;
  http.get('/?fields=* from sqlite_master;select *')
    .then(
      (response) =&gt; {
        throw new Error('Should not have let it go');
      },
      (response) =&gt; {
        expect(response.status).to.equal(400);
      }
    )
);</code></pre></div>
<p>We should never trust the information coming from a remote source.  It might not actually be a user on a browser.</p>
<h2><a class="self-ref" id="chapter08-summary" href="#chapter08-summary"># </a>Summary</h2>
<p>We have successfully migrated our server from using in-memory data to an external SQL database.</p>
<p>In doing so we have found that our original definition of our REST API had some expensive features. This required us to change the agreed interface causing a compatibility issue.  We indicated that by incrementing our version number of our code in <code>package.json</code>.</p>
<p>It was our tests that allowed us to discover this issue.  We should always write tests.</p>
<p>We have also shown how SQL injection can be done and how to prevent it by validating the requests.  And, of course, we tested for it.</p>
<h1><a class="self-ref" id="chapter09-separating-concerns" href="#chapter09-separating-concerns"># </a>Separating Concerns</h1>
<p>Our <code>projects.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/server/projects.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> file is a real mess.  It was useful so far because it allowed us to see in just one glimpse how a request could be handled but it mixed two separate concerns, those of handling the HTTP and the database connections.  As more complexity was added to the routes in some of the examples, they became really difficult to follow.</p>
<p>We fix this mess by separating the concerns.  To start with, it seems our server software will only deal with projects.  This is probably shortsighted, we would eventually have to tackle other concerns, such as user login, which will also require us to manage users.</p>
<p>Our server has already hard-coded a root route to deal with projects:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/server/index.js#L15-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">const projectsRouter = express.Router();
app.use('/data/v1/projects', projectsRouter);</code></pre></div>
<p>For starters, we will move the code dealing with projects into its own <code>projects</code> folder under <code>/server</code> <a href="https://github.com/Satyam/book-react-redux/tree/chapter-09-01/server">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  This will further give us flexibility to separate the code dealing with projects into various files without crowding the <code>/server</code> folder.</p>
<p>The <code>routes.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/routes.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> file deals with routing the HTTP requests to appropriate handlers and <code>transactions.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/transactions.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> deals with actually handling the data for those requests.</p>
<p>Several clues indicate the split is a good thing.</p>
<ul>
<li><code>routes.js</code>
<ul>
<li>no longer uses <code>db</code>, the global variable holding the database connection.</li>
<li>validates all incoming arguments and issues a <code>400 Bad request</code> HTTP Error.  The 4xx error codes are client-side errors and sending improper values is its concern.</li>
<li>converts incoming text values into proper internal data types (numbers and booleans)</li>
<li>sends <code>500 Internal Server Error</code> when an error comes from <code>transactions.js</code>.  The 5xx error codes are for server-side errors and whatever the specific error might be, from an HTTP standpoint, it is a 5xx error.</li>
</ul>
</li>
<li><code>transactions.js</code>
<ul>
<li>it assumes that the data from the request is present and validated</li>
<li>it is the only one accessing the database</li>
<li>knows nothing about HTTP error codes</li>
<li>knows nothing about where the data is located within the request</li>
</ul>
</li>
</ul>
<p>All the database functionality is contained within an object which is the only export of <code>transactions.js</code>.  Each property in that object is a function. An <code>init</code> function sets everything up, basically, pre-compiling the SQL prepared statements, followed by several functions handling each possible CRUD operation.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/transactions.js#L1-L32"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 32</div>
  </div>
  <pre><code class="language-js">const prepared = {};

module.exports = {
  init: (done) =&gt; {
    prepared.selectAllProjects = db.prepare('select * from projects', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.selectProjectByPid = db.prepare('select * from projects where pid = $pid', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.selectTasksByPid = db.prepare('select tid, descr, completed from tasks where pid = $pid', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.selectTaskByTid = db.prepare('select * from tasks where tid = $tid', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.createProject = db.prepare('insert into projects (name, descr) values ($name, $descr)', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.createTask = db.prepare('insert into tasks (pid, descr, completed) values ($pid, $descr, $completed)', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.deleteProject = db.prepare('delete from projects where pid = $pid', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.deleteTask = db.prepare('delete from tasks where pid = $pid and tid = $tid', (err) =&gt; {
      if (err) return done(err);
    });
    done();
  },

  getAllProjects: (keys, data, options, done) =&gt; {</code></pre></div>
<p>All the functions are asynchronous receiving a <code>done</code> callback function as their last or only argument.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/transactions.js#L49"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 49</div>
    <div class="to">To: 49</div>
  </div>
  <pre><code class="language-js">getProjectById: (keys, data, options, done) =&gt; {</code></pre></div>
<p>All data handling functions, such as the two shown above expect the following arguments:</p>
<ul>
<li><code>keys</code>: Object containing the key or index to locate the item to operate upon.  They are usually <code>pid</code> and/or <code>tid</code>.</li>
<li><code>data</code>: Object containing data associated to the request. They can be <code>name</code> and <code>descr</code> for projects, <code>descr</code> and <code>complete</code> for tasks.</li>
<li><code>options</code>: Object containing request options such as
<ul>
<li><code>fields</code>: list of fields to return</li>
<li><code>search</code>: name of field and value to look for in that field.</li>
</ul>
</li>
<li><code>done</code>: callback function.</li>
</ul>
<p>They all produce the same type of reply through the combination of the two arguments of the <code>done</code> callback function.</p>
<ul>
<li><code>done(null, data)</code>: success.  Requested data is returned.</li>
<li><code>done(err)</code>: error. The database handler produced some sort of error.  The second argument is irrelevant.</li>
<li><code>done(null, null)</code>: not found. The keys provided failed to locate any items.  This is usually an error and <code>routes.js</code> reports it as a <code>404 not found</code> HTTP error.  This is different from a request for a list of items that returns no items because that returns <code>done(null, [])</code> and it is not necessarily an error.</li>
</ul>
<p>Extracting the arguments for each data processing function and processing the replies is mostly handled by the <code>processPrj</code>  function:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/routes.js#L4-L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-js">const processPrj = (op, res, keys, data, options) =&gt; {
  transactions[op](keys, data, options, (err, data) =&gt; {
    if (err) return void res.status(500).send(err);
    if (data === null) return void res.status(404).send('Item(s) not found');
    res.json(data);
  });
};</code></pre></div>
<p>It receives the name of the method within <code>transactions.js</code> that should handle the operation, the <code>res</code> response object from Express and the <code>keys</code>, <code>data</code> and <code>options</code> object for each request, as described above. It calls the given method on the <code>transactions</code> objects which is the result of requiring <code>transactions.js</code></p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/routes.js#L2"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 2</div>
    <div class="to">To: 2</div>
  </div>
  <pre><code class="language-js">const transactions = require('./transactions.js');</code></pre></div>
<p>On receiving the callback call, it checks for errors and sends a 500 error if one is found.  If <code>err</code> is <code>null</code> it then checks whether <code>data</code> is <code>null</code> and if so it sends a 404 error and otherwise just sends the data.</p>
<p>A typical database operation turns out to be quite simple:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/transactions.js#L67-L74"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 67</div>
    <div class="to">To: 74</div>
  </div>
  <pre><code class="language-js">getTaskByTid: (keys, data, options, done) =&gt; {
  prepared.selectTaskByTid.get({$tid: keys.tid}, (err, task) =&gt; {
    if (err) return done(err);
    if (!task || task.pid !== keys.pid) return done(null, null);
    task.completed = !!task.completed;
    done(null, task);
  });
},</code></pre></div>
<p>All operations receive the very same 4 arguments though depending on the operation, some will be empty.  Here, <code>getTaskByTid</code> calls the SQL prepared statement <code>selectTaskByTid</code> providing it with the object that will fill its placeholders, in this case only one <code>$tid</code> for the task Id.  On callback, it checks for errors and return immediately if any is found, it then checks whether a task item was actually returned and if so whether the <code>pid</code> on it matches the <code>pid</code> requested and in either case, it returns both null indicating that no record matched the requested keys.  Finally, it does a data type conversion on the <code>completed</code> field because SQLite does not have an actual  Boolean type but represents it as numbers 0 or not zero.  Just as the <code>routes.js</code> module dealt with type conversion on the data received in the HTTP request, it is the responsibility of the module dealing with the database to do the data type conversion of the values received from it to native JavaScript data types. Finally, it calls <code>done</code> with the data retrieved.</p>
<p>It is always a good rule that the first module receiving the information from an external source (http client, database handler, etc.) is responsible for validating and converting the values to native data types.</p>
<p>We will off-load dealing with specific data routes from our core web server code.  Instead of setting up a sub-router for the whole <code>/data/v1/projects</code> route <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/server/index.js#L15-L18">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we will only deal with <code>/data/v1</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/index.js#L15-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">const dataRouter = express.Router();
app.use('/data/v1', dataRouter);</code></pre></div>
<p>However, it is not a good idea to let every data server plug itself into whichever route it pleases.  It is best to have some centralized place responsible to tell each module which branch off the main <code>/data/v1</code> route it should respond to.  Thus, we tell the module  where it should go when initializing itself:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/index.js#L28-L29"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 28</div>
    <div class="to">To: 29</div>
  </div>
  <pre><code class="language-js">const projectsRoutes = require('./projects/routes.js');
projectsRoutes(dataRouter, '/projects', (err) =&gt; {</code></pre></div>
<p>The projects router will receive the <code>dataRouter</code> and the <code>branch</code> it should respond to.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/routes.js#L17-L21"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 17</div>
    <div class="to">To: 21</div>
  </div>
  <pre><code class="language-js">module.exports = (dataRouter, branch, done) =&gt; {
  const projectsRouter = express.Router();
  dataRouter.use(branch, projectsRouter);

  projectsRouter.get('/', (req, res) =&gt; {</code></pre></div>
<p>Each module might choose to generate a new sub-router, as we did here by creating a new <code>projectsRouter</code>, or it might use the <code>dataRouter</code> and concatenate the <code>branch</code> into each of the paths:</p>
<pre><code class="language-js">// With sub-router
projectsRouter.get('/:pid', (req, res) =&gt; {

// Concatenating the branch into the path
dataRouter.get(`${branch}/:pid`, (req, res) =&gt; {
</code></pre>
<p>Within each router, Express checks the routes sequentially in the order they were defined.  By creating sub-routes we turn this sequential list into a tree, which is faster to traverse.  It also allows us to plug any group of routes anywhere else in the tree with little effort should we ever need it.  Besides, we write less.</p>
<p>It might well be noted that in our database handlers, the arguments <code>keys</code>, <code>data</code> and <code>options</code> copy values from <code>req.params</code>, <code>req.body</code> and <code>req.query</code> respectively.  It might seem that we are coupling our data-handling functions with the REST API, just changing the name of things. This is not so.</p>
<p>As we mentioned <a href="#chapter08-handling-url-query-parameters">earlier</a>, each part of the URL has a specific purpose. The path, such as <code>/data/v1/projects/25</code> is meant to identify a resource, the <code>25</code> in this case being the <code>pid</code>, thus, it matches the concept of a <code>key</code> in an indexed database or any other data-retrieval mechanism.  The data associated with that resource should go elsewhere, <code>req.body</code> in the request or the <code>data</code> argument in each data handling function.  Finally, it is equally fitting that the <code>options</code> come in the form of query parameters in <code>req.query</code>.</p>
<p>Thus, it is far from coincidence.  However, this is in no way enforced by Express or any of the other library modules we have been using. It is just our own convention.</p>
<h2><a class="self-ref" id="chapter09-simplifying-validation-with-middleware" href="#chapter09-simplifying-validation-with-middleware"># </a>Simplifying validation with middleware</h2>
<p>We have already seen how flexible Express can be in the way we can match routes.  We have transformed a large sequential list of routes to a tree quite easily. Routes also allows us to use variable parts in routes and extract them as parameters.</p>
<p>Express is also flexible in the way we handle that route once it has been matched.  So far, we have used the pattern:</p>
<pre><code class="language-js">router.method('route pattern', (req, res) =&gt; {
  // ...
});
</code></pre>
<p>However, Express allows any number of handlers to be chained after each route pattern.</p>
<pre><code class="language-js">router.method('route pattern', handler1, handler2, /* .... */ (req, res) =&gt; {
  // ...
});
</code></pre>
<p>This can be very useful in validating the data received.  It is obvious from our <code>routes.js</code> file how we keep repeating the very same validation code over and over again.  We can simplify this by using chained handlers which is basically what middleware does.</p>
<p>All route handlers have three arguments, <code>req</code> and <code>res</code> which we have been using so far and <code>next</code> which we haven't even mentioned yet.</p>
<p>The third, <code>next</code>, argument is a function that, when called, tells Express to call the next handler in the chain and, if there are no further handlers for that route, to go back to route matching.</p>
<p>Handlers can add information to both <code>req</code> and <code>res</code> and each successive handler in the chain will see the changes the previous one has made on those objects.  That is what, for example, <code>body-parser</code> does.  It reads and parses the information received in the request body and places it in <code>req.body</code>. Then, it calls <code>next()</code> so Express continues matching routes.</p>
<p>We have moved our validators to a separate <code>validators.js</code> file. This is our <code>pid</code> validator:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/validators.js#L12-L19"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/validators.js</div>
    <div class="from">From: 12</div>
    <div class="to">To: 19</div>
  </div>
  <pre><code class="language-js">validatePid: (req, res, next) =&gt; {
  const pid = Number(req.params.pid);
  if (Number.isNaN(pid)) return send400(res);
  req.$valid.keys = {
    pid
  };
  next();
},</code></pre></div>
<p>It converts the <code>:pid</code> parameter from string to number.  If it is <code>NaN</code> it means the conversion failed and sends back a 400 HTTP error. Otherwise, we store the converted <code>pid</code> into <code>req</code> in an object of our own called <code>$valid</code> under <code>keys</code>.  Finally, it calls <code>next</code> to chain into the next validator or the final handler.</p>
<p>The <code>send400</code> function sends our default response to invalid request data:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/validators.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/validators.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">const send400 = (res) =&gt; void res.status(400).send('Bad request');</code></pre></div>
<p>When we return from sending the 400 response, we are not calling <code>next</code> because there is no point in continuing further down the chain, a response has already been sent. We only call <code>next</code> on a successful validation.</p>
<p>The choice of using a <code>req.$valid</code> object to store validated values is completely arbitrary.  It simply needs to be some property that doesn't collide with any existing property names.  Express does not use the <code>$</code> for its properties.  Traditionally, though variable names can start with an underscore <code>_</code> or a dollar sign <code>$</code>, they are somewhat reserved.  Identifiers starting with underscore are meant to signal a <em>private</em> member.  It doesn't meant they are really private in the sense of other languages that make them invisible to other modules, it just signals the intent to keep them private.  In other words, it signals that developers should not count on it.  A developer is expected to support the <em>public</em> interface of their modules.  If any public interface is broken, then you have a <em>backward compatibility</em> issue.  Developers are not expected to support their <em>private</em> interfaces and they signal those by using the underscore prefix.  If you use any private interface from a third party module, you do it at your own risk.</p>
<p>The dollar sign usually signaled temporary or auxiliary variables whose existence is ephemeral. Then came JQuery, but that is another story. So, using <code>$valid</code> under <code>req</code> should be quite safe.</p>
<p>Our validators all assume there is a <code>req.$valid</code> object.  To ensure that, we use another chained handler:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/validators.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/validators.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">const send400 = (res) =&gt; void res.status(400).send('Bad request');</code></pre></div>
<p>We have to put this chained handler before any validators and we already have the perfect place to do so.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/routes.js#L14-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">module.exports = (dataRouter, branch, done) =&gt; {
  const projectsRouter = express.Router();
  dataRouter.use(branch, validators.add$valid, projectsRouter);</code></pre></div>
<p>Our <code>projectsRouter</code> sub-route handler is just another piece of middleware and any number of such handlers can be chained even when defining a new sub-route.  So, we add our <code>add$valid</code> middleware right in front of the sub-route handler to ensure <code>req.$valid</code> will already be available for any handler below.</p>
<p>This makes all our routes quite simple, even boringly so:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/routes.js#L50-L54"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 50</div>
    <div class="to">To: 54</div>
  </div>
  <pre><code class="language-js">projectsRouter.put('/:pid/:tid',
  validators.validateTid,
  validators.validateTaskData,
  (req, res) =&gt; processPrj('updateTask', req, res)
);</code></pre></div>
<p>To PUT (change) a task, we need to validate both the <code>tid</code> (which includes validating the <code>pid</code>) and the data to change.  If each of these validators succeeds, each will call <code>next</code> until the chain falls into our own handler which calls <code>processPrj</code> with the name of the method to execute.  Note that the last handler in the chain does not call <code>next</code> because it will take care of the request itself and no further handlers need to be concerned with it.  If it did call <code>next</code>, Express would continue the route matching process and with no further handlers matching this particular route, it would go all the way until the end and then send a <code>404 not found</code> reply, which is not good, mostly because of the time wasted since the valid reply would have already been sent long before.</p>
<p>The <code>processPrj</code> function has not changed that much from the previous version.  Instead of expecting the <code>keys</code>, <code>data</code> and <code>options</code> arguments, it expects to find those same arguments within <code>req.$valid</code> so it uses those.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/routes.js#L5-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">const processPrj = (op, req, res) =&gt; {
  const valid = req.$valid;
  transactions[op](valid.keys, valid.data, valid.options, (err, data) =&gt; {
    if (err) return void res.status(500).send(err);
    if (data === null) return void res.status(404).send('Item(s) not found');
    res.json(data);
  });
};</code></pre></div>
<p>Can we go a little further?  <code>processPrj</code> receives <code>req</code> and <code>res</code> like all handlers. Can we make it a piece of middleware?
Sure!</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-03/server/projects/routes.js#L5-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-03</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">const processPrj = (op) =&gt; (req, res) =&gt; {
  const valid = req.$valid;
  transactions[op](valid.keys, valid.data, valid.options, (err, data) =&gt; {
    if (err) return void res.status(500).send(err);
    if (data === null) return void res.status(404).send('Item(s) not found');
    res.json(data);
  });
};</code></pre></div>
<p>Lets take a look at both versions side by side.  The difference is just in the very first line:</p>
<pre><code class="language-js">// Previous:
const processPrj = (op, req, res) =&gt; {

// Now:
const processPrj = (op) =&gt; (req, res) =&gt; {
</code></pre>
<p>We turned <code>processPrj</code> from a function that receives three arguments into a function that receives the single <code>op</code> argument and returns a function that is the actual handler that will eventually receive the <code>req</code> and <code>res</code> arguments and respond with the requested data, which is what a route handler does.  In other words, <code>processPrj</code> is now a function that returns route handlers already bound to a particular <code>op</code>. The inner function will have access to <code>op</code> in the outer function via closure.  This is called <em>currying</em>.</p>
<p>A route in our list of route handlers ends up quite succinct:</p>
<pre><code class="language-js">projectsRouter.put('/:pid',
  validators.validatePid,
  validators.validatePrjData,
  processPrj('updateProject')
);
</code></pre>
<p>It is just a number of chained middleware and handlers each doing its part in the processing of the request.</p>
<h2><a class="self-ref" id="chapter09-summary" href="#chapter09-summary"># </a>Summary</h2>
<p>Now we have much less code repetition than we had before, all our validation is concentrated each in one simple validator. Should we later change the <code>pid</code>s or <code>tid</code>s to something else instead of plain integers, for example, UUIDs such as <code>{3F2504E0-4F89-41D3-9A0C-0305E82C3301}</code> we can change it in a few places.</p>
<p>Our code coverage also increases.  Since there is less repetition, there are fewer repeated lines and branches that need to be separately tested with extra tests.  Now, with the same number of tests, we go through most of the code.</p>
<p>Another interesting effect in our code coverage is that the column showing the number of times a certain line of code has been used increases since those fewer lines are used more times each.</p>
<p>We haven't added any tests since doing SQL Injection but we certainly should, though they wouldn't add much for the purpose of this book. Please feel free to try on your own. Our validators should be thoroughly checked forcing errors and making sure they detect them. One advantage of putting our validators into a separate file is that they can be tested on their own, without having to go through Express' routing or doing actual SQL transactions.  As a general rule, there should be one set of tests for each file, as a matter of fact, the <code>/test</code> folder should reproduce the file structure of the rest of application, having one test file per application file.</p>
<p>To top this off, we will do further chaining of the JavaScript kind.  The <code>get</code>, <code>post</code>, <code>put</code> and <code>delete</code> methods are also chainable so all our routes definitions can be reduced to the following:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-03/server/projects/routes.js#L18-L58"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-03</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 58</div>
  </div>
  <pre><code class="language-js">projectsRouter
  .get('/',
    validators.validateOptions,
    processPrj('getAllProjects')
  )
  .get('/:pid',
    validators.validatePid,
    processPrj('getProjectById')
  )
  .get('/:pid/:tid',
    validators.validateTid,
    processPrj('getTaskByTid')
  )
  .post('/',
    validators.validatePrjData,
    processPrj('addProject')
  )
  .post('/:pid',
    validators.validatePid,
    validators.validateTaskData,
    processPrj('addTaskToProject')
  )
  .put('/:pid',
    validators.validatePid,
    validators.validatePrjData,
    processPrj('updateProject')
  )
  .put('/:pid/:tid',
    validators.validateTid,
    validators.validateTaskData,
    processPrj('updateTask')
  )
  .delete('/:pid',
    validators.validatePid,
    processPrj('deleteProject')
  )
  .delete('/:pid/:tid',
    validators.validateTid,
    processPrj('deleteTask')
  )
;</code></pre></div>
<h1><a class="self-ref" id="chapter10-client-side" href="#chapter10-client-side"># </a>Client side</h1>
<h2><a class="self-ref" id="chapter10-the-way-not-to-do-it" href="#chapter10-the-way-not-to-do-it"># </a>The way not to do it</h2>
<p>Perhaps the best way to learn why we do things in a certain way is to see what would happen if we did it otherwise.  This is our new <code>index.html</code> file that shows the list of projects in the database.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-01/public/index.html"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-01</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="/node_modules/axios/dist/axios.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      axios.get('/data/v1/projects')
        .then(response =&gt; {
          document.getElementById('contents').innerHTML =
          `&lt;h1&gt;Projects:&lt;/h1&gt;&lt;ul&gt;${
            response.data.map(item =&gt;
              `&lt;li&gt;&lt;a href="project.html?${item.pid}"&gt;${item.name}&lt;/a&gt;&lt;/li&gt;`
            ).join('\n')
          }&lt;/ul&gt;`;
          document.title = "Projects";
        });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>In the body we create a <code>&lt;div id=&quot;contents&quot;&gt;</code> to put our page content in.  We then load Axios, our HTTP request library, from <code>node_modules</code>. We added a new route for static content to our Express server to let it access <code>node_modules</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-01/server/index.js#L18-L19"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 19</div>
  </div>
  <pre><code class="language-js">app.use('/node_modules', express.static(path.join(__dirname, '../node_modules')));
app.use(express.static(path.join(__dirname, '../public')));</code></pre></div>
<p>While the regular <code>use</code> of the <code>express.static</code> middleware is a catch-all for any path not already taken care for, in this new route we specifically tell it to deal with routes pointing to <code>node_modules</code>.  As such, we place it before the catch-all.  Though in this case it wouldn't have made a difference, it is always better to place the more specific routes before the more generic ones.</p>
<p>Since the browser doesn't know about <code>package.json</code> and NodeJS's module search mechanism, we have to be very specific regarding the exact location of the file we are loading as the browser won't look for it.  As a matter of fact, our server-side NodeJS script would load the version in <code>axios/lib</code> while we load the one in <code>axios/dist</code>. They are slightly different and we will see why later.</p>
<p>The code in this page simply sends an HTTP GET request to <code>'/data/v1/projects'</code> using Axios, just as we have already done in our Mocha tests in earlier chapters. On receiving the response, we locate the <code>&lt;div&gt;</code> by its ID and set its <code>innerHTML</code> to the string we compose using ES2015 template strings. With the ability to interpolate any sort of expressions into the template placeholders and the ability to extend to multiple lines, this looks pretty much like using PHP jumping in and out of HTML to PHP mode or, in this case, from template string to JS expression.</p>
<p>We have done pretty much the same with project.html with a different template and a different data request.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-01/public/project.html#L1-L27"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-01</div>
    <div class="filename">File: public/project.html</div>
    <div class="from">From: 1</div>
    <div class="to">To: 27</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="/node_modules/axios/dist/axios.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      axios.get(`/data/v1/projects/${window.location.search.substr(1)}`)
        .then(response =&gt; {
          const prj = response.data;
          document.getElementById('contents').innerHTML =
            `&lt;h1&gt;${prj.name}&lt;/h1&gt;&lt;p&gt;${prj.descr}&lt;/p&gt;&lt;ul&gt;${
              Object.keys(prj.tasks).map((tid) =&gt; {
                const task = prj.tasks[tid];
                return `&lt;li&gt;&lt;input type="checkbox" ${
                  task.completed ? 'checked' : ''
                } /&gt; &amp;nbsp; ${task.descr}&lt;/li&gt;`
              }).join('\n')
            }&lt;/ul&gt;`;
          document.title = `Project ${prj.pid}: ${prj.name}`;
        });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>For <code>project.html</code> we build the URL dynamically:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-01/public/project.html#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-01</div>
    <div class="filename">File: public/project.html</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-js">axios.get(`/data/v1/projects/${window.location.search.substr(1)}`)</code></pre></div>
<p>To try out these pages, we start the server as usual with <code>npm start</code> and then navigate to <code>http://localhost:8080</code> to get the project list and, by clicking on any of the projects, to each of the tasks list.</p>
<p>Depending on which browser we have and which version it is, this app may or may not work. ECMAScript 2015 is just starting to show up in some browsers and neither template strings or fat arrow functions might work. These are changes to the language itself and a pre-ES2015 browser will not even understand the script. It certainly will not work for most of our potential users.</p>
<h2><a class="self-ref" id="chapter10-polyfills" href="#chapter10-polyfills"># </a>Polyfills</h2>
<p>Older browsers will also lack Promises which Axios uses extensively. This is a different kind of error because this can be patched, it is a missing global object which can be added. It can also be a property within an existing object, such as <code>Object.keys</code> which can also be added. These are called <em>polyfills</em> and, if we check, for example, Mozilla's documentation, we <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys#Polyfill">will see</a> such polyfills listed for each method recently added.</p>
<p>Thus, we can change our code to make it available to more browsers.  It doesn't take long, we just need to add a couple of external scripts and change something.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-02/public/index.html#L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-02</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: 10</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-html">&lt;script src="//cdn.polyfill.io/v1/polyfill.min.js?features=Promise" defer async&gt;&lt;/script&gt;</code></pre></div>
<p>We simply added two extra external scripts.  The first one, from <code>polyfill.io</code> is from <a href="http://cdn.polyfill.io/v1/docs/">FT Labs</a>, the web development team at the Financial Times newspaper. It reads the <code>user-agent</code> header from the HTTP request which identifies which browser is making the request, for example, in the one I'm using right now, it shows:</p>
<pre><code>User-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36
</code></pre>
<p>In this case, this strings identifies the browser as Google Chrome major version 48.  It then goes to its own <a href="http://cdn.polyfill.io/v1/docs/features/">features table</a> and decides it doesn't need almost anything and returns less than 1k of polyfills.  On the other hand, if I go to my old laptop with IE9 the polyfills add up to almost 5k. In this case, the base URL has <code>?features=Promise</code> added because developers might not be using Promises at all or might have already been using their own polyfill for that so FT Labs polyfill service doesn't include it by default and you have to request it explicitly. Once again, in modern browsers it wouldn't bother to load it at all since it is already there, but would load it for older browsers.</p>
<h2><a class="self-ref" id="chapter10-transpiling" href="#chapter10-transpiling"># </a>Transpiling</h2>
<p>As for the language issue, it is somewhat more complex because it is a change to the language itself, not just to a part of its built-in library.  To deal with that, we need a <em>transpiler</em>, a sort of compiler that instead of generating native machine code, it simply translates source code from one version of a language to a different version of the very same language.</p>
<p>Here we are using <a href="http://babeljs.io/">Babel</a> which has become the standard.  We are loading the browser version of Babel to let it transpile on the client-side.  To let Babel know what it is expected to transpile, we have changed the <code>&lt;script&gt;</code> tag enclosing our code to signal it as of <code>type=&quot;text/babel&quot;</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-02/public/index.html#L11-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-02</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: 11</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-html">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"&gt;&lt;/script&gt;
&lt;script type="text/babel"&gt;</code></pre></div>
<p>By default the type of <code>&lt;script&gt;</code> tags is <code>text/javascript</code> which will make the browser execute the code within.  However, if the <code>type</code> given is any other, the browser will ignore it.  That gives Babel a chance to do something about that code before the browser attempts to understand it.  Babel searches for all <code>&lt;script type=&quot;text/babel&quot;&gt;</code>, transpiles them and executes the resulting code.</p>
<p>This is what Babel ends up with for the code in in IE9 (Babel skips transpiling features that the browser supports natively so in my latest Chrome, Babel does nothing):</p>
<pre><code class="language-js">function anonymous() {
  'use strict';

  axios.get('/data/v1/projects/' + window.location.search.substr(1)).then(function (response) {
    var prj = response.data;
    document.getElementById('contents').innerHTML = '&lt;h1&gt;' + prj.name + '&lt;/h1&gt;&lt;p&gt;' + prj.descr + '&lt;/p&gt;&lt;ul&gt;' + Object.keys(prj.tasks).map(function (tid) {
      var task = prj.tasks[tid];
      return '&lt;li&gt;&lt;input type=&quot;checkbox&quot; ' + (task.completed ? 'checked' : '') + ' /&gt; &amp;nbsp; ' + task.descr + '&lt;/li&gt;';
    }).join('\n') + '&lt;/ul&gt;';
    document.title = 'Project ' + prj.pid + ': ' + prj.name;
  });
}
</code></pre>
<p>All the fat arrow functions have been changed to regular functions, the <code>const</code>s turned into <code>var</code>s and the template string replaced by a simple concatenation of small segments of string. If <code>this</code> had been used at any point within the fat arrow function, Babel would have provided a copy of the context of the enclosing function for the inner function to use. It is smart enough to know when it is not needed at all so in more modern browsers, it doesn't change the code at all.</p>
<p>When running this version of our client-code, there is a noticeable delay until the page shows up.  This is not just because all of the Babel transpiler had to load but it also has to run and transpile the code.  With a modern browser, it would probably figure out it doesn't really need to do anything at all, but it first has to check it all out.</p>
<p>So, even if not used, Babel is a hefty load. It doesn't make sense to force such a big download and heavy processing to the client.  To any and all clients, some powerful, some not so much, some with good and fast connections, some on a tablet on a 3G cell-phone network.</p>
<p>That is why the above mechanism has been deprecated by the developers of Babel. We are loading the 5.x version of Babel because there is no 6.x version of this particular browser-side transpiler.  I doubt that it has ever been used on a production environment at all. Instead, we will transpile off-line as part of the development process.</p>
<p>To do that, we will install the command-line version of Babel:</p>
<pre><code>npm install --save-dev babel-cli babel-preset-es2015
</code></pre>
<p>This installs Babel and the presets to transpile EcmaScript 2015 and also saves the dependencies to <code>package.json</code>. As shown above, NPM can install more than one package in one go.</p>
<p>We will also add an extra script to <code>package.json</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/package.json#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-03</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"build": "babel client --presets es2015 --out-dir public/lib"</code></pre></div>
<p>This will allow us to transpile every script found in the <code>client</code> folder into old-style JavaScript, using the <code>es2015</code> presets into the <code>lib</code> folder under the <code>public</code> folder which we already reserved for files meant for the browser.</p>
<p>Thus, we need to separate the in-line scripts from the html files and place them in the <code>client</code> folder.  For example, <code>client/project.js</code> looks like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/client/project.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-03</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">axios.get(`/data/v1/projects/${window.location.search.substr(1)}`)
  .then((response) =&gt; {
    const prj = response.data;
    document.getElementById('contents').innerHTML =
      `&lt;h1&gt;${prj.name}&lt;/h1&gt;&lt;p&gt;${prj.descr}&lt;/p&gt;&lt;ul&gt;${
        Object.keys(prj.tasks).map((tid) =&gt; {
          const task = prj.tasks[tid];
          return `&lt;li&gt;&lt;input type="checkbox" ${
            task.completed ? 'checked' : ''
          } /&gt; &amp;nbsp; ${task.descr}&lt;/li&gt;`;
        }).join('\n')
      }&lt;/ul&gt;`;
    document.title = `Project ${prj.pid}: ${prj.name}`;
  });</code></pre></div>
<p>The code is the same as it was within the script tag in <code>projects.html</code>.</p>
<p>Now, if we do:</p>
<pre><code>npm run build
</code></pre>
<p>Babel will create two files in <code>/public/lib</code> for each of the original JS files.  They look just like the one shown before produced by the in-browser transpiler</p>
<p>We now have to include it into the HTML page and drop the Babel in-line compiler:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/public/project.html"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-03</div>
    <div class="filename">File: public/project.html</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="/node_modules/axios/dist/axios.js"&gt;&lt;/script&gt;
    &lt;script src="//cdn.polyfill.io/v1/polyfill.min.js?features=Promise" defer async&gt;&lt;/script&gt;
    &lt;script src="lib/project.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>Finally, since the files in <code>/public/lib</code> are generated as the product of those in <code>/client</code>, we add them to <code>.gitignore</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/.gitignore#L29">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> so they don't get uploaded into the GitHub repository. We also add that folder to <code>.eslintignore</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/.eslintignore#L3">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> so they won't be linted, because they will fail.  We have also added a <code>/client/.eslintrc.json</code> to tell ESLint that the contents of that folder are meant to be run in a browser so it should expect to find well-known globals such as <code>window</code> or <code>document</code> and also tell it to expect <code>axios</code> as a global variable.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/client/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-03</div>
    <div class="filename">File: client/.eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "env": {
    "browser": true
  },
  "globals": {
    "axios": false
  }
}</code></pre></div>
<p>When starting the server via <code>npm start</code> and then pointing the browser to <code>http://localhost:8080</code>, the pages will show up immediately.  Instead of wasting time having the browser load Babel and then letting it transpile the code for us, we did that off-line via <code>npm run build</code> so the transpiled version is immediately available.  All browsers, even modern ones supporting ES2015, will get the old-style JavaScript code which doesn't use the new features.</p>
<h1><a class="self-ref" id="chapter11-modules-imports-and-exports" href="#chapter11-modules-imports-and-exports"># </a>Modules, Imports and Exports</h1>
<p>Only recently, with ECMAScript-2015 has JavaScript has built-in support for modules, at least in its syntax since no platform actually knows what to do with it.  Babel helpfully transpiles <code>import x from 'myModule'</code> into <code>const x = require('myModule')</code> which NodeJS understands but no browser would.</p>
<p>The only mechanism to load external modules into a browser is via the <code>&lt;script&gt;</code> tag which is far from perfect.  The biggest issue is that whatever gets loaded goes into the same global namespace as everything else. If we had complete control of what goes into the browser we could be careful of what gets loaded and avoid any name collisions, however, with applications getting ever more complex, this is hard. What if we are using <a href="https://lodash.com/">Lodash</a> and some widget loads <a href="http://underscorejs.org/">Underscore</a> both of which load as <code>window._</code> in the browser? The one that loads last would end up overwriting the other and, though they are more or less compatible, Lodash is a superset of Underscore and whatever incompatibility there might be in between them might ruin our application.</p>
<p>The beauty of the way NodeJS modules load, is that when we <code>require</code> a certain module, we tell it where we want it, both in name and scope; we say <code>const axios = require('axios');</code> because we want it to be called <code>axios</code> in whichever scope that <code>axios</code> variable is being declared and, if we wanted it called something else, we could do, say, <code>const http = require('axios');</code>.  In browser-land, we don't have that option, we load Axios via <code>&lt;script&gt;</code> and it goes into <code>window.axios</code>, we have no control of name (axios) or scope (global).</p>
<p>This prevents the development of modular applications.  In our server script, we broke our simple app into several source files which <em>require</em>d one another each keeping its internals well hidden from each other exposing only what each explicitly exported.  Over time, several mechanisms to fix this were developed and nowadays, two module packagers are at the top, <a href="http://browserify.org/">Browserify</a> and <a href="http://webpack.github.io/">WebPack</a>.</p>
<p>Inadvertently, we have been using WebPack all along. Remember earlier on that we mentioned there were different versions of Axios, one for NodeJS (which we used for our tests) and the browser version?  Our <code>node_modules/axios</code> folder contains two different folders, <code>dist</code> for the browser version and <code>lib</code> for the NodeJS version.  Looking at the first few lines in the code for the <a href="https://github.com/mzabriskie/axios/blob/master/dist/axios.js">browser version</a> we can see it starts with <code>(function webpackUniversalModuleDefinition(root, factory) {</code> and later on we find a lot of lines preceded with <code>/******/</code>.  All those are added by WebPack. The Axios version on <code>/lib</code> is the original, non-packed version and we can see that the same code from <a href="https://github.com/mzabriskie/axios/blob/master/lib/axios.js#L1">/lib/axios.js</a>   starts about line 60 something in <a href="https://github.com/mzabriskie/axios/blob/master/dist/axios.js#L64"><code>/dist/axios.js</code></a> after all the WebPack packaging handling stuff.</p>
<h2><a class="self-ref" id="chapter11-webpack" href="#chapter11-webpack"># </a>WebPack</h2>
<p>To install WebPack, we do as we've been doing so far:</p>
<pre><code>npm i --save-dev webpack
</code></pre>
<p>We can change our code to use <code>require</code> just as we've done in the server-side code:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-01/client/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-01</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const axios = require('axios');
axios.get('/data/v1/projects')
  .then((response) =&gt; {
    document.getElementById('contents').innerHTML =
    `&lt;h1&gt;Projects:&lt;/h1&gt;&lt;ul&gt;${
      response.data.map((item) =&gt;
        `&lt;li&gt;&lt;a href="project.html?${item.pid}"&gt;${item.name}&lt;/a&gt;&lt;/li&gt;`
      ).join('\n')
    }&lt;/ul&gt;`;
    document.title = 'Projects';
  });</code></pre></div>
<p>Which means we no longer need to load Axios separately in <code>index.html</code> since our web-packaged code will already contain it. The earlier <code>&lt;script src=&quot;/node_modules/axios/dist/axios.js&quot;&gt;&lt;/script&gt;</code> is now gone:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-01/public/index.html"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-01</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="//cdn.polyfill.io/v1/polyfill.min.js?features=Promise" defer async&gt;&lt;/script&gt;
    &lt;script src="lib/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>In <code>.eslintrc.json</code> we can now drop declaring <code>axios</code> as a global variable, leaving only the <em>environment</em> declaration:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-01/client/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-01</div>
    <div class="filename">File: client/.eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "env": {
    "browser": true
  }
}</code></pre></div>
<p>We can change our earlier <code>build</code> script in <code>package.json</code> to use WebPack:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-01/package.json#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"build": "webpack client/index.js public/lib/index.js &amp;&amp; webpack client/project.js public/lib/project.js"</code></pre></div>
<p>So if we now do <code>npm run build</code> we will have our code packaged with Axios. If we look into the resulting files in <code>/public/lib</code> we can recognize our code right after the WebPack un-packager and then the code for Axios.</p>
<p>We can now run this as we did before, we type <code>npm start</code> to launch our server and go to <code>http://localhost:8080</code> in our browser and the app will most likely work if we have an updated browser.  One problem now is that WebPack has packed our code, but has not transpiled it so it still has the ES2015 features.  If we try to run it in an older browser, it will fail.</p>
<h2><a class="self-ref" id="chapter11-packaging-and-transpiling" href="#chapter11-packaging-and-transpiling"># </a>Packaging and Transpiling</h2>
<p>WebPack can use what it calls <em>loaders</em>, utilities that process the code before it gets packed.  Babel has such a loader for WebPack, which we can use:</p>
<pre><code>npm install --save-dev babel-loader babel-core
</code></pre>
<p>We already have <code>babel-preset-es2015</code> installed along <code>babel-cli</code>, otherwise, we should have installed it as well.</p>
<p>To tell WebPack what loaders it should use, we add a configuration file which, by default, is called <code>webpack.config.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-02/webpack.config.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-02</div>
    <div class="filename">File: webpack.config.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">module.exports = {
  module: {
    loaders: [
      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components)/,
        loader: 'babel'
      }
    ]
  }
};</code></pre></div>
<p>Here, we are telling WebPack that for files whose filename match the given regular expression (in this case, they end with <code>.js</code> or <code>.jsx</code>), unless they are under <code>node_modules</code> or <code>bower_components</code>, it should use <code>babel</code> (the <code>-loader</code> suffix is assumed). The <code>.jsx</code> extension is for React files, which we will use later on. <a href="http://bower.io/">Bower</a> is another package manager like NPM which we are not using.  We don't want Babel to waste time trying to transpile code from NPM or Bower libraries because they should already be compatible with old-style JavaScript.</p>
<p>We also need to configure Babel. Earlier on, we did it via an option in the NPM script:</p>
<pre><code>babel client --presets es2015 --out-dir public/lib
</code></pre>
<p>We can also configure Babel via a configuration file called <code>.babelrc</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-02/.babelrc"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-02</div>
    <div class="filename">File: .babelrc</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "presets": ["es2015"]
}</code></pre></div>
<p>After all this, if we do <code>npm run build</code>, we will get both JS files both transpiled and packed.</p>
<p>That means we will no longer be using Babel standalone so we might as well drop <code>babel-cli</code>:</p>
<pre><code>npm uninstall --save-dev babel-cli
</code></pre>
<p>Now, we should make some numbers, the resulting <code>index.js</code> is 32.2kB in size, <code>project.js</code> is 32.4kB.  Most of that is due to Axios and a little bit comes from WebPack which is exactly the same for both.  The difference is in the pre-packaged sources, <code>/client/index.js</code> which is 341 bytes long while <code>/client/project.js</code> is 594 bytes long.</p>
<p>This might seem an extreme situation because we are doing so little in our code, but it is not that different from a real application.  We are using just two common libraries, Axios and WebPack.  In larger applications we would have more such common utilities, for example, standard UI components such as calendars, tabbed interfaces, menus and what not.</p>
<p>We are forcing our web pages to load two scripts which are basically the same.  We can take a look at those two files side by side (using GNU <code>diff</code> or some such) and we will see there is very little difference in between them.</p>
<h2><a class="self-ref" id="chapter11-almost-a-single-page-application" href="#chapter11-almost-a-single-page-application"># </a>Almost a Single Page Application</h2>
<p>We can pack both our client scripts into the same bundle with Axios and WebPack and have our client do just one load. Once the script is in the browser's cache, all pages would benefit from that single download.</p>
<p>To do that, we must first convert our two separate scripts to loadable modules and to do that we have to export something.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/client/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const axios = require('axios');
module.exports = function (contentEl) {
  axios.get('/data/v1/projects')
    .then((response) =&gt; {
      contentEl.innerHTML =
      `&lt;h1&gt;Projects:&lt;/h1&gt;&lt;ul&gt;${
        response.data.map((item) =&gt;
          `&lt;li&gt;&lt;a href="project.html?${item.pid}"&gt;${item.name}&lt;/a&gt;&lt;/li&gt;`
        ).join('\n')
      }&lt;/ul&gt;`;
      document.title = 'Projects';
    });
};</code></pre></div>
<p>We export a function that, when called, will execute mostly the very same code we had so far.  To avoid repetition, the function receives the DOM element that is to receive the content.  We do the same for <code>project.html</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/client/project.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const axios = require('axios');
module.exports = function (contentEl) {
  axios.get(`/data/v1/projects/${window.location.search.substr(1)}`)
    .then((response) =&gt; {
      const prj = response.data;
      contentEl.innerHTML =
        `&lt;h1&gt;${prj.name}&lt;/h1&gt;&lt;p&gt;${prj.descr}&lt;/p&gt;&lt;ul&gt;${
          Object.keys(prj.tasks).map((tid) =&gt; {
            const task = prj.tasks[tid];
            return `&lt;li&gt;&lt;input type="checkbox" ${
              task.completed ? 'checked' : ''
            } /&gt; &amp;nbsp; ${task.descr}&lt;/li&gt;`;
          }).join('\n')
        }&lt;/ul&gt;`;
      document.title = `Project ${prj.pid}: ${prj.name}`;
    });
};</code></pre></div>
<p>Now we have to glue them together which will decide, based on the URL of the page requested, which content to use. Its function is not dissimilar to that of the routers we have been using on the server side so we call it <code>router.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/client/router.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const index = require('./index.js');
const project = require('./project.js');
const contentEl = document.getElementById('contents');
if (/^\/(index\.html)?$/i.test(location.pathname)) {
  index(contentEl);
} else if (/^\/project\.html$/i.test(location.pathname)) {
  project(contentEl);
} else {
  contentEl.innerHTML =
    `Page ${location.pathname} is not available`;
}</code></pre></div>
<p>We require both modules then, depending on the path of the URL requested, we execute one or the other.  The path might be either '/' or <code>/index.html</code> for the default page or <code>/project.html</code>.  If it doesn't match any of the regular expressions for them, we simply show a message. The later should never happen since this script would be loaded by either of those HTML pages.</p>
<p>Now, instead of building two separate packages, we build just one which includes both options.  We can do that by using the WebPack configuration file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/webpack.config.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: webpack.config.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">module.exports = {
  entry: './client/router.js',
  output: {
    path: './public/lib',
    filename: 'bundle.js'
  },
  module: {
    loaders: [
      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components)/,
        loader: 'babel'
      }
    ]
  }
};</code></pre></div>
<p>We are telling WebPack that the entry point for our app is <code>/client/router.js</code> and our packaged file should be called <code>bundle.js</code> and will go into <code>/public/lib</code>.  WebPack loads the file that is the entry point, parses it and locates all its calls to the <code>request</code> function, then loads and parses those looking for their <code>require</code>s and so on until it packages all of the dependencies into <code>bundle.js</code>.</p>
<p>The build script in <code>package.json</code> is now far simpler since all the information is now in the configuration file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/package.json#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"build": "webpack"</code></pre></div>
<p>We also need to change both <code>index.html</code> and <code>project.html</code> because instead of each loading its own separate JavaScript file, they both load <code>bundle.js</code> which, with the router and all, has grown to 33.9kB:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/public/index.html"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="//cdn.polyfill.io/v1/polyfill.min.js?features=Promise" defer async&gt;&lt;/script&gt;
    &lt;script src="lib/bundle.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>The <code>/public/lib</code> folder might still contain <code>index.js</code> and <code>project.js</code> files from previous compilations. We may delete those since they are no longer used.</p>
<p>Not surprisingly, both HTML files are exactly the same, their content determined by the single JavaScript file <code>bundle.js</code> which decides what to show.  Unfortunately, the browser doesn't actually know the two files are alike, since each comes from a different URL it will load each HTML file separately.  We still need the two files because the user might enter either of the two URLs, unless we fix that in the router.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-04/server/index.js#L20-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 20</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">app.use(
  /\/((index.html)|(project.html))?/,
  express.static(path.join(__dirname, '../public/index.html'))
);</code></pre></div>
<p>The routing functions of Express can take regular expressions instead of strings. We use that ability to tell Express that if the user requests <code>/</code>, <code>/index.html</code> or <code>/project.html</code>, it should return the very same <code>index.html</code> file.  We can now delete <code>/public/project.html</code>.</p>
<p>Now it really starts to look like a Single Page Application.  We have a single <code>index.html</code> and a single <code>bundle.js</code> to serve both requests.  However, whenever the user navigates from one page to the other, those requests will still go all the way to the server.  Browsers keep copies of what they load in their caches so, most likely, it will load the cached copy, however, it will still do a quick check with the server to make sure those files are still valid.</p>
<p>It would be good to be able to tell the browser to load it only once and avoid bothering the server with these requests.</p>
<p>It would also be nice to have a more capable router than our improvised <code>router.js</code> is.</p>
<p>Fortunately, there is already software to do both things, client-side routing software can handle routes pretty much as Express does and will capture navigation requests and prevent them from generating unnecessary traffic.</p>
<h2><a class="self-ref" id="chapter11-summary" href="#chapter11-summary"># </a>Summary</h2>
<p>We've seen how we can benefit from the same module-loading capability of NodeJS in the browser by using a bundler such as WebPack or Browserify.</p>
<p>By using a primitive router, we have managed to put our two earlier JS files into a single bundle and by configuring our server, we can deliver our application using only one set of files.</p>
<h1><a class="self-ref" id="chapter12-client-side-routing" href="#chapter12-client-side-routing"># </a>Client-side Routing</h1>
<p>In our latest version of <code>router.js</code> we used regular expressions to match the URL of the page requested to the routes we are handling so as to run either of our rendering scripts.  Basically, it is the equivalent of what we've been doing in the server thanks to Express.  There is client software to do the same on the client.  This is our routes configuration</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L10-L18"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 18</div>
  </div>
  <pre><code class="language-js">const routeConfig = {
  path: '/',
  component: App,
  indexRoute: { component: Index },
  childRoutes: [
    { path: 'index', component: Index },
    { path: 'project/:pid', component: Project }
  ]
};</code></pre></div>
<p>It is easy to relate the array of routes under the <code>childRoutes</code> property, they are basically the same as we had before with some minor differences. The paths  lack the <code>.html</code> ending and the <code>pid</code> parameter is part of the route path instead of a query parameter, so it follows the standard where the item should be identified by the route itself while the query parameters are meant for options.  Also, in the earlier example, it was the <code>project.js</code> module the one that read the <code>pid</code>.  Here it is more like in Express, where the router picks it up from the route itself. Likewise, route matching is sequential within an array so the order is important.</p>
<p>Routes in the client work somewhat different than in the server. In the server routes result in running some piece of script that sends a stream of HTML code, images, JSON data or any other sequential collection of bytes with a single call to <code>res.send()</code> or its variations. There is only one stream of data going out of the server.</p>
<p>Routes in the client are meant to affect a two-dimensional screen where each part of the route might influence a particular section of it.  For example, most web pages will have a standard look, starting with an enclosing frame with the basic color scheme, perhaps the company logo, a copyright sign and so on.  Within that frame there might be other standard sections such as a header or footer, perhaps a menu or tabbed interface and finally, there will be one or more sections that are totally dependent on the route.  For example, a mail-client program will have a main section that contains the list of folders for the <code>/</code>, a list of messages in the inbox for <code>/inbox</code> or a particular message for <code>/inbox/de305d54-75b4-431b-adb2-eb6b9e546014</code>.   Each responds to a fragment of the full URL and they all combine to build the full screen.</p>
<p><img src="routes.png" alt="email program layout"></p>
<p>The image above shows how the different parts of the URL bring up different sections on the screen layout for such application, with each section dealing with a little bit more of the URL and enclosing the more specific section. That is why client-side routes are hierarchical and why our routes from the previous example are <code>childRoutes</code> within the root route. Each section is handled by a <em>component</em>. A typical application will handle more levels than this simple example, nesting many more components. Our router includes two components:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L5-L6"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 6</div>
  </div>
  <pre><code class="language-js">const Index = require('./index.js');
const Project = require('./project.js');</code></pre></div>
<p>Our <code>Index</code> and <code>Project</code> components will be React versions of the former <code>index.js</code> and <code>project.js</code>, as we will soon see.  For our overall frame, responding to the <code>/</code> part of the path, we have an <code>App</code> component which is quite simple indeed:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 8</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-js">const App = (props) =&gt; props.children;</code></pre></div>
<p>Basically, what it says is that the App frame, which will receive some <code>props</code> properties, most of them from the router and amongst them the <code>children</code> property, should just return whatever the children produce. Of course it usually is something more elaborate, some frame, logo or some such, but right now, this should suffice. We must have a single overarching frame, even if it does nothing more than enclosing any number of children because, after all, we only have one screen.</p>
<p>With the <code>indexRoute</code> option we are also telling the router that when no route is specified, the <code>Index</code> component should be shown.  In other words, we are defaulting to showing the <code>Index</code> component whether we explicitly ask for it with <code>/index</code> or not, very much like the regular <code>index.html</code> default.</p>
<h2><a class="self-ref" id="chapter12-react-router" href="#chapter12-react-router"># </a>React Router</h2>
<p>We are using <a href="https://www.npmjs.com/package/react-router">React Router</a> which works along <a href="https://facebook.github.io/react/">React</a> so we first have to install those.</p>
<pre><code class="language-bash">npm i --save react react-dom react-router history
</code></pre>
<p>We install these with the <code>--save</code> option, not <code>--save-dev</code> because they are part of the production code, not just development tools, and so they go into the <code>dependencies</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/package.json#L33-L43">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> section of <code>package.json</code>. Besides React and React Router, we are installing <code>react-dom</code> which contains the parts of React specific to browsers as opposed to other possible environments such as smart-phones or future platforms, and <code>history</code> which complements the router by letting it manipulate the browser history and respond to the back and forward buttons (I don't know why the highlighter put that one in a different color, sorry).</p>
<p>We can then use those packages into our script:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L1-L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">import React from 'react';
import { render } from 'react-dom';
import { Router, browserHistory  } from 'react-router';</code></pre></div>
<p>The magic of Babel transpiling allows us to use both the new ES2015 <code>import</code> statement and the CommonJS <code>require</code> function.  The new <code>import</code> statement allows us to import whole packages such as <code>React</code> or just one or more named exports within a package such as <code>render</code> from <code>react-dom</code> or <code>Router</code> and <code>browserHistory</code> from <code>react-router</code> (actually, it is ES6 <em>destructuring</em> that lets us pick the pieces we want, more on that later).</p>
<p>With all these pieces, we must put this <code>routeConfig</code> to work:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L20-L29"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 20</div>
    <div class="to">To: 29</div>
  </div>
  <pre><code class="language-js">render(
  React.createElement(
    Router,
    {
      routes: routeConfig,
      history: browserHistory
    }
  ),
  document.getElementById('contents')
);</code></pre></div>
<p>We are asking React to <code>render</code> a new React element provided by <code>Router</code> into the <code>&lt;div id=&quot;contents&quot;&gt;</code> we have on our <code>index.html</code> page <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/public/index.html#L8">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  The router will not be a visible DOM element itself, it is the components selected according to <code>routeConfig</code> that will produce the DOM elements we will eventually see in the web page. We provide this <code>Router</code> element with two configuration elements, the <code>routes</code> property points to the <code>routeConfig</code> we have defined and <code>history</code> pointing to <code>browserHistory</code> which is one of several history managers the router can use.</p>
<p>History managers handle the locations the browser visits.  They listen to changes in the locations (i.e.: <code>window.location</code>), such as those seen in the address bar of the browser, and handle them on the client-side, without sending any actual request to the server. The <code>browserHistory</code> manager is the only one that is worth serious consideration in production.  It is not the default because it requires some support from the server.</p>
<p>Instead of the complex route we had to support our earlier primitive version of router <a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-04/server/index.js#L20-L23">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> we now have a simpler, catch-all route in our Express server:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/server/index.js#L18-L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-js">app.use(express.static(path.join(__dirname, '../public')));

app.get('*', function (request, response) {
  response.sendFile(path.join(__dirname, '../public', 'index.html'));
});</code></pre></div>
<p>Thanks to our client-side router, our application will be able to respond to several <em>virtual</em> URLs which don't actually exist on the server side.  At any time, the user might save one of those URLs or copy and paste them into an e-mail to pass them on to someone else.  What happens when any of those URLs are requested?  If the user had started the application from the home page, all routing would be handled by the client but if, out of the blue, the user requests one of those virtual URLs, the request will go straight to the server, but there is no actual file there to be sent back to the user. That is why we have to add this route, we are letting the client app to handle those virtual routes.  As a rule, wildcard, catch-all routes should go at the end, after all other routes have been dealt with.</p>
<p>So far, if the URL requested was for any of the known paths such as <code>/data/v1/projects</code> there was a piece of script to handle it, otherwise it felt through and got to that <code>express.static</code> middleware which tried to find a file that mapped to the requested path.  Then, if no file was found, it would let the request fall through by calling the <code>next()</code> callback.  If that was the end of the list of routes  and route patterns (which it was) Express, having nowhere else to look for, sends a <code>404 Not Found</code> reply. If there had been any further routes or patterns, Express would try them as well before quiting.</p>
<p>The wildcard <code>'*'</code> route we add means that for absolutely any leftover route the file <code>/public/index.html</code> will be sent.  That will load and run our application and then the client-side router will deal with that route.</p>
<p>This also means that our client-side App must deal with the 404 Not found condition on its own because the server will never send that error on its own. We may do this by adding a wildcard route at the end of the child routes:</p>
<pre><code class="language-js">childRoutes: [
  { path: 'index', component: Index },
  { path: 'project/:pid', component: Project },
  { path: '*', component: NotFound }
]
</code></pre>
<p>Since the routes are matched in sequence, the last wildcard catches any route that failed to match and it shows the <code>NotFound</code> component, which is simply declared like this:</p>
<pre><code class="language-js">const NotFound = () =&gt; (&lt;h1&gt;Not found&lt;/h1&gt;);
</code></pre>
<p>That line of JavaScript doesn't look right, does it? The <code>&lt;h1&gt;Not found&lt;/h1&gt;</code> part should be quoted or something since it is not JavaScript but HTML. Any linter would signal it as an error and Babel would not be able to transpile it as we have configured it so far.   Actually, that is JSX and we will use it more extensively.</p>
<h2><a class="self-ref" id="chapter12-jsx" href="#chapter12-jsx"># </a>JSX</h2>
<p><a href="https://facebook.github.io/jsx/">JSX</a> is an extension to JavaScript designed by Facebook to embed HTML into plain JavaScript.  It is not a proposal for future JavaScript versions nor it is meant to be included in any browser but to be transpiled.</p>
<blockquote>
<p>If I may take a moment to brag about it, back towards the end of 2008 I made a proposal to embed HTML into PHP. I called it <a href="http://www.satyam.com.ar/pht/">PHT</a> which resulted from a merger of the letters in PHp and HTml.  It was an extension to the <a href="http://phpcompiler.org/">PHP Compiler</a> which could generate native code but could also serve as a transpiler.  I used is as a transpiler to create regular PHP out of PHT code.  Mechanisms to publish and make open source contributions back then were not widely available, no GitHub or any such popular sharing mechanisms, so the idea faded away.</p>
</blockquote>
<p>JSX is based on the fact that the less-than sign <code>&lt;</code> is a binary operator in JavaScript so it should be found in between expressions to be compared and it could not possibly be found at the start of an expression.  The JSX transpiler catches those unary <code>&lt;</code> and takes care of dealing with what follows. If we are not sure whether the transpiler would consider a <code>&lt;</code> to be a <em>less than</em> operator or JSX, we just open a parenthesis right before it, like in <code>(&lt;h1&gt; ...)</code> because that ensures the start of a new expression.</p>
<p>None of our code lints or compiles as it is.  We need some extras to deal with JSX:</p>
<pre><code class="language-bash">npm i --save-dev babel-preset-react eslint-config-airbnb eslint-plugin-react
</code></pre>
<p>We are installing a whole bunch of Babel extensions which are encompassed into a preset collection called <code>babel-preset-react</code>.  We need to tell Babel to use that preset by modifying our <code>.babelrc</code> file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/.babelrc"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: .babelrc</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-">{
  "presets": ["es2015", "react"]
}</code></pre></div>
<p>Babel assumes the <code>babel-preset-</code> prefix to the names listed in the <code>presets</code> entry.</p>
<p>We are also loading a new ESLint plugin to handle React, which uses JSX extensively and a rules configuration file <code>eslint-config-airbnb</code>, which is the standard set of routes used by the <a href="https://www.airbnb.com/">Airbnb</a> development team.   We are making use of a nice feature of ESLint which is that we can use different preset configurations in different folders.  We will be still using the <code>eslint-config-standard</code> presets for the server-side code, as we've been doing so far, but will use the Airbnb ones for our client side code.  To do that we simply add a <code>.eslintrc.json</code> file in the <code>/client</code> folder:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/.eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "extends": "airbnb",
  "env": {
    "browser": true
  }
}</code></pre></div>
<p>The rules are extensively explained and, when not purely stylistic, thoroughly justified in their <a href="https://github.com/airbnb/javascript">GitHub repository</a>.  For the purpose of this book, it is just interesting to note that two teams, working in different environments, one in the server using native NodeJS with no transpiling, the other on the client with Babel, can use different styles and rules suited to their environment.</p>
<p>We can use JSX far more extensively.  All our routes can be expressed in JSX:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/router.js#L11-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">render((
  &lt;Router history={browserHistory}&gt;
    &lt;Route path="/" component={App}&gt;
      &lt;IndexRoute component={Index} /&gt;
      &lt;Route path="index" component={Index} /&gt;
      &lt;Route path="project/:pid" component={Project} /&gt;
      &lt;Route path="*" component={NotFound} /&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), document.getElementById('contents'));</code></pre></div>
<p>We have already seen that to embed JSX we just need to start an expression with a <code>&lt;</code>.  We can also embed plain JavaScript into JSX by enclosing any expression in curly brackets.  We do that with <code>{App}</code>, <code>{Index}</code>, <code>{Project}</code>, <code>{NotFound}</code> or <code>{browserHistory}</code>, which are either <code>const</code>ants declared in JavaScript or imported modules.  Any sort of expression can thus be embedded, very much like we do in ES6 template strings by enclosing variable parts in <code>${ }</code>.</p>
<p>The React plugin for Babel creates plain JavaScript for all that JSX, it turns them into calls to <code>React.createElement</code>, in other words, it would transpile it into something pretty much like the code we had before <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L10-L29">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Some of these elements are plain HTML others are React components.  To tell them apart, HTML elements should be all lowercase, <code>&lt;h1&gt;</code> or <code>&lt;div&gt;</code> while React components should start with uppercase <code>&lt;Router&gt;</code> or <code>&lt;IndexRoute&gt;</code>.  That is why we changed our <code>index</code> and <code>project</code> references into <code>Index</code> and <code>Project</code>.</p>
<p>This is how our previous <code>index.js</code> might look using JSX for React:</p>
<pre><code class="language-js">import React from 'react';
import { Link } from 'react-router';
const data = require('./data.js');

export default () =&gt; (
  &lt;div className=&quot;project-list&quot;&gt;
    &lt;h1&gt;Projects:&lt;/h1&gt;
    &lt;ul&gt;{
      Object.keys(data).map(pid =&gt;
        (&lt;li key={pid}&gt;
          &lt;Link to={`project/${pid}`}&gt;
            {data[pid].name}
          &lt;/Link&gt;
        &lt;/li&gt;)
      )
    }&lt;/ul&gt;
  &lt;/div&gt;
);
</code></pre>
<p>This is called a <em>stateless</em> component in React.  It is simply a <em>fat arrow</em> function that returns whatever needs to be displayed. That function is our default export. Our earlier <code>App</code> and <code>NotFound</code> components were simple stateless components.  There are <em>stateful</em> components as well, which we will see later.</p>
<p>We are importing <code>data.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/data.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which is the same <code>data.json</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/server/data.json">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> turned into a module, so that we don't need to interact with the server. We will do that in later chapters.  Note how we can mix ES6 <code>import</code> statement with CommonJS <code>require</code> in the same module. It is safe to use <code>import</code> with those modules that were exported using ES6 <code>export</code> statement and <code>require</code> with those exported by assigning to the <code>module.exports</code> property, the other combinations are not straightforward.</p>
<p>Besides plain HTML elements, we are using the <code>&lt;Link&gt;</code> component from <code>react-router</code>.  This component renders as a plain <code>&lt;a&gt;</code> element but it is tied internally to the router so the link will not be actually followed but caught by the router and processed so as to activate the corresponding component.</p>
<p>There is also a <code>key</code> attribute added to each <code>&lt;li&gt;</code> element.  This is an optimization for React.  Whenever there is a repeated element such as the list elements within a <code>&lt;ul&gt;</code> it helps if we provide React with a unique id to tell them apart.  It helps it optimize the screen refresh specially when items are added or removed.</p>
<p>We can improve on this component by separating it into the list and the items:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import React from 'react';
import { Link } from 'react-router';
const data = require('./data.js');

const ProjectItem = ({ pid, name }) =&gt; (
  &lt;li className="project-item"&gt;
    &lt;Link to={`project/${pid}`}&gt;
      {name}
    &lt;/Link&gt;
  &lt;/li&gt;
);

ProjectItem.propTypes = {
  pid: React.PropTypes.string.isRequired,
  name: React.PropTypes.string.isRequired,
};

const ProjectList = () =&gt; (
  &lt;div className="project-list"&gt;
    &lt;h1&gt;Projects:&lt;/h1&gt;
    &lt;ul&gt;{
      Object.keys(data).map(pid =&gt;
        (&lt;ProjectItem key={pid} pid={pid} name={data[pid].name} /&gt;)
      )
    }&lt;/ul&gt;
  &lt;/div&gt;
);

export default ProjectList;</code></pre></div>
<p>The <code>ProjectItem</code> component displays a single project item in the list.  We use it within the loop in the project list by using it as a JSX component <code>&lt;ProjectItem&gt;</code> and providing it with what look like HTML attributes, <code>pid</code> and <code>name</code>.</p>
<p>The <code>ProjectItem</code> component receives a <em>properties</em> argument, usually referred to as <code>props</code>, which is an object containing all pseudo-HTML-attributes used when invoked.  Here we are using ES6 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destructuring</a> to explicitly assign the relevant properties within the <code>props</code> object into variables that might well be considered function arguments.  The following segments of code are equivalent:</p>
<pre><code class="language-js">const ProjectItem = ({ pid, name }) =&gt; (
// --------------------
const ProjectItem = props =&gt; {
  let {pid, name} = props;
}
// -----------------
const ProjectItem = props =&gt; {
  let pid = props.pid;
  let name = props.name;
}
</code></pre>
<p>Destructuring is new to JavaScript in ES6, it is not JSX nor React. We have already used <em>destructuring</em> in the <code>import</code> statements.</p>
<p>As a general rule, it is customary to add a <code>className</code> attribute to the outermost element in each component, derived from the name of the component itself. Thus, for <code>ProjectItem</code> we have <code>project-item</code>, for <code>Task</code>, <code>task</code>, each following the standard naming conventions of the language. However, there is nothing but custom preventing us from using <code>ProjectItem</code> as a class name and we might as well have done so. Since <code>class</code> is a reserved word in JavaScript and JSX allows us to mix JavaScript and HTML, it is not good to use <code>class</code> as the HTML attribute name, thus, we must use <code>className</code> instead.  Likewise, in <code>&lt;label&gt;</code> elements, instead of <code>for</code> as we must use <code>htmlFor</code>.</p>
<p>The Router component uses properties to send information to the components.  We use that in <code>project.js</code> which should read the <code>pid</code> from the route. Just as Express does on the server-side, Router also provides a <code>params</code> object with the decoded parameters which we can then retrieve from the <code>props</code> argument using, once again, <em>destructuring</em>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/project.js#L27-L34"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 27</div>
    <div class="to">To: 34</div>
  </div>
  <pre><code class="language-js">const Project = ({ params: { pid } }) =&gt; {
  const prj = data[pid];
  return (&lt;div className="project"&gt;
    &lt;h1&gt;{prj.name}&lt;/h1&gt;
    &lt;p&gt;{prj.descr}&lt;/p&gt;
    &lt;TaskList tasks={prj.tasks} /&gt;
  &lt;/div&gt;);
};</code></pre></div>
<h3><a class="self-ref" id="chapter12-proptypes" href="#chapter12-proptypes"># </a>PropTypes</h3>
<p>React provides us with a mechanism to validate the nature of properties passed to components.  We can declare the data types of those properties by adding a  <code>propTypes</code> static object to our components.  React has two modes of operation, production and development.  In development mode, the default, it will check a good number of things and issue warnings to help us pinpoint any problems ahead of time.  It will skip on this checks when running in production mode. Thus, we can add property validation at no performance cost to us.</p>
<p>For the above <code>ProjectItem</code> component we can add the following property validation:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/index.js#L13-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">ProjectItem.propTypes = {
  pid: React.PropTypes.string.isRequired,
  name: React.PropTypes.string.isRequired,
};</code></pre></div>
<p>React provides a good number of <a href="https://facebook.github.io/react/docs/reusable-components.html#prop-validation">PropTypes</a> to check the properties of any component.  We have used <code>string</code> as the data type for <code>pid</code> because object property names are always converted to strings even when they originally were numbers.  The optional <code>isRequired</code> can be added to any other data type to make it mandatory.</p>
<h3><a class="self-ref" id="chapter12-production-version" href="#chapter12-production-version"># </a>Production version</h3>
<p>To create the <em>production</em> version to be deployed in a real life installation we need to create a new configuration file <code>webpack.production.config.js</code> for WebPack.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/webpack.production.config.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: webpack.production.config.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const webpack = require('webpack');

module.exports = Object.assign(require('./webpack.config.js'), {
  plugins: [
    new webpack.DefinePlugin({
      'process.env': {
        'NODE_ENV': JSON.stringify('production')
      }
    })
  ]
});</code></pre></div>
<p>We are using the original configuration file <code>webpack.config.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/webpack.config.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> as the basis and adding one of WebPack's built-in plugins that allows us to add environment variables to the task.  To run it we add another command to our <code>package.json</code> file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/package.json#L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 13</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-json">"production": "webpack -p --config webpack.production.config.js"</code></pre></div>
<p>So, if we do <code>npm run production</code> we will run WebPack with the new configuration file and also with the <code>-p</code> or <em>production</em> option which produces a minimized version with all comments and formatting stripped off.</p>
<p>When we run this NPM script, we will get hundreds of warning messages mostly produced by <a href="https://www.npmjs.com/package/uglify-js">Uglify</a> saying <code>Condition always false</code> or <code>Dropping unreachable code</code> in many locations.  This is because React has plenty of pieces of code to validate and verify the workings of the components we write while in development, each enclosed in a conditional such as:</p>
<pre><code class="language-js">if (process.env.NODE_ENV !== 'production') {
</code></pre>
<p>Since we have set <code>NODE_ENV</code> to <code>production</code> all those pieces of code will not be included in the output, which is good. We will drop those warnings later on but it is good to see them once to appreciate how much code React has to keep us safe.</p>
<p>Our code not only runs faster but after being minified and stripped of all unnecessary code, our <code>bundle.js</code> file has gone down from about 930kB to less than 200kB, almost a fifth in size.</p>
<p>WebPack also has a <code>-d</code> option for development, which produces a <em>SourceMap</em> which cross-references the output code in the bundle to the original code and helps in debugging.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/package.json#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"build": "webpack -d",</code></pre></div>
<h3><a class="self-ref" id="chapter12-watch-for-changes" href="#chapter12-watch-for-changes"># </a>Watch for changes</h3>
<p>While doing all these changes, we start getting bored of typing the <code>npm run build</code> command after every single change.  We can simplify this by using WebPack's <em>watch</em> feature with the following extra NPM script command:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/package.json#L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 12</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-json">"watch": "webpack -d --watch &amp;",</code></pre></div>
<p>Running WebPack with the <code>--watch</code> option tells it to keep an eye on all the dependencies that make up the bundle.  If any of them change, WebPack will automatically rebuild the bundle.  By adding the <code>&amp;</code> at the end, we leave it to run in the background, freeing us to do <code>npm start</code> to start the web server. We do this only for the development version since that is the one we will be changing continuously.</p>
<h3><a class="self-ref" id="chapter12-final-touches" href="#chapter12-final-touches"># </a>Final touches</h3>
<p>The <code>import</code> statement allows us to import both the whole module at once and specific named exports within it:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/client/index.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-03</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">import React, { PropTypes } from 'react';</code></pre></div>
<p>Here we are importing <code>React</code> wholesale as we've been doing so far but also importing <code>PropTypes</code> as a separate named import.  This makes it shorter for us when declaring the property types:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/client/index.js#L13-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-03</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">ProjectItem.propTypes = {
  pid: PropTypes.string.isRequired,
  name: PropTypes.string.isRequired,
};</code></pre></div>
<p>We are also exporting <code>ProjectItem</code> as a separate named export (in contrast to the default export which is <code>ProjectList</code>).</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/client/index.js#L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-03</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-js">export const ProjectItem = ({ pid, name }) =&gt; (</code></pre></div>
<p>Adding that named export doesn't affect our use of the main component, which is the default export, while it allows us to run separate tests on <code>PrjItem</code>.  It is a good practice to provide direct access via named exports to the subcomponents within a module for testing.</p>
<p>Finally, we have added a configuration option to our <code>webpack.production.config.js</code>  <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/webpack.production.config.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> so it will not print those hundreds of warning messages when generating the production version.</p>
<h2><a class="self-ref" id="chapter12-summary" href="#chapter12-summary"># </a>Summary</h2>
<p>We have modified our basic application to run on React, JSX and React Router.</p>
<h1><a class="self-ref" id="chapter13-events" href="#chapter13-events"># </a>Events</h1>
<p>Our simple App shows existing information but does not allow us to change it in any way.  To do that we first have to respond to events from the UI.</p>
<p>Regular DOM events provide us with information about the DOM element involved and additional information such as which mouse button was used in a click, which key was pressed with which modifiers, the cursor coordinates and much more.  However, when we develop our own components we should define what information might be of interest to the developer who is using that component and satisfy those expectations.</p>
<p>Take our Task component <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/client/project.js#L4-L8">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Could anyone possibly care the precise [x,y] coordinates of the cursor within that component when the item is clicked? Or weather the element was clicked, touched, stared at or thought about?  It would be far more important to provide the <code>tid</code> of the task and its new completion status.  Thus, we might define our <code>onCompletedChange</code> custom event object having just a couple of properties, the <code>tid</code> and the new value for <code>completed</code>. In this way we translate a DOM event closely related to the browser environment into an abstract application-oriented event with information suitable to higher level components.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/client/project.js#L4-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-01</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">export const Task = ({ descr, completed, tid, onCompletedChange }) =&gt; {
  const onClickHandler = ev =&gt; {
    if (ev.button || ev.shiftKey || ev.altKey || ev.metaKey || ev.ctrlKey) return;
    ev.preventDefault();
    onCompletedChange({
      tid,
      completed: !completed,
    });
  };
  return (&lt;li onClick={onClickHandler} className={`task ${completed ? 'completed' : 'pending'}`}&gt;
    {descr}
  &lt;/li&gt;);
};</code></pre></div>
<p>We change the argument list of our <code>Task</code> component to receive extra properties, <code>tid</code> and <code>onCompletedChange</code>.  Actually, <code>Task</code> is still receiving a single argument, an object usually called <code>props</code>, short for <em>properties</em>. We are adding a couple of names of the properties we are destructuring out of that single object.</p>
<p>First, we define an <code>onClickHandler</code> for the DOM <code>onClick</code> event. The <code>onClickHandler</code> function will receive the <code>ev</code> DOM Event object. We check if the event was triggered with any mouse button except the primary one, or modified with the shift, alt, meta or control keys.  If any of those conditions is true, we simply return and do nothing.  Otherwise, we call <code>ev.preventDefault()</code> to signal the DOM that we are taking care of that event and that the default action, whatever that might have been, does not need to be invoked. So far, all these operations are closely related to the DOM and the browser environment. Finally, we call the <code>onCompletedChange</code> callback we received as an argument providing it with an object with the <code>tid</code> of the task clicked and the new value for <code>completed</code>.  This object is the application-oriented event object, it contains no browser information.</p>
<p>As before, the <code>Task</code> component returns the actual elements to be rendered much as we did before, except that we are adding an <code>onClick</code> DOM event handler to the <code>&lt;li&gt;</code> element.  We have also dropped the checkbox we used before to represent the completion status in favor of changing the <code>className</code> of the list item.  This is, in fact, a far more flexible alternative as it gives the graphic designer more options, even simulating a checkbox, via CSS. Consequently, we have added a CSS file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/public/index.css">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which we included in <code>index.html</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/public/index.html#L6">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>To make it work, we have to modify the <code>TaskList</code> component to provide <code>Task</code> with the new arguments.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/client/project.js#L25-L39"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-01</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 25</div>
    <div class="to">To: 39</div>
  </div>
  <pre><code class="language-js">export const TaskList = ({ pid, tasks }) =&gt; {
  const onCompletedChangeHandler = ev =&gt; console.log('Completed Changed', Object.assign(ev, { pid }));
  return (&lt;ul className="task-list"&gt;{
    Object.keys(tasks).map(tid =&gt; {
      const task = tasks[tid];
      return (&lt;Task
        key={tid}
        descr={task.descr}
        completed={task.completed}
        tid={tid}
        onCompletedChange={onCompletedChangeHandler}
      /&gt;);
    })
  }&lt;/ul&gt;);
};</code></pre></div>
<p>We define a trivial handler that simply sends to the console the event object it receives, augmented with the <code>pid</code>.  No browser-related information is handled at this point.  The <code>Task</code> component provides the <code>tid</code> because that is what it deals with, one simple task.  Components higher up may augment this with more information, such as the <code>pid</code>.</p>
<p>Now, we must provide the <code>&lt;Task&gt;</code> component with the new <code>tid</code> and <code>onCompletedChange</code> properties. The list of pseudo-HTML-attributes has grown so large that we had to spread it into multiple lines.  The <code>propTypes</code> for <code>Task</code> has also grown:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/client/project.js#L18-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-01</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">Task.propTypes = {
  completed: PropTypes.bool,
  descr: PropTypes.string,
  tid: PropTypes.string,
  onCompletedChange: PropTypes.func,
};</code></pre></div>
<p>It is important to notice that the way we use the <code>onCompletedChange</code> attribute of the <code>&lt;Task&gt;</code> component looks very much like a DOM event such as the regular <code>onClick</code> attribute on the  <code>&lt;li&gt;</code> element, we just assign a callback function that will be called when the expected event happens. Both callbacks will receive an object which will contain suitable properties.</p>
<p>As we click on the tasks within the project, we will be able to see in the browser console the messages from our handler.  They won't show if we press any of the modifier keys or use any button but the primary one.</p>
<p>We have responded to the UI event signaling the intent of the user to change the completion status of the task but we haven't done that yet.  It should be pretty easy just by changing the event handler in <code>TaskList</code>:</p>
<pre><code class="language-js">const onCompletedChangeHandler = ({ tid, completed }) =&gt; {
  tasks[tid].completed = completed;
};
</code></pre>
<p>We are once again using destructuring to take the <code>tid</code> property out of the event object.  It is easy to set the completion status since <code>TaskList</code> has a reference to all the tasks in the project. Of course, we are reading and changing all this data from an in-memory copy of <code>data.js</code> so all changes are purely local and volatile, but we will get to that in a moment. Now, the problem is to refresh this new state in the UI.</p>
<p>One way to do it would be to call <code>render</code> again as we did in <code>router.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/client/router.js#L11">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  It will work but it is a little too extreme!  It would be fast for a small application such as ours but it makes no sense for anything larger.</p>
<p>React uses a <em>virtual DOM</em>. It keeps a very succinct version of the DOM in memory as it was rendered the last time. Lets call this the <em>existing</em> copy.  When it does a refresh, React produces a new version, the <em>expected</em>.  It then compares the <em>expected</em> against the <em>existing</em> version.   When it finds a difference, it only sends the minimum of commands to change the DOM to reflect the expectations.</p>
<p>Changes to the DOM are expensive, specially if they involve a re-flow of the whole page.  Producing the <em>expected</em> version and comparing it against the <em>existing</em> is relatively cheap, however, it is not free, it does take some effort, less than re-rendering the full DOM but it still takes time.</p>
<p>If we can tell React what has actually been changed, React can do much less work.  To do that, we need our components to remember their previous state and know when that state has changed.  So far, we have used <em>stateless</em> components, we need to go to <em>stateful</em> ones.</p>
<h2><a class="self-ref" id="chapter13-stateful-components" href="#chapter13-stateful-components"># </a>Stateful components</h2>
<p>Stateless components are simple functions that receive a series of properties and return whatever should be rendered.   Stateful components are classes derived from <code>React.Component</code>.  Lets convert our <code>Task</code>  stateless component into a stateful one. Just as we did with <code>PropTypes</code> we extract <code>Component</code> as a separate import from <code>React</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">import React, { PropTypes, Component } from 'react';</code></pre></div>
<p>Instead of a simple function, our <code>Task</code> component is now a class:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L4-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">export class Task extends Component {
  constructor(props) {
    super(props);
    this.state = {
      completed: props.completed,
      descr: props.descr,
    };
    this.onClickHandler = this.onClickHandler.bind(this);
  }</code></pre></div>
<p>As all classes, it has a <code>constructor</code> which receives the <code>props</code> argument.  Before doing anything else, it is important to call the constructor of the parent class, in this case, <code>React.Component</code>.  We do this by calling <code>super(props)</code>. React.Component needs to receive those properties for its internal workings.</p>
<p>React knows when to render a component based on its internal state.  It the state has changed, it assumes it needs re-rendering.  This doesn't mean it will completely regenerate the DOM for this component, what it will do is to create that <em>expected</em> in-memory image which, at some point, it will compare to the <em>existing</em> image and, wherever they differ, it will issue the appropriate DOM commands.</p>
<p>One of the tasks of the constructor is to set the initial state of the component.  We do this by setting <code>this.state</code> to an object containing the relevant properties.  We only use <code>descr</code> and <code>completed</code> for the state.  The <code>tid</code> is the primary key for the task so it should not change and doesn't need to be part of the possibly changing state.  The <code>onCompletedChange</code> property shouldn't change either.</p>
<p>Finally, we <code>bind</code> the event handler to <code>this</code>.  As with all event handlers, whether DOM or custom ones, when the handler is called, it is called in the context of the caller or with no context at all.  This means that the handler would not have access to the <code>this</code> of its own class.  We use that handler in the <code>render</code> function and we might bind it there, when it gets used but, as the <code>render</code> function may be called lots of times, it is better to bind it just once in the constructor. Repeatedly calling <code>bind</code> does not only waste time but it leaves behind a small piece of memory allocated for each bound function and those bits end up trashing the memory space and forcing more work on the garbage collector.</p>
<p>The <code>render</code> function is very much like our earlier stateless component:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L22-L31"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 31</div>
  </div>
  <pre><code class="language-js">render() {
  return (
    &lt;li
      onClick={this.onClickHandler}
      className={`task ${this.state.completed ? 'completed' : 'pending'}`}
    &gt;
      {this.state.descr}
    &lt;/li&gt;
  );
}</code></pre></div>
<p>The main difference is that instead of reading <code>descr</code> and <code>completed</code> from the argument list, it reads them from <code>this.state.descr</code> and <code>this.state.completed</code>.  Also, it uses <code>this.onClickHandler</code> instead of accessing <code>onClickHandler</code> via closure as it did before.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L13-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">onClickHandler(ev) {
  if (ev.button || ev.shiftKey || ev.altKey || ev.metaKey || ev.ctrlKey) return;
  ev.preventDefault();
  this.props.onCompletedChange({
    tid: this.props.tid,
    completed: !this.state.completed,
  });
  this.setState({ completed: !this.state.completed });</code></pre></div>
<p>The handler itself does the same.  Instead of accessing the <code>onCompletedChange</code> callback via closure, it reads it from <code>this.props.onCompletedChange</code>.  It does the same with <code>this.props.tid</code>.  That is one of the visible effects of calling <code>super(props)</code> in the constructor, React will copy all the properties received into <code>this.props</code>.  We read <code>completed</code> from <code>this.state.completed</code> instead.  There is a copy of it in <code>this.props.completed</code> just as there are for <code>tid</code> or <code>descr</code> but these copies do not reflect possible changes in the state of the component, they will always retain their original values and won't be affected by whatever the user does.</p>
<p>Thus, as a general rule, those properties that the user might change via some interaction with the UI, be it clicking, touching, typing or whatever, must go into <code>this.state</code> in the constructor and read from there.  The ones that don't change over the lifetime of the component, can be accessed from <code>this.props</code>.</p>
<p>How do we change the state of the component?  Via <code>this.setState</code>.  Except in the constructor, where the state is initialized, we must never set <code>this.state</code> or anything within it directly.  We should always do it via <code>this.setState</code>. This function actually merges the values given to the existing ones.  In our case, we only set <code>completed</code> but that doesn't mean we are wiping out <code>descr</code>, we are merging the new value of <code>completed</code> into the object which also contains the value of <code>descr</code>.</p>
<p>When React detects changes in its state, it triggers the re-rendering process. If we now run this version, we will see the task items switch color as we click on them.  However, though we have changed the state of the component, we have not changed the underlying data itself.  That is why we are still firing the <code>onCompletedChange</code> custom event to notify to whomever it might concern, that the change has been requested.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L41-L43"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 41</div>
    <div class="to">To: 43</div>
  </div>
  <pre><code class="language-js">export const TaskList = ({ pid, tasks, onTaskCompletedChange }) =&gt; {
  const onCompletedChangeHandler = ev =&gt; onTaskCompletedChange(Object.assign(ev, { pid }));
  return (&lt;ul className="task-list"&gt;{</code></pre></div>
<p>The <code>TaskList</code> component itself listens to that event and its handler, adds the <code>pid</code> and fires its own <code>onTaskCompletedChange</code> event.   The <code>Project</code> component listens to this event and finally changes the actual data.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L64-L66"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 64</div>
    <div class="to">To: 66</div>
  </div>
  <pre><code class="language-js">const onTaskCompletedChangeHandler = ev =&gt; {
  data[ev.pid].tasks[ev.tid].completed = ev.completed;
};</code></pre></div>
<p>Of course, it only changes the local client-side copy of <code>data.js</code>, not the shared one on the server, which we will do later on. It is easy to tell the changes have been preserved by clicking on some of the tasks to change its completion status, selecting another project and then, when going back to the original one, the changes are still there.</p>
<h3><a class="self-ref" id="chapter13-stateless-or-stateful" href="#chapter13-stateless-or-stateful"># </a>Stateless or Stateful</h3>
<p>Stateless components are to be preferred over stateful because, besides being cheap in resources taken, state machines are harder to test and debug.  Calling a stateless component with the same properties will always produce the same output.  In a stateful component, it all depends on the previous state, thus the chances for bugs increases and so does then need for tests.</p>
<p>However, to let React know when a component has changed and, if so, to trigger a re-render, said component needs to know what its previous state was so it can compare it with the new one.  That is why we had to go to a stateful component, that is, a JavaScript class instead of a plain function.</p>
<p><code>React.Component</code> also provides a whole series of methods for particular needs and what they call <a href="https://facebook.github.io/react/docs/component-specs.html">lifecycle events</a> such as <code>shouldComponentUpdate</code> which allows for a finer control on when the component might need re-rendering.</p>
<h2><a class="self-ref" id="chapter13-putting-some-order-into-our-files" href="#chapter13-putting-some-order-into-our-files"># </a>Putting some order into our files</h2>
<p>Our project has grown a little wild, some components are not where they should.  It is customary that components should be each in its own file, except for stateless components when they are totally subordinate to the main component in the file, like <code>ProjectItem</code> is to <code>ProjectList</code>.</p>
<p>The <code>App</code> and <code>NotFound</code> stateless components which were within <code>router.js</code> now have their own separate files <code>app.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/app.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and <code>notFound.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/notFound.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>The <code>NotFound</code> component now informs which path is the one that has not been found.  It gets this information from the Router which provides the component with plenty of information about how it got there.</p>
<p>The <code>App</code> component is now a true frame providing some real options, well... at the moment, just one, listing the available projects.  At this point we are using a plain <code>&lt;Link&gt;</code> component which renders as an HTML anchor <code>&lt;a&gt;</code>.  In a real project, it might be a menu or a tabbed interface.  What it still has from before is a placeholder for the children it will contain: <code>{props.children}</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/app.js#L7">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  This is important.  Whenever there is a <code>&lt;Route&gt;</code> which contains nested <code>&lt;Route&gt;</code> elements, the parent component should have a <code>{props.children}</code> placeholder to put the contents of the components in the nested routes.  Failing to provide such a placeholder will not issue an error nor warning, the children will simply not be rendered.</p>
<p>Our earlier <code>index.js</code> file is now <code>projectList.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/projectList.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> because it actually contains a component called <code>ProjectList</code> which lists the available projects. Likewise, the component imported as <code>Index</code> in <code>router.js</code> is now <code>ProjectList</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/router.js#L5">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. Early on, <code>index.js</code> was the entry point of our pre-React application and that is why it received the default name for an entry-point. That is no longer the case.</p>
<p>The <code>project.js</code> file contained too many components, even a stateful one, which should have been on its own.  Now it is much smaller containing a simple stateless component <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/project.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> with the <code>TaskList</code> and <code>Task</code> components moved into their own files <code>taskList.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/taskList.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and <code>task.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/task.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>We have also changed the routes:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/router.js#L11-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-03</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">render((
  &lt;Router history={browserHistory}&gt;
    &lt;Route path="/" component={App}&gt;
      &lt;Route path="project" component={ProjectList}&gt;
        &lt;Route path=":pid" component={Project} /&gt;
      &lt;/Route&gt;
      &lt;Route path="*" component={NotFound} /&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), document.getElementById('contents'));</code></pre></div>
<p>We have <code>App</code> as an overall container.  It has the main menu, though at this point it has only one option, listing the projects.  This <code>App</code> menu will show if its own path or any of the subordinated paths are matched.  Since one of those paths is <code>'*'</code> which shows the <code>NotFound</code> component, <code>App</code> will always have a match, even if it is <code>NotFound</code>.  That is why we are no longer using <code>IndexRoute</code>.</p>
<p>If the route is <code>/project</code> or <code>/project/:pid</code>, the <code>ProjectList</code> will show.  Once again, it will show with either its own path <code>/project</code> or upon matching any subordinate route <code>/project/:pid</code>.  Notice how the nested paths get concatenated in the actual URL.</p>
<p>In our earlier version, we either had the projects list or the information about a single project.   In this version we have a hierarchy of information starting at the main menu, followed by the projects list and then, if a project is selected, information about it. The nesting of the routes reflects this.</p>
<h2><a class="self-ref" id="chapter13-conditional-rendering" href="#chapter13-conditional-rendering"># </a>Conditional rendering</h2>
<p>We have something that doesn't look nice.  Once a project is selected and its details shown in the bottom panel, the projects list still shows as a link, even though that project has already been selected.  It would be good to highlight the selected project and drop the link around it.</p>
<p>We can easily do this by using the <code>params</code> property that the Router provides our components.  <code>params.pid</code> will be the actual <code>pid</code> of the selected project or <code>undefined</code> if no project has been selected yet.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-04/client/projectList.js#L21-L36"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-04</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 21</div>
    <div class="to">To: 36</div>
  </div>
  <pre><code class="language-js">const ProjectList = ({ children, params }) =&gt; (
  &lt;div className="project-list"&gt;
    &lt;h1&gt;Projects:&lt;/h1&gt;
    &lt;ul&gt;{
      Object.keys(data).map(pid =&gt;
        (&lt;ProjectItem
          key={pid}
          pid={pid}
          name={data[pid].name}
          active={params.pid === pid}
        /&gt;)
      )
    }&lt;/ul&gt;
    {children}
  &lt;/div&gt;
);</code></pre></div>
<p>We then add an <code>active</code> property to the <code>ProjectItem</code> component.  We set it by comparing the <code>pid</code> parameter in the route to the <code>pid</code> of the project being rendered.  If they are the same, then we are rendering the active project.</p>
<p>We use that extra <code>active</code> property in two conditional expressions within <code>ProjectItem</code>.  One of them adds a <code>className</code> to the list item and the other decides whether to show the plain name for the active project or a link to navigate to it.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-04/client/projectList.js#L5-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-04</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">export const ProjectItem = ({ pid, name, active }) =&gt; (
  &lt;li className={`project-item ${active ? 'selected' : ''}`}&gt;
    {
     active
     ? name
     : (&lt;Link to={`/project/${pid}`}&gt;{name}&lt;/Link&gt;)
   }
  &lt;/li&gt;
);</code></pre></div>
<p>We do something very similar in <code>App</code> since, once we have clicked on our single menu item, there is no point in keeping it as a link <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-04/client/app.js#L4-L13">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>Lets go a little further.  Why don't we add a count of pending tasks along the list of projects?  We will provide an extra numeric <code>pending</code> property to <code>ProjectItem</code> so we can show it along each of the project names. We calculate it in <code>ProjectList</code> like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-05/client/projectList.js#L32-L36"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-05</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 32</div>
    <div class="to">To: 36</div>
  </div>
  <pre><code class="language-js">pending={
  Object.keys(data[pid].tasks).filter(
    tid =&gt; !data[pid].tasks[tid].completed
  ).length
}</code></pre></div>
<p>We use <code>Array.filter</code> over each of the tasks in each project to select those which are not yet completed.  Then, we count how many they ended up being.  It might not a good piece of code but it won't last long.  It is there just to show one issue.</p>
<p>We just show that count for each of the items:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-05/client/projectList.js#L5-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-05</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">export const ProjectItem = ({ pid, name, active, pending }) =&gt; (
  &lt;li className={`project-item ${active ? 'selected' : ''}`}&gt;
    {
     active
     ? name
     : (&lt;Link to={`/project/${pid}`}&gt;{name}&lt;/Link&gt;)
   } [Pending: {pending}]
  &lt;/li&gt;
);</code></pre></div>
<p>As we click on the tasks for a particular project, though the marks on the checkboxes change indicating their completion status, the counts of <em>pendings</em> on the projects list don't change at all.  However, if we click on a different project, then the pending counts suddenly get updated to their correct values.</p>
<p>The problem is that though we are updating the data and we are telling <code>TaskList</code> to re-render itself by changing its state, this does not apply to components higher in the hierarchy.  Clicking on any of the project links re-renders them and then the counts are updated.</p>
<p>This was meant to be a simple example of a deeper issue which we will fix this in the next chapter, namely, that it is difficult to keep in sync different views of the same data.</p>
<h2><a class="self-ref" id="chapter13-lodash" href="#chapter13-lodash"># </a>Lodash</h2>
<p>After seeing all those calls to <code>Object.keys</code>, it is time to wonder if there is anything better.  The problem is that though Arrays have <code>.map</code>, <code>.reduce</code> and <code>.filter</code> methods, Objects don't so it is harder to loop over its items. Fortunately there are libraries of utilities to solve this.  One of the best is <a href="https://lodash.com/">Lodash</a> an improved version of <a href="http://underscorejs.org/">Underscore</a> which was named like that because it was usually named with the underscore <code>_</code> symbol.</p>
<p>To use Lodash, we first need to download the package:</p>
<pre><code class="language-bash">npm i --save lodash
</code></pre>
<p>We may load the whole package like this:</p>
<pre><code class="language-js">const _ = require('lodash');
</code></pre>
<p>The examples shown in the documentation of Lodash assume we've loaded it in this way, which makes all of the dozens of functions available at once.  However, this would make WebPack include the whole library in the bundle. A better option for us is to include only the parts we need:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-06/client/projectList.js#L4-L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-06</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-js">const map = require('lodash/map');
const filter = require('lodash/filter');</code></pre></div>
<p>We can clearly see the benefits of Lodash looking at this same segment in both versions side to side:</p>
<table><tr><th>Before  <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-05/client/projectList.js#L26-L38"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a> </th><th>After <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-06/client/projectList.js#L28-L40"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></th></tr>
<tr><td><pre><code class="lang-js">
Object.keys(data).map(pid =>
   (&lt;ProjectItem
     key={pid}
     pid={pid}
     name={data[pid].name}
     active={params.pid === pid}
     pending={
       Object.keys(data[pid].tasks).filter(
         tid => !data[pid].tasks[tid].completed
       ).length
     }
   /&gt;)
 )
</code></pre></td>
<td><pre><code class="lang-js">
map(data, (prj, pid) =>
  (&lt;ProjectItem
    key={pid}
    pid={pid}
    name={prj.name}
    active={params.pid === pid}
    pending={
      filter(prj.tasks,
        task => !task.completed
      ).length
    }
  /&gt;)
)</code></pre></td></tr></table>
<p>It is worth noting that <a href="https://lodash.com/docs#map"><code>map</code></a> and <a href="https://lodash.com/docs#filter"><code>filter</code></a> work indistinctly in both Array and Objects or, as they are called in Lodash, <em>Collections</em>.</p>
</div>
  </body>
  <script type="text/javascript" src="index.js"></script>
</html>
