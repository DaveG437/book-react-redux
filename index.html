<!DOCTYPE html>
<html>
  <head>
    <title>An annotated single page app using React and Redux</title>
    <link rel="stylesheet" href="ddscrollspydemo.css" />
    <link rel="stylesheet" href="github.min.css">
    <link rel="stylesheet" href="index.css">
    <script type="text/javascript" src="jquery.min.js"></script>
    <script type="text/javascript" src="ddscrollspy.js"></script>
    <script src="highlight.min.js"></script>
  </head>
  <body>
    <div class="toc"><ul class="level-h0"><ul class="level-h1"><li><a href="#preface-the-application">The Application</a></li>
<li><a href="#preface-resources">Resources</a></li>
</ul>
<li><a href="#softwareused-software-used">Software used</a></li>
<li><a href="#folders-what-is-where">What is where</a></li>
<ul class="level-h1"><li><a href="#folders-the-client-folder">The client folder</a></li>
<ul class="level-h2"><li><a href="#folders-clientcomponents">client/components</a></li>
<li><a href="#folders-clientstore">client/store</a></li>
<li><a href="#folders-clientutils">client/utils</a></li>
</ul>
<li><a href="#folders-the-electron-folder">The electron folder</a></li>
<li><a href="#folders-the-scripts-folder">The scripts folder</a></li>
<li><a href="#folders-the-server-folder">The server folder</a></li>
<li><a href="#folders-the-test-folder">The test folder</a></li>
<li><a href="#folders-the-webpackconfig-folder">The webpack.config folder.</a></li>
<li><a href="#folders-other-local-folders">Other local folders</a></li>
</ul>
<li><a href="#installation-installation">Installation</a></li>
<ul class="level-h1"><li><a href="#installation-available-commands">Available commands</a></li>
</ul>
<li><a href="#conventions-conventions">Conventions</a></li>
<ul class="level-h1"><li><a href="#conventions-octocats">OctoCats</a></li>
<li><a href="#conventions-predefined-constants">Predefined Constants</a></li>
<li><a href="#conventions-virtual-import-paths">Virtual import paths</a></li>
<li><a href="#conventions-omitting-extensions">Omitting extensions</a></li>
<li><a href="#conventions-promises">Promises</a></li>
</ul>
<li><a href="#server-the-web-server-code">The Web Server code</a></li>
<ul class="level-h1"><li><a href="#server-isomorphism">Isomorphism</a></li>
<li><a href="#server-start-and-stop">Start and Stop</a></li>
<li><a href="#server-starting">Starting</a></li>
<ul class="level-h2"><li><a href="#server-data-handlers">Data handlers</a></li>
<li><a href="#server-start-listening">Start listening</a></li>
</ul>
<li><a href="#server-stopping">Stopping</a></li>
<li><a href="#server-the-cli">The CLI</a></li>
</ul>
<li><a href="#serverprojectshandler-server-side-projects-data-handler">Server-side Projects Data Handler</a></li>
<ul class="level-h1"><li><a href="#serverprojectshandler-initialization">Initialization</a></li>
<li><a href="#serverprojectshandler-validators">Validators</a></li>
<li><a href="#serverprojectshandler-transactions">Transactions</a></li>
</ul>
<li><a href="#components-react-components">React Components</a></li>
<ul class="level-h1"><li><a href="#components-stateless-components">Stateless Components</a></li>
<li><a href="#components-connected-stateless-component">Connected Stateless Component</a></li>
<li><a href="#components-react-redux">React-Redux</a></li>
<li><a href="#components-router-hoc">Router HoC</a></li>
</ul></li></ul></div>
    <div class="contents unfolded">
      <div class="close">&lt; close</div>
      <h1 class="title">An annotated single page app using React and Redux</h1>
      <section id="preface"><div class="notice">This is the new, still unfinished version of the book. The previous version, also unfinished but far more complete is also available <a href="old.html">here</a>.  See the <a href="https://github.com/Satyam/book-react-redux/blob/master/README.md">README</a> file in the GitHub repository for further information.</div>
# Introduction
<p>The purpose of this book is to show how to create an isomorphic single-page-application (SPA) using React and Redux. It contains both client and server-side code to show how the client can interact with the server by using the <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST API</a>.</p>
<h2><a class="self-ref" id="preface-the-application" href="#preface-the-application"># </a>The Application</h2>
<p>It is isomorphic, meaning that on the initial load, the server can generate and provide the client with a static image of the request page with the corresponding data, which notably reduces the time a slow device, such as a tablet or smart phone, would normally require to produce the initial page.</p>
<p>It can also run on a desktop using <a href="http://electron.atom.io/">Electron</a> though no attempt has been done to exploit the desktop environment, for example, by moving the main menu from the page itself to the desktop application menu.</p>
<p>It is quite small, just what is required to show the main techniques described. It is, however, extensible and many other features could easily be added.  Likewise, testing is scarce, just enough to show how to test the different elements in it. Though the code does work (and please let us know if it does not) the code is meant as a working sample to support this book, not to solve any real-life problem.</p>
<p>Unlike the many application boilerplates available <a href="https://github.com/facebook/react/wiki/Complementary-Tools#full-stack-starter-kits">(see)</a> the intention is to fully explain what the code does so instead of a recipe to follow, this book is meant as a guide on how to build an app.</p>
<h2><a class="self-ref" id="preface-resources" href="#preface-resources"># </a>Resources</h2>
<p>The book and the code are available in <a href="https://github.com/Satyam/book-react-redux">GitHub</a>.</p>
<p>Any issues with this book or the code can be reported via the projects' <a href="https://github.com/Satyam/book-react-redux/issues">issues</a> section.</p>
</section><section id="softwareUsed"><h1><a class="self-ref" id="softwareused-software-used" href="#softwareused-software-used"># </a>Software used</h1>
<p>Our sample application will use JavaScript extensively both for the client and the server.  We used JavaScript even for auxiliary scripts, no Bash shell or Python, all plain JavaScript.</p>
<p>On the client side, our application will use React along several related packages such as React-Router and Redux for data manipulation.  We will use <a href="https://www.npmjs.com/package/axios">Axios</a> for HTTP communication, but its usage is concentrated on just a couple of files so it should be easy to swap it out for some other communication package.</p>
<p>We are using Twitter's <a href="http://getbootstrap.com/">Bootstrap</a> for its CSS styles, fonts and icons, though we are not using any of its active components.  We haven't used any active components from any library because that simply requires following the recipe for whichever library and doesn't need much explaining.  We have made all of our components so as to learn how to do them.</p>
<p>On the server side we are using <a href="http://expressjs.com/">Express</a>, possibly the most popular web server framework for Node.js. There are several other similar packages available, but this book is not about what's on the server but on the client, thus, we've made a conservative choice in this area.  Express is well-known and even those who might prefer other web servers will have dabbled with Express at some point so it will be somewhat familiar.  Since our application will be isomorphic, being able to run JavaScript in the server is a must.</p>
<p>We have used the most basic SQL database manager we could find, <a href="https://www.npmjs.com/package/sql.js">SQL.js</a> a pure JavaScript version of <a href="www.sqlite.org">SQLite</a>. The concepts explained in this book are not tied to whatever data storage might be in the background so we didn't try to use anything more sophisticated. We are not advocating for any particular data storage solution and certainly not SQL.js which is quite primitive and terribly slow in a production environment, but it is very simple to install by just doing an NPM install with no need for any further setup or configuration.  For the purpose of this book it takes a lot of administrative trivia out of the way and does not polute the reader's machine.</p>
<p>Incidentally, we are not installing anything globally, except for Node.js and a browser, both of which we would expect are already there. We are not using the <code>-g</code> option of the <code>npm install</code> command.  Once done with the sample code, uninstalling it is just a matter of removing the installation folder.</p>
<p>We are using EcmaScript-2015 or ES6 syntax for most of the code and Babel to transpile it to ES5.  We are not using ES6 for code that is not transpiled, such as ancillary scripts and the WebPack configuration files, except for some ES6 features already available in Node.js 4.4.7, the current recommended stable version.</p>
<p>We are using <a href="http://webpack.github.io/">WebPack</a> to pack our modules into bundles that a browser can load. However, since we are using ES6 syntax not yet supported by Node.js and a few other WebPack features that turn out to be quite handy, we are using WebPack to create server-side bundles as well. This is partly due to implementing isomorphism, which requires the server to be able to run the very same code that the client does so as to create the static image that the browser will download.  So, it is easier if both sides use exactly the same environment.</p>
<p>Finally, we are using the <a href="http://eslint.org/">ESLint</a> linter with the <a href="https://www.npmjs.com/package/eslint-config-airbnb">Airbnb</a> rules set and <a href="https://mochajs.org/">Mocha</a> with <code>expect</code> assertions from <a href="http://chaijs.com/api/bdd/">Chai</a> for testing.</p>
<p>There are plenty of other modules used here and there, but these are the main dependencies that most influence the code.</p>
<p>Something sorely lacking in this app are API docs. Unfortunately, none of the tools reviewed work as could be desired.  Most are confused by either the JSX syntax used by React or don't support ES6 syntax or have no means to describe modules or document their exports.  In the end, the resulting docs were of very little help so no effort was put into adding doc-comments to the code.</p>
</section><section id="folders"><h1><a class="self-ref" id="folders-what-is-where" href="#folders-what-is-where"># </a>What is where</h1>
<p>The application <a href="https://github.com/Satyam/book-react-redux">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> contains six main folders plus those for the book itself (manuscript).</p>
<h2><a class="self-ref" id="folders-the-client-folder" href="#folders-the-client-folder"># </a>The client folder</h2>
<p>The <code>client</code> folder <a href="https://github.com/Satyam/book-react-redux/tree/master/client">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> contains all the files that will eventually get loaded in the client.</p>
<p>The <code>index.jsx</code> file sets up the React / Redux / routing environment.  The <code>.eslintrc.json</code> file ensures the proper linting rules are used for the client-side environment.</p>
<p>Within it there are three further folders</p>
<h3><a class="self-ref" id="folders-clientcomponents" href="#folders-clientcomponents"># </a>client/components</h3>
<p>It contains the React components  <a href="https://github.com/Satyam/book-react-redux/tree/master/client/components">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. It has a couple of common files for the whole application, <code>app.jsx</code> contains the overall frame that will enclose the app and <code>notFound.jsx</code> the simple component that will show up if an erroneous, perhaps obsolete URL is provided.</p>
<p>We then have further folders for each of the main sections of the app.  In this example we have just one such section, <code>client/components/projects</code> but there might well be any number of them.</p>
<p>Each section usually contains a <code>routes.jsx</code> file that states how each component is activated depending on the path in the URL. We'll see its contents later on.</p>
<h3><a class="self-ref" id="folders-clientstore" href="#folders-clientstore"># </a>client/store</h3>
<p>It contains the Redux components <a href="https://github.com/Satyam/book-react-redux/tree/master/client/store">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>The <code>createStore.js</code> file composes the various sub-stores into a single Redux store.  The <code>actions.js</code> consolidates all the action and action creators (more on them later) in a single include file.</p>
<p>The actual stores are each in a folder underneath. For simple stores, such as <code>misc</code> <a href="https://github.com/Satyam/book-react-redux/tree/master/client/store/misc">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> it is all contained in a single <code>index.js</code> file.  For more elaborate ones such as <code>projects</code> <a href="https://github.com/Satyam/book-react-redux/tree/master/client/store/projects">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> the various parts of the store are split into various files.</p>
<h3><a class="self-ref" id="folders-clientutils" href="#folders-clientutils"># </a>client/utils</h3>
<p>It contains various utility modules for both the React components and the Redux stores.  Alternatively, a <code>utils</code> folder might be created in each of <code>components</code> and <code>store</code>, however, some utility functions such as <code>initialDispatcher.js</code> help connect both components and store so, considering that in this example we don't have that many utility modules, we've piled them up here.</p>
<h2><a class="self-ref" id="folders-the-electron-folder" href="#folders-the-electron-folder"># </a>The electron folder</h2>
<p>Turning our client/server application into a Electron desktop application isn't hard, the proof being that we've done it with just three files <a href="https://github.com/Satyam/book-react-redux/tree/master/electron">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Admittedly, we haven't used any desktop-specific features such as the application menu, but doing so wouldn't be that big of an issue.</p>
<h2><a class="self-ref" id="folders-the-scripts-folder" href="#folders-the-scripts-folder"># </a>The scripts folder</h2>
<p>Most commands to compile, run or lint are simple enough to be contained within the <code>package.json</code> <code>scripts</code> entry so they can be run via the <code>npm run</code> command.  A few might require some extra help.  This folder might contain bash scripts or, in this case, plain JavaScript files for Node.js.</p>
<h2><a class="self-ref" id="folders-the-server-folder" href="#folders-the-server-folder"># </a>The server folder</h2>
<p>We will start looking at the server-side code in the very next chapter so we won't comment on the files in this folder right now.  As for the folders, there is an <code>isomorphic</code> folder that turns the regular client/server app into an isomorphic one.  Delete this folder and two lines in <code>server.js</code> and the application is no longer isomorphic.</p>
<p>The <code>projects</code> folder contains the server-side code to provide the data to the client-side store contained in a folder of the same name. Some of the stores on the client side do not require any server-side support, but those that do would have a folder for them.</p>
<h2><a class="self-ref" id="folders-the-test-folder" href="#folders-the-test-folder"># </a>The test folder</h2>
<p>It contains the scripts to test the code in each of the previous sections. Being so, it mimics the folder structure of them, there is a <code>client</code> folder containing a <code>components</code> and a <code>store</code> folder each containing further folders and files to test each element.</p>
<p>The <code>functional</code> folder contains a couple of functional tests.  Unlike the unit tests in the previous folders, which exercise each element independently of one another, this folder contains a couple of functional tests that test the overall functionality of a complete group of elements, in this case, the web server and the REST API manipulating the data for the <code>projects</code> store.</p>
<p>The tests are not complete.  We have done a few tests just to show how they can be written and which tools to use, but there is not one test for each and every element in the app.</p>
<p>The <code>utils</code> folder contains several handy modules to help in testing.</p>
<h2><a class="self-ref" id="folders-the-webpackconfig-folder" href="#folders-the-webpackconfig-folder"># </a>The webpack.config folder.</h2>
<p>Since we use WebPack to package all the bits and pieces of our app and we need several configuration files for the various environments, we placed them all in a single folder.  Thus we have one for development, one for production and one for testing.  They all share the <code>common.js</code> configuration.</p>
<h2><a class="self-ref" id="folders-other-local-folders" href="#folders-other-local-folders"># </a>Other local folders</h2>
<p>Once downloaded or cloned, the various scripts will create other folders which are not stored in GitHub because they are produced by the various scripts and contain no source material.</p>
<p>The <code>bundles</code> folder will contain the packages created by WebPack, transpiled by Babel and, for the production version, minified, except the one destined for the client which will be located in a publicly accessible folder.</p>
<p>The <code>coverage</code> folder will be created when the <code>npm run coverage</code> command is issued.  It is produced by <a href="https://www.npmjs.com/package/istanbul">istanbul</a> and we will look into it later.</p>
<p>The <code>public</code> folder contains whatever files might be sent to the client.  This is the virtual root for any URL received from the client. Background images, icons, static pages might be contained in it.  We have none of those but we do have a <code>public/bundles</code> folder that contains the packaged bundle destined for the client.</p>
<p>The <code>tmp</code> folder will be created by the script that executes the tests. It is deleted and rebuild every time the tests are run.  It might as well be deleted after the tests are successful but sometimes the web-packed files provide clues to some errors so it is best to leave them behind.</p>
<p>Finally, the <code>node_modules</code> folder contains all sorts of NPM modules as listed in <code>package.json</code>.</p>
</section><section id="installation"><h1><a class="self-ref" id="installation-installation" href="#installation-installation"># </a>Installation</h1>
<p>The easiest way to get the code running in your machine is to <a href="https://github.com/Satyam/book-react-redux/archive/master.zip">download</a> the ZIP file of the project from GitHub <a href="https://github.com/Satyam/book-react-redux">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>For those wanting to play with it and keep a copy of their changes in GitHub, making a fork and then cloning it locally might be a better option.  If you know what the previous sentence meant, you probably know how to do it.</p>
<p>The application only needs Node.js installed, which also installs NPM.</p>
<p>Once expanded into any folder of your choice, move to that folder and do a 'npm install' which will read all the dependencies from <code>package.json</code> and install them. This will take a while. There are no global dependencies in the project so the installation should not mess up with any folders outside of the project, except for the cache NPM maintains of the modules it downloads. The command <code>npm cache clean</code> flushes it but otherwise, NPM takes care of it.</p>
<h2><a class="self-ref" id="installation-available-commands" href="#installation-available-commands"># </a>Available commands</h2>
<p>Once in the root folder of the project, the following commands are available.</p>
<ul>
<li><code>npm run build</code> Creates the developer versions of the bundles that can be executed.  This is the first command to run since very little of the code can be executed as-is.</li>
<li><code>npm run production</code> Creates the production versions of the same files.  The extra code used for internal checking within React is dropped and everything is minified.</li>
<li><code>npm run watch</code> Same as <code>npm run build</code> but WebPack remains loaded in the background and whenever any of the source files changes, the corresponding bundles will be re-created.</li>
<li><code>npm start</code> Starts the web server. A browser can then access the application by going to the URL that is shown in the console. Requires the application to be built.</li>
<li><code>npm run debug</code> Runs the web server in debug mode.  This command <strong>does require</strong> the <a href="https://github.com/node-inspector/node-inspector">node-inspector</a> package to be installed globally and works with Chrome and Opera only.</li>
<li><code>npm run lint</code> Runs ESLint on all the source code.</li>
<li><code>npm t</code> Runs tests on the code.</li>
<li><code>npm run coverage</code> Runs the tests with code coverage via Istanbul.</li>
<li><code>npm run electron</code> Runs the Electron desktop version of this application.  Requires the application to be built.</li>
<li><code>npm run updateModules</code> Updates NPM modules to their latest versions.</li>
</ul>
</section><section id="conventions"><h1><a class="self-ref" id="conventions-conventions" href="#conventions-conventions"># </a>Conventions</h1>
<h2><a class="self-ref" id="conventions-octocats" href="#conventions-octocats"># </a>OctoCats</h2>
<p>Within the book we will use the <em>OctoCat</em> icon <a href="https://github.com/Satyam/book-react-redux">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> to refer to code located in GitHub.  The OctoCat is GitHub's mascot. It usually points to large stretches of code that aren't worth including along the text, but that can be looked at, if so desired.</p>
<p>Most of the code boxes within this book (the ones with a thick silver frame) are extracted automatically from GitHub and the original can be reached by clicking on the OctoCat icon in the frame. For example:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/notFound.jsx#L3-L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/notFound.jsx</div>
    <div class="from">From: 3</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-jsx">const NotFound = props =&gt; (
  &lt;div&gt;
    &lt;h1&gt;Not found&lt;/h1&gt;
    &lt;p&gt;Path: &lt;code&gt;{props.location.pathname}&lt;/code&gt;&lt;/p&gt;
  &lt;/div&gt;
);</code></pre></div>
<h2><a class="self-ref" id="conventions-predefined-constants" href="#conventions-predefined-constants"># </a>Predefined Constants</h2>
<p>The code contains constant literals written in upper case characters, for example, <code>REST_API_PATH</code>. These are replaced by actual values during bundling, thus, <code>REST_API_PATH</code> will show as <code>(&quot;/data/v2&quot;)</code> in the packaged bundles.</p>
<h2><a class="self-ref" id="conventions-virtual-import-paths" href="#conventions-virtual-import-paths"># </a>Virtual import paths</h2>
<p>The path to some of the imported modules start with an underscore, for example, <code>import routes from '_components/routes';</code>.  These are virtual paths that WebPack will resolve to actual locations based on the aliases set in the configuration file <a href="https://github.com/Satyam/book-react-redux/blob/master/webpack.config/common.js#L16-L22">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Since an actual NPM module name cannot start with an underscore, there is no risk of name collision.  These virtual routes allow us to avoid relative references to modules starting with double dot <code>from '../../etc'</code> which are hard to follow or maintain should files be moved relative to one another.  With full paths starting from these virtual roots, any reference to a moved file can be easily located and replaced.</p>
<h2><a class="self-ref" id="conventions-omitting-extensions" href="#conventions-omitting-extensions"># </a>Omitting extensions</h2>
<p>We omit the <code>.js</code> or <code>.jsx</code> extensions on references to imported files.  This serves several purposes.  The importer should not care whether the file does contain JSX code or not.  Should the contents of the file change to include some JSX syntax and, following convention, the file extension changed to <code>.jsx</code>, the files that import it don't need to be changed. Also, if the source file gets too large and it needs to be broken up, it can easily be done without affecting the files that import it.  For example, if the file <code>whatever.js</code> which we import with <code>import whatever from './whatever'</code> needs to be split into various files, we can move <code>whatever.js</code> to a new folder as <code>whatever/index.js</code> and all the imports will still work.  Then, the <code>whatever/index.js</code> file can be broken into several files, all within that folder, without polluting the parent folder, as long as the exports remain within <code>index.js</code> or are re-exported from it.</p>
<h2><a class="self-ref" id="conventions-promises" href="#conventions-promises"># </a>Promises</h2>
<p>We use Promises extensively, to the point of converting some Node.js library functions from using the callback convention into a Promise. We have mostly used <a href="https://www.npmjs.com/package/denodeify">denodeify</a> to do that so that this code:</p>
<pre><code class="language-js">import fs from 'fs';

fs.readFile('./foo.txt', 'utf8', (err, data) =&gt; {
  if (err) throw err;
  // do something with data
})
</code></pre>
<p>Turns into this:</p>
<pre><code class="language-js">import fs from 'fs';
import denodeify from 'denodeify';

const readFile = denodeify(fs.readFile);

readFile('./foo.txt', 'utf8')
.then(data =&gt; {
  // do something with data
});
</code></pre>
<p>The latter seems a more expensive proposition but it must be considered that when several asynchronous operations are chained together, it is very easy to fall into the depths of indentation hell, with each successive operation called within the callback of the previous one while with Promises all the chain is nicely aligned and clearly visible, which helps with future maintenance.  It also allows for several operations to be launched at once via <code>Promise.all</code>.</p>
</section><section id="server"><h1><a class="self-ref" id="server-the-web-server-code" href="#server-the-web-server-code"># </a>The Web Server code</h1>
<p>We start by following the standard recipe to create an instance of an Express web server using Node.js native HTTP server:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L15-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">const app = express();
const server = http.createServer(app);</code></pre></div>
<p>We used <code>app</code> as a variable name simply because it is customary to do so.  All Express documentation uses <code>app</code> for the express server instance, <code>req</code> for the incoming requests and <code>res</code> for the responses to it.  Trying to be original might lead to confusion so it is best to stick with what is common practice.</p>
<p>We convert the server functions we will use into Promises by <em>denodeifying</em> them:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L18-L19"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 19</div>
  </div>
  <pre><code class="language-js">const listen = denodeify(server.listen.bind(server));
const close = denodeify(server.close.bind(server));</code></pre></div>
<p>Using <code>denodeify</code> with functions, as we did with <code>fs.readFile</code> <a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L13">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> is straightforward.  When using it on method of an object instance, we have to denodeify the function reference bound to that instance, so the method has a valid <code>this</code> when invoked.</p>
<p>The same server will both provide regular HTML, style sheets, images, icons or whatever clients request but it will also manipulate data via a REST API.  In a large installation, handling data might be delegated to other set of servers, while a further set of servers might actually run the database management system.  We are doing it all from the same server.  We are, though, creating a separate router to handle the REST API requests:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L21-L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 21</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-js">const dataRouter = createRouter();
app.use(REST_API_PATH, bodyParser.json(), dataRouter);</code></pre></div>
<p>On importing Express <a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L3">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> we renamed <code>express.Router</code> as <code>createRouter</code> which, when called, returns a new router.  <code>dataRouter</code> will handle all the routes that start with the <code>REST_API_PATH</code> path which is a constant that via some WebPack magic which we'll see later, comes from <code>package.json</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/package.json#L18-L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 18</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-json">"myWebServer": {
  "port": 8080,
  "host": "http://localhost",
  "restAPIpath": "/data/v2"
},</code></pre></div>
<p>We will use those other <code>host</code> and <code>port</code> constants elsewhere as <code>HOST</code> and <code>PORT</code>. We usually try to respect the customary naming conventions for each type of file, that is why we use <code>host</code> in the <code>package.json</code> file and <code>HOST</code> in the JavaScript code, but that is a matter of preference.</p>
<p>Thus <code>dataRouter</code> handles the paths starting with <code>/data/v2</code>.  Since the data will be expected to be in JSON format but it comes as a serialized string of data, before letting it reach <code>dataRouter</code>, we pass it through <code>bodyParser.json()</code>.</p>
<blockquote>
<p>It is somewhat obvious why the <code>/data</code> part of the route, after all it is meant to manipulate simple data.  It might not be so obvious why the <code>/v2</code>.  Over time, the API may change in incompatible ways, however, during the transition time, both versions will be required to coexist.  We could actually have a <code>dataRouterV2</code> and an older <code>dataRouterV1</code> running from the same server responding to different APIs.  We control what is running on the server, but we cannot fully control what is installed or cached in the client system so it is always a good idea to tag the API with, at least, the major version number.</p>
</blockquote>
<p>Another piece of middleware we might also chain before anything reaches <code>dataRouter</code> is one to check the user authorization to request the execution of such operation. User authentication is quite a complex issue. It is easy to log-in and out and check whether a user is logged in.  However, the permissions each user is granted tells what each can see so it affects the whole user interface which would distract us from the current goal of this book.</p>
<p>Express checks the paths of the URLs requested against the routes in the order in which they are set in the configuration via <code>app.use</code>, <code>app.get</code> or any of the other <code>app.</code><em>method</em> methods.  That is why the routes that branch off the <em>natural</em> path go before the <em>catch-all</em> ones, the exceptions before the generic ones.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L24-L25"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 24</div>
    <div class="to">To: 25</div>
  </div>
  <pre><code class="language-js">app.use('/bootstrap', express.static(absPath('node_modules/bootstrap/dist')));
app.use(express.static(absPath('public')));</code></pre></div>
<p>The <code>express.static</code> handler checks the file system for requested resources.  Combined with Express routing it also helps to translate public, external paths to local paths.  In this case, we translate any path starting with <code>/bootstrap</code> to <code>node_modules/bootstrap/dist</code> relative to the application path.  The <code>absPath</code> function, defined elsewhere <a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L12">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, uses <code>path.join</code> to assemble a full path from the app root and the given relative path.  Bootstrap is installed in our server since it is listed as a dependency in <code>package.json</code> <a href="https://github.com/Satyam/book-react-redux/blob/master/package.json#L41">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Translating the path here saves us from moving over the files to another public location in the server. It is handy for this book and it also shows a nice feature of Express, however, it might not be efficient in actual production.</p>
<p>Using <code>express.static</code> with no route, basically means <em>&quot;for everything else, check here2</em>, in this case, the <code>/public</code> folder in our setup.  Thus, for any route not starting with either <code>/data</code> or <code>/bootstrap</code> it will try looking for a file in <code>/public</code>, which includes <code>/public/bundles</code> where the code and CSS files for this application reside.</p>
<p>This catch-all route would seem the end of the road for our routes. However, if the file is not found in <code>/public</code> then the <code>express.static</code> will not send a <code>404 Not found</code> error, instead, it will signal the router to keep looking for further paths, only when no further routes are available the router will send the 404 error.</p>
<h2><a class="self-ref" id="server-isomorphism" href="#server-isomorphism"># </a>Isomorphism</h2>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L27"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 27</div>
    <div class="to">To: 27</div>
  </div>
  <pre><code class="language-js">app.use(isomorphic);</code></pre></div>
<p>This line sets up isomorphism on the server side.  The <code>isomorphic</code> <em>middleware</em> is imported <a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L8">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> from our own code. In Express parlance, <em>middleware</em> is code that stands in the middle of the process of handling a request.  Both <code>bodyParser</code> and <code>express.static</code> are middleware, they do their thing, parsing JSON or trying to deliver the contents of a file, and then let Express carry on with the request or, depending on the middleware, handle it by themselves.  <code>body.parser</code> always lets requests pass through, <code>express.static</code>, on the other hand, if it finds the file requested, it responds to the request by itself.</p>
<p>Our isomorphic middleware, which we will look at in a later chapter, does something similar.  It checks whether the path matches any of the routes it is configured to handle and, if so, it deals with the request by itself, otherwise, it lets it pass through.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L29"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 29</div>
    <div class="to">To: 29</div>
  </div>
  <pre><code class="language-js">app.get('*', (req, res) =&gt; res.sendFile(absPath('server/index.html')));</code></pre></div>
<p>When it does pass through, it falls into the line above. For any <code>GET</code> request that might remain, the server will send the default <code>index.html</code> <a href="https://github.com/Satyam/book-react-redux/blob/master/server/index.html">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>It is easy to see the difference in using isomorphism or not.  By simply deleting or commenting out the line about using the <code>isomorphic</code> middleware, (and rebuilding the app), the application will still work. From the user point of view, though, the browser will flash.  The screen will be initially blank, then once the client code executes, it will render a blank page while the data for the initial page is requested. Finally, when the data does arrive, the page will be re-rendered with the data.  Since we are using <code>sql.js</code> for our database server, which is quite slow, the delay is noticeable, specially in the first load before anything gets cached.  If we open the developer tools in the Network tab we can see that without isomorphism we have an extra request, the one for the data.</p>
<p>With isomorphism active, a copy of the page with all its data is sent as static HTML.  There is no flash at all. The page is rendered even before the code starts executing.  When the code does execute and React is about to render it, it checks the static image that was sent from the server and, if it matches what it would render, it just lets that page be. Actually, the server sends a checksum made from the generated content as a data attribute in the static page. React just needs to check this checksum against the one it would generate itself.</p>
<p>Though the application, as set up, works with the isomorphic middleware dropped, the client-side code will issue a warning and the tests will also produce an error because it expects isomorphism.  Fully dropping isomorphism does require a few changes elsewhere.</p>
<h2><a class="self-ref" id="server-start-and-stop" href="#server-start-and-stop"># </a>Start and Stop</h2>
<p>This server module does not start on its own,  instead it exports <code>start</code> <a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L31-L40">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and <code>stop</code> <a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L41-L44">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> functions.  The reason for this is that other code might want to control it so we don't want to just let it start on its own.  One such code is the test suite.  The tests cannot see the <code>Server running at ....</code> message.  It has to be able to start the server and know when it is ready to be tested.  That is also why both exported functions return Promises.</p>
<h2><a class="self-ref" id="server-starting" href="#server-starting"># </a>Starting</h2>
<p>The <code>start</code> function sets up the database server:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L31-L34"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 31</div>
    <div class="to">To: 34</div>
  </div>
  <pre><code class="language-js">export function start() {
  global.db = new sqlJS.Database();
  return readFile(absPath('server/data.sql'), 'utf8')
  .then(data =&gt; db.exec(data))</code></pre></div>
<p>We are using SQL.js, which is not recommended for a production setting, so the code presented here should not be used in such environment.</p>
<p>First we create an instance of an empty, memory based database.  We assign this database instance to <code>global.db</code> so that it is accessible as <code>db</code> anywhere else in the whole application.  To prevent ESLint complaining about our use of this <code>db</code> global variable, we have set its configuration file to accept it as a global, along the other WebPack generated constant literals <a href="https://github.com/Satyam/book-react-redux/blob/master/.eslintrc.json#L15-L22">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>We have an empty database right now so we read the  SQL statements <a href="https://github.com/Satyam/book-react-redux/blob/master/server/data.sql">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> that will create the tables and fill them with data and then execute the whole set of statements at once.</p>
<p>Connecting to an actual production-grade database engine will usually be an asynchronous operation.  If the selected database driver does not already return a Promise, it will have some means to signal its readiness.  For example, when connecting with the <a href="https://www.npmjs.com/package/mysql#establishing-connections">MySqL driver</a> we might use <code>denodeify</code> to turn it into a Promise:</p>
<pre><code class="language-js">var mysql      = require('mysql');
global.connection = mysql.createConnection({
  host     : 'example.org',
  user     : 'bob',
  password : 'secret'
});

const connect = denodeify(connection.connect.bind(connection));
const disconnect = denodeify(connection.end.bind(connection));

// later on, in start
connect().then( /* .... */ );
// and in stop
disconnect().then( /* .... */ );
</code></pre>
<h3><a class="self-ref" id="server-data-handlers" href="#server-data-handlers"># </a>Data handlers</h3>
<p>An application server might have to handle different sets of data for various parts of the client application. We will call them data handlers.  We only have one such data handler, <code>projects</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-js">import projects from './projects';</code></pre></div>
<p>Don't bother looking for a <code>server/projects.js</code> file.  We have pretended our sample data handler to be more complex than it actually is so we broke it into several source files and placed them under the <code>server/projects</code> folder <a href="https://github.com/Satyam/book-react-redux/tree/master/server/projects">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and, within it, we have an <code>index.js</code> which is what actually gets imported.</p>
<p>Once the database connection is established and before we allow the web server to start accepting requests, we initialize each of those data set handlers. We will assume that such initialization might be asynchronous and that each will be independent of any other thus we use <code>Promise.all</code> to start them all at once. The chain of promises will only continue when all of them succeed or any of them fails.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L35-L37"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 35</div>
    <div class="to">To: 37</div>
  </div>
  <pre><code class="language-js">.then(() =&gt; Promise.all([
  projects().then(router =&gt; dataRouter.use('/projects', router)),
]))</code></pre></div>
<p>In our simple example application, we only have one set of data for a projects/tasks application.  In a real-life app, the argument to <code>Promise.all</code> would contain a larger array of initializers.</p>
<p>Each data handler will resolve to an Express router instance. In the <code>then</code> part, we tell <code>dataRouter</code> to use that router instance when the path starts with <code>/projects</code>.  <code>dataRouter</code> itself is called on routes starting with <code>/data/v2</code> so our <code>projects</code> data handler will respond to <code>/data/v2/projects</code>. All requests received by <code>dataRouter</code> have already passed through the JSON <code>bodyParser</code>.</p>
<h3><a class="self-ref" id="server-start-listening" href="#server-start-listening"># </a>Start listening</h3>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L38"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 38</div>
    <div class="to">To: 38</div>
  </div>
  <pre><code class="language-js">.then(() =&gt; listen(PORT));</code></pre></div>
<p>To finish up our initialization, we finally set the server to <code>listen</code> for requests, using our <em>denodeified</em> version of <code>server.listen</code>.</p>
<blockquote>
<p>Promises and fat arrows go well with one another.  If the body of a fat arrow function is a simple expression, not a code block, its value will be returned. Using fat arrow functions in the <code>then</code> parts of a Promise produces terse code. If the body of a fat arrow function is a Promise, it will return it, leaving the enclosing Promise in a <em>pending</em> state.  If it is a value, it will <em>fulfill</em> it with that value.</p>
</blockquote>
<h2><a class="self-ref" id="server-stopping" href="#server-stopping"># </a>Stopping</h2>
<p>Stopping the web server is trivial in our case since the database is an in-memory one, and we have no other resources to disconnect from. Should there be any, such as the MySQL example above, this is the place to do it.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L40-L42"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/server.js</div>
    <div class="from">From: 40</div>
    <div class="to">To: 42</div>
  </div>
  <pre><code class="language-js">export function stop() {
  return close();
}</code></pre></div>
<p>As it is, we simply close the connection using the denodeified version of <code>server.close</code>.  We might have simply exported the <code>close</code> function, but in a real app, there will be more things to attend to when closing so we opted to make the <code>stop</code> function a placeholder for them, though right now it holds just one simple function call.</p>
<h2><a class="self-ref" id="server-the-cli" href="#server-the-cli"># </a>The CLI</h2>
<p>To actually start and stop the server from the command line, we have <code>index.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import { start, stop } from './server';

start()
.then(() =&gt; console.log(`Server running at http://localhost:${PORT}/`))
.catch(err =&gt; {
  console.error(err);
  process.exit(1);
});

const shutdown = () =&gt; stop()
  .then(() =&gt; console.log(`Server at  http://localhost:${PORT}/ closed`))
  .then(process.exit);

process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);</code></pre></div>
<p>The server is started by calling the <code>start</code> method imported from <code>server.js</code>, then we show a message to the operator and make sure to catch any errors in the startup.  The code in <code>server.js</code> had no error-catching because what we do with an error varies in between one environment and another so it is best left to the calling module.</p>
<p>The <code>shutdown</code> function calls the <code>stop</code> method, shows a message and finally exits.  It is called from listeners for the OS signals for program termination. This ensures everything gets cleaned up, connections to database managers and whatever other resource we might be using.</p>
</section><section id="serverProjectsHandler"><h1><a class="self-ref" id="serverprojectshandler-server-side-projects-data-handler" href="#serverprojectshandler-server-side-projects-data-handler"># </a>Server-side Projects Data Handler</h1>
<p>Our <code>projects</code> data handler is broken into three files:</p>
<ul>
<li><code>index.js</code> contains the initialization code and returns a Promise resolved with an Express router.</li>
<li><code>transactions.js</code> contains the database operations that do the actual manipulation of the data in whichever DBMS system the system uses.</li>
<li><code>validators.js</code> contains validators for all the bits of data that might be received.</li>
</ul>
<blockquote>
<p>Regardless of whatever client-side validation might be in place, all data received at the server must always be validated.</p>
</blockquote>
<h2><a class="self-ref" id="serverprojectshandler-initialization" href="#serverprojectshandler-initialization"># </a>Initialization</h2>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/index.js#L7-L18"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/projects/index.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 18</div>
  </div>
  <pre><code class="language-js">export default () =&gt;
  transactions.init()
  .then(() =&gt; createRouter()
    .get('/', handleRequest(
      validators.validateOptions,
      transactions.getAllProjects
    ))
    .get('/:pid', handleRequest(
      validators.validatePid,
      transactions.getProjectById
    ))
    .get('/:pid/:tid', handleRequest(</code></pre></div>
<p>The default export of the data handler must be a Promise which is resolved when any required initialization is done. Usually, it is the part dealing with the DBMS the one that might be asynchronous.  We have concentrated all our database operations in the <code>transactions.js</code> file, which has an <code>init</code> export which returns a Promise.</p>
<p>Our default export should return an Express router so, in the <code>.then</code> part after the initialization of the transactions, we call <code>createRouter</code> te get a new one. A router with no routes would be of little use.  Fortunately, all the routing methods, i.e. <code>get</code>, <code>post</code> and so on, are chainable so we can call all those <code>get</code>s, <code>post</code>s and <code>put</code>s and still return the router, though now it would have plenty of routes to handle.</p>
<p>The routing method functions expect a path, which might contain parameters signaled by a leading colon <code>:</code> and the name that will be given to that parameter.  All those paths are relative to the route of our projects route, which is <code>/data/v2/projects</code>.</p>
<p>Each path can be followed by any number of middleware functions. We have used none in this case.  Then, the route handler which we called <code>handleRequest</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/utils.js#L3-L17"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/utils.js</div>
    <div class="from">From: 3</div>
    <div class="to">To: 17</div>
  </div>
  <pre><code class="language-js">export const handleRequest = (...args) =&gt; (req, res) =&gt; {
  const o = {
    keys: req.params,
    data: req.body,
    options: req.query,
  };

  const action = args[args.length - 1];
  Promise.all(args.slice(0, -1).map(validator =&gt; validator(o)))
  .then(() =&gt; action(o))
  .then(reply =&gt; res.json(reply))
  .catch(reason =&gt; {
    res.status((reason instanceof Error) ? 500 : reason.code).send(reason.message);
  });
};</code></pre></div>
<p><code>handleRequest</code> returns a function that will actually handle the request. It first extracts information from the request.  The object <code>o</code> contains three main properties:</p>
<ul>
<li><code>keys</code> contains the identifiers that help locate the data. They are extracted from the request <code>params</code>.</li>
<li><code>options</code> will be an object that may contain some processing options, extracted from the part of the URL after the query mark.</li>
<li><code>data</code> may contain data required by the operation, extracted from the body, decoded by <code>bodyParser.json()</code></li>
</ul>
<p>The change of names might be considered somewhat whimsical, however, they most closely represent the purpose of each element within the transaction than the names of the parts within the URL.</p>
<p><code>handleRequest</code> expects an arbitrary number of arguments <code>args</code>.  All but the last are validators while the last is the one actually executing the transaction. They all receive a copy of the <code>o</code> object.</p>
<p>All the validators are launched in parallel via <code>Promise.all</code>, under the assumption that they are independent of one another.  If any of them were not, then they should be sequenced elsewhere.</p>
<p>Once all validators are finished, <code>then</code> the <code>action</code> is executed.  By this time, all values would have been validated and some of them converted.  The action is expected to return a value (or a Promise to return one) which is then send back to the client via <code>res.json()</code>.</p>
<p>The <code>validators</code> are not expected to return anything except, possibly, a rejected Promise.  The <code>action</code> is expected to return data to be sent to the client but it might also return a rejected Promise. To help send those errors, the <code>failRequest</code> function creates a rejection:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/utils.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/utils.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">export const failRequest = (code, message) =&gt; Promise.reject({ code, message });</code></pre></div>
<p>If any do return a rejected Promise, the last <code>catch</code> in the chain will receive a <code>reason</code> which is expected to contain a <code>code</code> and a <code>message</code>. The <code>code</code> should be an HTTP error code, however, any of the validators or actions might actually throw an error. So, in case of any rejection, the Promise is caught and, if the <code>reason</code> is an instance of <code>Error</code>, an <code>500</code> HTTP status code is sent back as the HTTP status code and the <code>message</code> as the HTTP status text.  If it is not an instance of <code>Error</code>, then the <code>code</code> is sent.  Both have a <code>message</code> property so the text is always sent.</p>
<h2><a class="self-ref" id="serverprojectshandler-validators" href="#serverprojectshandler-validators"># </a>Validators</h2>
<p>The function that validates project ids is a typical validator:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/validators.js#L7-L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/projects/validators.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-js">export function validatePid({ keys }) {
  const pid = Number(keys.pid);
  if (Number.isNaN(pid)) return failRequest(400, 'Bad Request');
  keys.pid = pid;
}</code></pre></div>
<p>The <code>pid</code> (project id) is the main record identifier for projects. The client expects it to be a string, for example a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>.  In our tiny database, our ids are actually integers from an auto-incremented primary-key field.  Our validator then tries to convert it into a number.  If it turns out not to be a number, it fails with a <code>400</code>, <code>Bad request</code> error.  Otherwise, it saves the converted <code>pid</code> back into the <code>keys</code> property.</p>
<p>Other validators <a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/validators.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> work pretty much like this one, they pick different pieces of data, do some validation and possibly a conversion and either fail with an rejection or do nothing which allows the request to carry on.</p>
<p>We have not been particularly original with our error messages.  In this implementation, the code should be a valid HTTP code which should be in the 4xx range. If there were other sources of errors that might not be instances of Error, they would have to be converted.</p>
<h2><a class="self-ref" id="serverprojectshandler-transactions" href="#serverprojectshandler-transactions"># </a>Transactions</h2>
<p>Our primitive SQL manager does require some initialization, namely preparing the SQL statements that we will use later, which is done in the <code>init</code> function:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/transactions.js#L7-L27"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 27</div>
  </div>
  <pre><code class="language-js">const sqlAllProjects =
  `select projects.*, count(tid) as pending from projects left join
  (select pid, tid from tasks where completed = 0)
  using (pid) group by pid`;

export function init() {
  prepared = {
    selectAllProjects: db.prepare(sqlAllProjects),
    selectProjectByPid: db.prepare('select * from projects where pid = $pid'),
    selectTasksByPid: db.prepare('select tid, descr, completed from tasks where pid = $pid'),
    selectTaskByTid: db.prepare('select * from tasks where tid = $tid and pid = $pid'),
    createProject: db.prepare('insert into projects (name, descr) values ($name, $descr)'),
    createTask: db.prepare(
      'insert into tasks (pid, descr, completed) values ($pid, $descr, $completed)'
    ),
    deleteProject: db.prepare('delete from projects where pid = $pid'),
    deleteTasksInProject: db.prepare('delete from tasks where pid = $pid'),
    deleteTask: db.prepare('delete from tasks where pid = $pid and tid = $tid'),
  };
  return Promise.resolve();
}</code></pre></div>
<p>We use <code>db.prepare</code> to tell the driver to pre-compile the SQL statements so later executions will run faster.  We store them all into the <code>prepared</code> object. We will use the text of the <code>sqlAllProjects</code> statement elsewhere, that is why we have it defined separately. The <code>db</code> variable contains the reference to the database driver we inititialized and assigned to <code>global.db</code> on setting up the web server <a href="https://github.com/Satyam/book-react-redux/blob/master/server/server.js#L32">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. All SQL.js operations are synchronous, however, our data handler code allows for asynchronous operations and expects a Promise so, at the end of the <code>init</code> function, we return a resolved Promise.</p>
<p>Most SQL statements listed contain identifiers starting with a <code>$</code> sign.  Those are placeholders for actual values that must be filled in later, when the query is actually performed.</p>
<p>A transaction will either return the data to be sent back to the client or a Promise to return such data or it will return Promise.reject and, of course, it may always throw an error, which also implies a rejection.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/transactions.js#L88-L99"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 88</div>
    <div class="to">To: 99</div>
  </div>
  <pre><code class="language-js">export function getTaskByTid(o) {
  const task = prepared.selectTaskByTid.getAsObject(dolarizeQueryParams(o.keys));
  if (!task.tid) {
    prepared.selectTaskByTid.reset();
    return failRequest(404, 'Item(s) not found');
  }
  task.completed = !!task.completed;
  task.tid = String(task.tid);
  task.pid = String(task.pid);
  prepared.selectTaskByTid.reset();
  return task;
}</code></pre></div>
<p>We retrieve a task by calling the prepared statement in <code>prepared.selectTaskByTid</code>.  The <code>getAsObject</code> method retrieves the record as an object with the database column names as its property names. As an argument, <code>getAsObject</code> takes an object with the named placeholders, those identifiers starting with a <code>$</code> sign in the statement, and their values.  Since mapping the query parameters to those <code>$</code> placeholders is such a common operation, we have provided a <code>dolarizeQueryParams</code> function <a href="https://github.com/Satyam/book-react-redux/blob/master/server/utils.js#L19-L27">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> to do it for us.</p>
<p>Since an object is always returned, we check to see if it is empty by checking a mandatory field, <code>task.tid</code>. Auto-incremented SQL fields can never be zero so this is an easy and safe way to do such a test.  So, if there is no <code>tid</code> then we return a rejection. Otherwise, we do some field conversions we return the retrieved task record.  SQLite has no booleans, only 0 or non-zero integer fields, so <code>completed</code> must be converted. <code>pid</code>s and <code>tid</code>s must be converted from integers, as they exist in the database, to strings.</p>
<p>In either case, once used, the prepared statement must be <code>reset</code> to have it ready for later queries.  This is an idiosyncrasy of SQL.js.</p>
<p>Other transactions such as <code>getAllProjects</code> <a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/transactions.js#L29-L54">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> may potentially return too many records so we might want to limit both the number of records and/or the columns returned.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/transactions.js#L42-L53"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 42</div>
    <div class="to">To: 53</div>
  </div>
  <pre><code class="language-js">const fields = o.options.fields;
const search = o.options.search;
return fetch(
  (fields || search)
  ? db.prepare(`select ${fields || '*'} from (${sqlAllProjects})
     ${search
       ? ` where ${search.replace(/([^=]+)=(.+)/, '$1 like "%$2%"')}`
       : ''
     }`
   )
   : prepared.selectAllProjects
 );</code></pre></div>
<p>We read the <code>fields</code>, which contains a comma delimited list of fields to retrieve, and <code>search</code> which contains a column name and a value to be contained within that column.  Both options have been already validated to contain only  strings in that format.</p>
<p>If there are either search term or list of fields, instead of using the <code>prepared.selectAllProjects</code> prepared statement, we build one on the fly by doing some string manipulation using the <code>sqlAllProjects</code> SQL statement which we had set aside <a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/transactions.js#L7-L10">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> on initialization.</p>
<p>Either way, we fetch those records in the usual SQL.js way:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/transactions.js#L30-L40"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 30</div>
    <div class="to">To: 40</div>
  </div>
  <pre><code class="language-js">const fetch = stmt =&gt; {
  const projects = [];
  let prj;
  while (stmt.step()) {
    prj = stmt.getAsObject();
    prj.pid = String(prj.pid);
    projects.push(prj);
  }
  stmt.reset();
  return projects;
};</code></pre></div>
<p>The <code>step</code> method advances the cursor to each successive record and <code>getAsObject</code> does the actual reading of each record. After converting the values that need conversion, the records are pushed into the <code>projects</code> array which eventually gets returned.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/server/projects/transactions.js#L74-L86"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 74</div>
    <div class="to">To: 86</div>
  </div>
  <pre><code class="language-js">export function getProjectById(o) {
  const prj = prepared.selectProjectByPid.getAsObject({ $pid: o.keys.pid });
  if (Object.keys(prj).length === 0) {
    prepared.selectProjectByPid.reset();
    return failRequest(404, 'Item(s) not found');
  }
  prepared.selectProjectByPid.reset();
  return Promise.resolve(getTasksByPid(o))
  .then(tasks =&gt; {
    prj.tasks = tasks;
    return prj;
  });
}</code></pre></div>
<p>Transactions might use one another, in this case, <code>getProjectById</code> uses <code>getTasksByPid</code>.  Though the latter usually returns an array of tasks, we must remember that it may return a Promise, a rejected Promise at that so, we use <code>Promise.resolve</code> when calling it so we ensure it does get treated as a Promise.</p>
</section><section id="components"><h1><a class="self-ref" id="components-react-components" href="#components-react-components"># </a>React Components</h1>
<p>React Components range from the very tiny to somewhat complex ones though never  <em>'very complex ones'</em>. If a single component is very complex it means it is trying to do too much thus it should be broken into several simpler components.</p>
<p>Each component takes care of producing a small section of the UI of an application. We need to compose them to build the whole application. We will see how several of them work, each with a higher degree of complexity.</p>
<p>Components can be stateless or stateful.  Stateless components are made of a simple function that receives a series of arguments called <em>properties</em> usually abbreviated to <code>props</code>, and returns the expected representation of the little piece of UI it deals with.</p>
<h2><a class="self-ref" id="components-stateless-components" href="#components-stateless-components"># </a>Stateless Components</h2>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/notFound.jsx#L1-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/notFound.jsx</div>
    <div class="from">From: 1</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-jsx">import React, { PropTypes } from 'react';

const NotFound = props =&gt; (
  &lt;div&gt;
    &lt;h1&gt;Not found&lt;/h1&gt;
    &lt;p&gt;Path: &lt;code&gt;{props.location.pathname}&lt;/code&gt;&lt;/p&gt;
  &lt;/div&gt;
);

NotFound.propTypes = {
  location: PropTypes.shape({
    pathname: PropTypes.string,
  }),
};

export default NotFound;</code></pre></div>
<p>The <code>NotFound</code> component is a simple stateless component. It receives a <code>props</code> object which contains a bunch of information provided by the parent component, in this case the <a href="https://github.com/reactjs/react-router">React Router</a>.  It returns very simple HTML with a text message containing the path that was not found. React Router handles navigation within a Single Page Application. It can be told which parts of the application to render depending on the URL and it can also be told what to do when no route matches the requested path. The <code>NotFound</code> component was configured to be used in such a case.</p>
<p><code>NotFound</code> is written in <a href="http://facebook.github.io/jsx/">JSX</a>, a syntax closely associated with React but not really restricted to it, for example, <a href="https://github.com/insin/msx">MSX</a> can be used with <a href="http://mithril.js.org/">Mithril</a>.</p>
<p>Though files containing JSX usually have a <code>.jsx</code> extension, this is not mandatory at all and, actually, many of our tools have to be told to read <code>.jsx</code> files as plain JavaScript with some extra.</p>
<p>JSX allows inserting HTML/XML-like code into a JavaScript source code file though, of course, the resulting mix cannot be interpreted directly as JavaScript but has to go through a compiler to produce actual JavaScript code.  The compiler looks for an expression starting with a <code>&lt;</code> symbol. In JavaSript, the <em>less than</em> symbol is a binary operator, that is, it sits in between two expressions, so no expression could possibly start with it because it would be missing the left-hand-side part. If there could be any doubt about whether a <code>&lt;</code> is binary or unary, enclosing the JSX in between parenthesis disambiguates it since after an open parenthesis, there can only be an expression.</p>
<p>JavaScript expressions, not statements, are allowed within JSX, they have to be enclosed in between curly brackets <code>{}</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/notFound.jsx#L3-L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/notFound.jsx</div>
    <div class="from">From: 3</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-jsx">const NotFound = props =&gt; (
  &lt;div&gt;
    &lt;h1&gt;Not found&lt;/h1&gt;
    &lt;p&gt;Path: &lt;code&gt;{props.location.pathname}&lt;/code&gt;&lt;/p&gt;
  &lt;/div&gt;
);</code></pre></div>
<p>Our <code>NotFound</code> component receives <code>props</code> as an argument and, since it uses a <em>fat-arrow function</em> it implicitly returns what follows. It returns a <code>&lt;div&gt;</code> enclosing a heading and a paragraph showing the path that was not found.  To insert the path within the JSX code, we enclose it in curly braces.</p>
<p>React provides a mechanism to ensure the properties received by a component are of the expected types:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/notFound.jsx#L10-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/notFound.jsx</div>
    <div class="from">From: 10</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-jsx">NotFound.propTypes = {
  location: PropTypes.shape({
    pathname: PropTypes.string,
  }),
};</code></pre></div>
<p>We can add a <code>propTypes</code> property to any component and list each of the properties within the <code>props</code> object and <a href="https://facebook.github.io/react/docs/reusable-components.html#prop-validation">their types</a>. The code that does this validation will only be included in the <em>development</em> version of the app, it will be completely stripped out in the <em>production</em> version.</p>
<p>It doesn't really matter whether the <code>props</code> were supplied by a component such as React Router as in this case, or by a component of ours.  React will always warn about properties within <code>props</code> that are not declared or are of the wrong type.  There is no need to declare all the properties, just the ones we use.  React Router provides plenty of information, we only declare those we use.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/app.jsx"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/app.jsx</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-jsx">import React, { PropTypes } from 'react';

import Errors from '_components/errors';
import Loading from '_components/loading';
import Menu from '_components/menu';

const App = ({ children }) =&gt; (
  &lt;div className="app"&gt;
    &lt;Loading /&gt;
    &lt;Errors /&gt;
    &lt;Menu
      menuItems={{
        projects: 'Projects',
      }}
    /&gt;
    {children}
  &lt;/div&gt;
);

App.propTypes = {
  children: PropTypes.node,
};

export default App;</code></pre></div>
<p>React component may include in their JSX code other React Components besides plain HTML. React expects all components to have their names starting with uppercase while plain HTML tags should always be lowercase. React Components can have attributes just like HTML elements can. The <code>Menu</code> component receives a <code>menuItems</code> attribute:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/app.jsx#L11-L15"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/app.jsx</div>
    <div class="from">From: 11</div>
    <div class="to">To: 15</div>
  </div>
  <pre><code class="language-jsx">&lt;Menu
  menuItems={{
    projects: 'Projects',
  }}
/&gt;</code></pre></div>
<p>Though we use an HTML-like style to define attributes, in JSX, the values are not restricted to plain strings. In this case, <code>menuItems</code> receives a JavaScript object. There is no need to serialize it into a JSON string as it might happen with a <code>data-xxx</code> attribute in HTML.  That is also the reason for the double curly brackets <code>{{ }}</code>, the outer set of brackets is to switch from JSX mode into plain JavaScript and the inner set are those of the object literal.</p>
<p>Here we are importing the <code>Loading</code>, <code>Errors</code> and <code>Menu</code> components from the <code>_components</code> <a href="#conventions-virtual-import-paths">virtual location</a> and using them just as we would use any other HTML element.</p>
<p>We are using the <code>children</code> property which is also provided by React Router.  <code>children</code> is validated as of type <code>React.PropTypes.node</code> which represents any kind of React component.</p>
<p>Routes in the browser behave differently than routes in the server. In the server, the first route that matches the requested path gets called and it sends via <code>res.send</code> the information back to the client.  There is no nesting, the first match does it all. We are not talking about middleware here, which can do some processing and pass on the request for others to deal with. On the server side, the first <code>res.send</code> or its equivalents, ends the operation. This is because the response to an HTTP request is a simple stream.</p>
<p>Routes in the client are meant to affect a two-dimensional screen where each part of the route might influence a particular section of it.  For example, most web pages will have a standard look, starting with an enclosing frame with the basic color scheme, perhaps the company logo, a copyright sign and so on.  Within that frame there might be other standard sections such as a header or footer, perhaps a menu or tabbed interface and finally, there will be one or more sections that are totally dependent on the route.  For example, a mail-client program will have a main section that contains the list of folders for the <code>/</code>, a list of messages in the inbox for <code>/inbox</code> or a particular message for <code>/inbox/de305d54-75b4-431b-adb2-eb6b9e546014</code>.   Each responds to a fragment of the full URL and they all combine to build the full screen.</p>
<p><img src="routes.png" alt="email program layout"></p>
<p>The image above shows how the different parts of the URL bring up different sections on the screen layout for such application, with each section dealing with a little bit more of the URL and enclosing the more specific section. That is why client-side routes are hierarchical and why one component may have a variable <code>children</code> that might be assigned by the Router. It is like a place-holder for whatever subordinated content there might be.</p>
<h2><a class="self-ref" id="components-connected-stateless-component" href="#components-connected-stateless-component"># </a>Connected Stateless Component</h2>
<p>Stateless components, as it name implies, do not contain any state. However, they can access state information held by others, such as data from the Redux store. The <code>Loading</code> component <a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/loading.jsx">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> is one such.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/loading.jsx#L6-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/loading.jsx</div>
    <div class="from">From: 6</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-jsx">export const LoadingComponent = ({ loading }) =&gt; (
  &lt;div
    className={classNames(
      'loading',
      styles.loading,
      { hide: !loading }
    )}
  &gt;loading&lt;/div&gt;
);</code></pre></div>
<p>As any stateless component, it is a simple function which receives some properties.  Since we are interested in <code>props.loading</code> we use ES6 <em>Object Destructuring</em> to get just <code>loading</code> extracted from <code>props</code>, plus <em>shorthand property names</em>.  This is not React or JSX, it is plain ES6.</p>
<p>The <code>Loading</code> component has a simple <code>div</code> containing a text message when anything is loading from a remote source.  It has a <code>className</code> attribute.  React accepts almost all HTML attributes, but has a few exceptions.  The <code>class</code> attribute would mess up JSX parsing because <code>class</code> is a reserved word in JavaScript and so is <code>for</code>.  That is why in React, we <a href="https://facebook.github.io/react/docs/dom-differences.html">should use</a> <code>className</code> instead of <code>class</code> and <code>htmlFor</code> instead of <code>for</code>.</p>
<p>We are composing the <code>className</code> attribute via the <a href="https://www.npmjs.com/package/classnames"><code>classNames</code></a> utility, which allows us to easily concatenate various class names from different sources, some of them conditionally.  That is what we are doing with the <code>{ hide: !loading }</code> part.  <code>classNames</code> will add the name of the property <code>hide</code> to the list of class names depending on the truthiness of its value which, in this case is the inverse of the boolean value of <code>props.loading</code>.</p>
<p>The <code>hide</code> class name comes from <a href="http://getbootstrap.com/css/#helper-classes-show-hide">Bootstrap</a>.</p>
<p>The <code>styles.loading</code> class names comes from the following include:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/loading.jsx#L4"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/loading.jsx</div>
    <div class="from">From: 4</div>
    <div class="to">To: 4</div>
  </div>
  <pre><code class="language-jsx">import styles from './loading.css';</code></pre></div>
<p>Importing CSS files is a feature provided by WebPack's <a href="https://github.com/webpack/css-loader">CSS-loader</a>.  The <code>loading.css</code> file <a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/loading.css">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> is a normal CSS file. WebPack can also pack CSS and load them on the client.  An interesting feature of such loading is that the CSS-loader generates unique class names for the included classes, excluding any possibility of name clashes.  The CSS-loader also understands <a href="https://github.com/css-modules/css-modules">CSS-modules</a> and optionally translates identifiers invalid in JavaScript such as those with dashes: <code>my-class-name</code> to JS-compatible camel-case: <code>myClassName</code></p>
<p>In this example, <code>styles.loading</code> might contain <code>_3ZmMd6h2aKqY_GEJqAEiQN</code> and the <code>client.css</code> bundle generated by WebPack will define the style for that unique identifier.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/loading.jsx#L16-L18"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/loading.jsx</div>
    <div class="from">From: 16</div>
    <div class="to">To: 18</div>
  </div>
  <pre><code class="language-jsx">LoadingComponent.propTypes = {
  loading: PropTypes.bool,
};</code></pre></div>
<p>We declare the type of the <code>loading</code> property within <code>props</code> to be a boolean.  All these type-checking code disappears automatically when building the <em>production</em> version so there is not cost in the final product.</p>
<p>We didn't call our component <code>Loading</code>, as the file name suggests, or the way we imported it in <code>app.jsx</code> <a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/app.jsx#L4">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> but used <code>LoadingComponent</code> instead. That is because our default export is not <code>LoadingComponent</code> but a wrapped version of it.</p>
<h2><a class="self-ref" id="components-react-redux" href="#components-react-redux"># </a>React-Redux</h2>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/loading.jsx#L20-L26"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/loading.jsx</div>
    <div class="from">From: 20</div>
    <div class="to">To: 26</div>
  </div>
  <pre><code class="language-jsx">export const mapStateToProps = state =&gt; ({
  loading: !!state.requests.pending,
});

export default connect(
  mapStateToProps
)(LoadingComponent);</code></pre></div>
<p>We might have several requests pending at any one time from various sources. It is not practical for all those possible sources to know how to notify the <code>Loading</code> component when they start a request or receive a reply. We could use some sort of global event system, but that would be messy.  Instead, we use the <a href="http://redux.js.org/docs/basics/Store.html">Redux Store</a> to do so.  Also, we cannot use a simple boolean flag, we need instead to count pending requests.  When there are any pending requests it means the <code>loading</code> status is true, when it comes down to zero, <code>loading</code> is false.</p>
<p><code>mapStateToProps</code> is a customary name for a function that receives the <code>state</code> of the Redux Store and returns an object that maps the values currently in the store into the name of the <code>props</code> that the React component will receive.</p>
<p>The <code>connect</code> function from <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options">react-redux</a> merges whichever <code>props</code> the component is already receiving from its parent with those provided by <code>mapStateToProps</code> and calls <code>LoadingComponent</code> whenever the store changes.</p>
<p><code>connect</code> returns what is called a <em>High-order Component</em> or HoC.  It is a true React Component which has the wrapped component as its only child. It is invisible to the user, it adds nothing to whatever its child renders. As a regular React component, it receives properties from its parent, it then merges them with those coming from the store thanks to <code>mapStateToProps</code> and calls our stateless <code>LoadingComponent</code>.  The latter does not need to care about Redux or its store, it just receives a plain <code>props</code> object with all it needs to know to do its simple duty.  The HoC also subscribes to the store to receive notifications of any changes so that it knows when to redraw the wrapped component.</p>
<p>We export the wrapped component as the default because, for all any other component might ever care, the wrapped component is just as good as the stateless <code>LoadingComponent</code>. No other component should really care whether a component is wrapped by a HoC or not.</p>
<blockquote>
<p>We diverge from the example given in the <a href="http://redux.js.org/docs/basics/UsageWithReact.html">Redux documentation</a> in that we don't separate <em>presentational</em> from <em>container</em> components into different folders. <em>Container</em> components are those wrapped with <code>connect</code>. The author clearly states in the <a href="http://redux.js.org/docs/FAQ.html#structure-file-structure">FAQ</a> that there is no preferred structure for a project using Redux and lists several options. We see no benefit in separating wrapped components from simple ones.  As we will see later, there can be many HoCs and we cannot allow those HoCs to define the structure of our project.</p>
</blockquote>
<blockquote>
<p>Though we export our wrapped component as the default, we still export <code>LoadingComponent</code> and <code>mapStateToProps</code> as <em>named</em> exports. The React application itself would only care for the <em>default</em> export, however, for the purpose of unit testing, it is good to have the other <em>units</em> exposed to be able to test them individually.  We don't really need to test the full connected component.  If the plain, un-connected component works and <code>mapStateToProps</code> works, it is safe to assume <code>connect</code> will do its work.</p>
</blockquote>
<h2><a class="self-ref" id="components-router-hoc" href="#components-router-hoc"># </a>Router HoC</h2>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/menu.jsx#L30"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/menu.jsx</div>
    <div class="from">From: 30</div>
    <div class="to">To: 30</div>
  </div>
  <pre><code class="language-jsx">export default withRouter(MenuComponent);</code></pre></div>
<p>In <code>menu.jsx</code> <a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/menu.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> our default export is also a wrapped component.  In this case, we use the <code>withRouter</code> HoC from React-Router:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/menu.jsx#L2"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/menu.jsx</div>
    <div class="from">From: 2</div>
    <div class="to">To: 2</div>
  </div>
  <pre><code class="language-jsx">import { Link, withRouter } from 'react-router';</code></pre></div>
<p>The <code>withRouter</code> wrapper from React Router adds a <code>router</code> property to the <code>props</code> argument of the wrapped component. We use the <code>router.isActive</code> method to know which tab in the menu to highlight as active.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/menu.jsx#L6-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/menu.jsx</div>
    <div class="from">From: 6</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-jsx">export const MenuComponent = ({ router, menuItems }) =&gt; (
  &lt;ul className={styles.tabs}&gt;
    {
      map(
        menuItems,
        (caption, path) =&gt; (
          router.isActive(path)
          ? (
            &lt;li key={path} className={styles.active}&gt;
              &lt;a&gt;{caption}&lt;/a&gt;
            &lt;/li&gt;
          )
          : (&lt;li key={path}&gt;&lt;Link to={path}&gt;{caption}&lt;/Link&gt;&lt;/li&gt;)
        )
      )
    }
  &lt;/ul&gt;
);</code></pre></div>
<p><code>MenuComponent</code> produces a tabbed navigation bar.  It accepts the <code>menuItems</code> object which contains a series of unique paths as property names and the caption for the corresponding tab.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/app.jsx#L12-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/app.jsx</div>
    <div class="from">From: 12</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-jsx">menuItems={{
  projects: 'Projects',
}}</code></pre></div>
<p>It creates an un-ordered list of list items which, thanks to <a href="http://getbootstrap.com/components/#nav-tabs">Bootstrap Tabs</a>. We are not using Bootstrap prescribed class names in our code.  We could use <a href="http://getbootstrap.com/components/#nav-pills">pills</a> instead of <a href="http://getbootstrap.com/components/#nav-tabs">tabs</a> since the actual style definitions are in the imported <code>menu.css</code> file <a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/menu.css">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which uses <a href="https://github.com/css-modules/css-modules">CSS-modules</a> to compose them out of the Bootstrap styles.  If we change the composition of styles from <code>nav-tabs</code> to <code>nav-pills</code> or to whichever classes another library might use, we change the look of the menu.</p>
<p>Since <code>menuItems</code> is not an array but an object, we resort to <a href="https://lodash.com/">Lodash</a> which works in both arrays and objects. Lodash is a large library and loading the whole of it for just one or two functions would be too expensive.   Many such libraries have been modularized.  Instead of importing everything from the library and using parts of it, we can request only what we will use.  So, instead of doing <code>import _ from 'lodash';</code> and then using the <code>_.map()</code> function, we can import just the <code>map</code> function:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/menu.jsx#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/menu.jsx</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-jsx">import map from 'lodash/map';</code></pre></div>
<p>When using the <code>map</code> function, instead of doing <code>menuItems.map( ... )</code> as we would do if it was an array, we do <code>map(menuItems, ... )</code>.  The callback receives the property values and property names, which we call <code>caption</code> and <code>path</code>.  Depending on whether the path is active, via <code>router.isActive(path)</code> we display either an inert link (it has no <code>href</code>) with the <code>styles.active</code> style.  The <code>&lt;a&gt;</code> element is just because Bootstrap expects one otherwise it won't look right.</p>
<p>For the rest of the links, we use a <code>&lt;Link&gt;</code> component which we also import from React Router. This component produces an actual <code>&lt;a&gt;</code> so Bootstrap (or any other style library) can be kept happy, but ensures that React Router will catch that request for navigation and process it itself.</p>
<p>Note that we are returning an array of <code>&lt;li&gt;</code> elements.  The <code>map</code> function returns an array of whatever the callbacks return and the callback is a <em>fat arrow function</em> which implicitly returns the value of the expression in it.  That expression is ternary conditional expression.</p>
<p>Whenever we have an array of items such as the <code>&lt;li&gt;</code> elements in this component, it is important that we assign each of them a <code>key</code> pseudo-attribute containing a unique id within the array (they might and will probably repeat over and over in an application, they just have to be unique within each array).  React uses this attribute to identify each item even as its contents change, otherwise, React wouldn't be able to know if an item with a different content is meant to be a different element or the same element with its contents changed. It becomes particularly useful when elements are inserted or deleted because it allows it to actually insert or delete the element from the DOM instead of re-render them all from the mismatched element on. We must ensure the <code>key</code> is a permanent and lasting id for the element, not just a sequentially assigned integer which changes in each render, that would be as bad as not providing any <code>key</code> at all.</p>
<p>As expected, the types of the <code>props</code> are declared both as objects:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/master/client/components/app.jsx#L12-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: master</div>
    <div class="filename">File: client/components/app.jsx</div>
    <div class="from">From: 12</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-jsx">menuItems={{
  projects: 'Projects',
}}</code></pre></div>
</section>
    </div>
  </body>
  <script type="text/javascript" src="index.js"></script>
</html>
