<!DOCTYPE html>
<html>
  <head>
    <title>Step by Step Guide to React and Redux</title>
    <link rel="stylesheet" href="ddscrollspydemo.css" />
    <link rel="stylesheet" href="github.min.css">
    <link rel="stylesheet" href="index.css">
    <script type="text/javascript" src="jquery.min.js"></script>
    <script type="text/javascript" src="ddscrollspy.js"></script>
    <script src="highlight.min.js"></script>
  </head>
  <body>
    <div class="toc"><ul class="level-h0"><li><a href="#_preface-introduction">Introduction</a></li>
<ul class="level-h1"><li><a href="#_preface-base-software">Base software</a></li>
<li><a href="#_preface-server-side-code">Server side code</a></li>
<li><a href="#_preface-client-side">Client side</a></li>
</ul>
<li><a href="#chapter01-initial-software-setup">Initial software setup</a></li>
<ul class="level-h1"><li><a href="#chapter01-nodejs">NodeJS</a></li>
<li><a href="#chapter01-npm">NPM</a></li>
<li><a href="#chapter01-editor">Editor</a></li>
<li><a href="#chapter01-github">GitHub</a></li>
<li><a href="#chapter01-git">GIT</a></li>
<li><a href="#chapter01-working-with-repositories">Working with repositories</a></li>
<ul class="level-h2"><li><a href="#chapter01-creating-a-repository">Creating a repository</a></li>
<li><a href="#chapter01-cloning-your-repository">Cloning your repository</a></li>
<li><a href="#chapter01-uploading-the-changes">Uploading the changes</a></li>
</ul>
<li><a href="#chapter01-summary">Summary</a></li>
</ul>
<li><a href="#chapter02-creating-a-simple-web-server">Creating a simple web server</a></li>
<ul class="level-h1"><li><a href="#chapter02-important-nodejs-features">Important NodeJS features</a></li>
<ul class="level-h2"><li><a href="#chapter02-modules">Modules</a></li>
<li><a href="#chapter02-event-loop">Event loop</a></li>
<li><a href="#chapter02-callbacks">Callbacks</a></li>
<li><a href="#chapter02-chaining">Chaining</a></li>
</ul>
<li><a href="#chapter02-and-finally">... and finally</a></li>
<li><a href="#chapter02-summary">Summary</a></li>
</ul>
<li><a href="#chapter03-npm-packages">NPM Packages</a></li>
<ul class="level-h1"><li><a href="#chapter03-running-the-script">Running the script</a></li>
<li><a href="#chapter03-installing-dependencies-express">Installing dependencies: Express</a></li>
<li><a href="#chapter03-installing-developer-dependencies-eslint">Installing developer dependencies: ESLint</a></li>
<li><a href="#chapter03-global-installs-eslint">Global installs: ESLint</a></li>
<li><a href="#chapter03-ignored-files">Ignored files</a></li>
<li><a href="#chapter03-summary">Summary</a></li>
</ul>
<li><a href="#chapter04-creating-an-express-web-server">Creating an Express Web Server</a></li>
<ul class="level-h1"><li><a href="#chapter04-request-parameters">Request parameters</a></li>
<li><a href="#chapter04-using-middleware">Using Middleware</a></li>
<li><a href="#chapter04-reading-data-from-a-form">Reading data from a form</a></li>
<li><a href="#chapter04-summary">Summary</a></li>
</ul>
<li><a href="#chapter05-rest">REST</a></li>
<ul class="level-h1"><li><a href="#chapter05-defining-our-rest-api">Defining our REST API</a></li>
<li><a href="#chapter05-loading-sample-data">Loading sample data</a></li>
<li><a href="#chapter05-global-variables">Global variables</a></li>
<li><a href="#chapter05-writing-a-module-to-respond-to-rest-requests">Writing a module to respond to REST requests</a></li>
<li><a href="#chapter05-summary">Summary</a></li>
</ul>
<li><a href="#chapter06-testing-our-server">Testing our server</a></li>
<ul class="level-h1"><li><a href="#chapter06-loading-testing-software">Loading testing software</a></li>
<li><a href="#chapter06-running-the-tests">Running the tests</a></li>
<li><a href="#chapter06-testing-the-data-server">Testing the data server</a></li>
<li><a href="#chapter06-summary">Summary</a></li>
</ul>
<li><a href="#chapter07-code-coverage">Code coverage</a></li>
<ul class="level-h1"><li><a href="#chapter07-installing-istanbul">Installing Istanbul</a></li>
<li><a href="#chapter07-running-istanbul">Running Istanbul</a></li>
<li><a href="#chapter07-improving-coverage">Improving coverage</a></li>
<li><a href="#chapter07-linting">Linting</a></li>
<li><a href="#chapter07-summary">Summary</a></li>
</ul>
<li><a href="#chapter08-switching-to-sql">Switching to SQL</a></li>
<ul class="level-h1"><li><a href="#chapter08-building-sql-statements-dynamically">Building SQL statements dynamically</a></li>
<li><a href="#chapter08-regular-anonymous-functions-vs-fat-arrow-functions">Regular anonymous functions vs. fat arrow functions</a></li>
<li><a href="#chapter08-testing-the-changes">Testing the changes</a></li>
<li><a href="#chapter08-handling-url-query-parameters">Handling URL Query Parameters</a></li>
<li><a href="#chapter08-sql-injection">SQL Injection</a></li>
<li><a href="#chapter08-summary">Summary</a></li>
</ul>
<li><a href="#chapter09-separating-concerns">Separating Concerns</a></li>
<ul class="level-h1"><li><a href="#chapter09-simplifying-validation-with-middleware">Simplifying validation with middleware</a></li>
<li><a href="#chapter09-summary">Summary</a></li>
</ul>
<li><a href="#chapter10-client-side">Client side</a></li>
<ul class="level-h1"><li><a href="#chapter10-the-way-not-to-do-it">The way not to do it</a></li>
<li><a href="#chapter10-polyfills">Polyfills</a></li>
<li><a href="#chapter10-transpiling">Transpiling</a></li>
</ul>
<li><a href="#chapter11-modules-imports-and-exports">Modules, Imports and Exports</a></li>
<ul class="level-h1"><li><a href="#chapter11-webpack">WebPack</a></li>
<li><a href="#chapter11-packaging-and-transpiling">Packaging and Transpiling</a></li>
<li><a href="#chapter11-almost-a-single-page-application">Almost a Single Page Application</a></li>
<li><a href="#chapter11-summary">Summary</a></li>
</ul>
<li><a href="#chapter12-client-side-routing">Client-side Routing</a></li>
<ul class="level-h1"><li><a href="#chapter12-react-router">React Router</a></li>
<li><a href="#chapter12-jsx">JSX</a></li>
<ul class="level-h2"><li><a href="#chapter12-proptypes">PropTypes</a></li>
<li><a href="#chapter12-production-version">Production version</a></li>
<li><a href="#chapter12-watch-for-changes">Watch for changes</a></li>
<li><a href="#chapter12-final-touches">Final touches</a></li>
</ul>
<li><a href="#chapter12-summary">Summary</a></li>
</ul>
<li><a href="#chapter13-events">Events</a></li>
<ul class="level-h1"><li><a href="#chapter13-stateful-components">Stateful components</a></li>
<ul class="level-h2"><li><a href="#chapter13-stateless-or-stateful">Stateless or Stateful</a></li>
</ul>
<li><a href="#chapter13-putting-some-order-into-our-files">Putting some order into our files</a></li>
<li><a href="#chapter13-conditional-rendering">Conditional rendering</a></li>
<li><a href="#chapter13-lodash">Lodash</a></li>
</ul>
<li><a href="#chapter14-actions-stores-flux-and-redux">Actions, Stores, Flux and Redux</a></li>
<ul class="level-h1"><li><a href="#chapter14-redux">Redux</a></li>
<li><a href="#chapter14-dispatching-an-action">Dispatching an action.</a></li>
<li><a href="#chapter14-using-shouldcomponentupdate">Using shouldComponentUpdate</a></li>
<li><a href="#chapter14-redux-principles">Redux principles</a></li>
<li><a href="#chapter14-summary">Summary</a></li>
</ul>
<li><a href="#chapter14a-rearranging-the-files">Rearranging the files</a></li>
<ul class="level-h1"><li><a href="#chapter14a-the-components-folder">The components folder</a></li>
<ul class="level-h2"><li><a href="#chapter14a-dropping-the-file-extension">Dropping the file extension</a></li>
<li><a href="#chapter14a-delegating-routes">Delegating routes</a></li>
</ul>
<li><a href="#chapter14a-the-store-folder">The store folder</a></li>
<ul class="level-h2"><li><a href="#chapter14a-actions">Actions</a></li>
<li><a href="#chapter14a-reducer">Reducer</a></li>
<li><a href="#chapter14a-the-indexjs-file">The index.js file</a></li>
</ul>
<li><a href="#chapter14a-consolidating-the-store">Consolidating the store.</a></li>
<ul class="level-h2"><li><a href="#chapter14a-actions">Actions</a></li>
<li><a href="#chapter14a-creating-the-store">Creating the store</a></li>
<li><a href="#chapter14a-some-left-over">Some left-over</a></li>
</ul>
<li><a href="#chapter14a-whats-left-at-the-top">What's left at the top</a></li>
<li><a href="#chapter14a-why-separate-components-and-store">Why separate components and store</a></li>
<li><a href="#chapter14a-summary">Summary</a></li>
</ul>
<li><a href="#chapter15-react-and-redux">React and Redux</a></li>
<ul class="level-h1"><li><a href="#chapter15-react-redux">React-Redux</a></li>
<ul class="level-h2"><li><a href="#chapter15-data-containers">Data containers</a></li>
<li><a href="#chapter15-dispatching-actions">Dispatching actions</a></li>
</ul>
<li><a href="#chapter15-refreshing">Refreshing</a></li>
<li><a href="#chapter15-summary">Summary</a></li>
</ul>
<li><a href="#chapter16-tools-and-helpers">Tools and helpers</a></li>
<ul class="level-h1"><li><a href="#chapter16-react-developer-tools">React Developer Tools</a></li>
<li><a href="#chapter16-redux-dev-tools">Redux Dev Tools</a></li>
<li><a href="#chapter16-react-performance-tools">React Performance tools</a></li>
<li><a href="#chapter16-webpack-warnings">WebPack warnings</a></li>
<li><a href="#chapter16-ui-components">UI components</a></li>
<li><a href="#chapter16-flux-standard-actions">Flux Standard Actions</a></li>
<li><a href="#chapter16-navigating">Navigating</a></li>
<li><a href="#chapter16-class-names">Class Names</a></li>
<li><a href="#chapter16-react-router-redux">react-router-redux</a></li>
<li><a href="#chapter16-memoizing-caching">Memoizing (caching)</a></li>
<li><a href="#chapter16-reducing-boilerplate">Reducing Boilerplate</a></li>
<li><a href="#chapter16-summary">Summary</a></li>
</ul>
<li><a href="#chapter17-data-normalization">Data Normalization</a></li>
<ul class="level-h1"><li><a href="#chapter17-data">Data</a></li>
<li><a href="#chapter17-reducers">Reducers</a></li>
<li><a href="#chapter17-components">Components</a></li>
<li><a href="#chapter17-server-side">Server side</a></li>
<ul class="level-h2"><li><a href="#chapter17-reducing-the-number-of-requests">Reducing the number of requests</a></li>
</ul>
<li><a href="#chapter17-summary">Summary</a></li>
</ul>
<li><a href="#chapter18-asynchronous-operations">Asynchronous operations</a></li>
<ul class="level-h1"><li><a href="#chapter18-phases-of-a-remote-request">Phases of a remote request</a></li>
<li><a href="#chapter18-redux-middleware">Redux Middleware</a></li>
<li><a href="#chapter18-dispatching-initial-loading-actions">Dispatching initial loading actions</a></li>
<li><a href="#chapter18-writing-our-own-middleware">Writing our own middleware</a></li>
<li><a href="#chapter18-summary">Summary</a></li>
</ul>
<li><a href="#chapter19-styling">Styling</a></li>
<ul class="level-h1"><li><a href="#chapter19-including-css-files">Including CSS files.</a></li>
<li><a href="#chapter19-css-modules">CSS Modules</a></li>
<li><a href="#chapter19-composing-styles">Composing styles</a></li>
<li><a href="#chapter19-summary">Summary</a></li>
</ul>
<li><a href="#chapter20-editing">Editing</a></li>
<ul class="level-h1"><li><a href="#chapter20-dispatching-the-new-actions">Dispatching the new actions</a></li>
<li><a href="#chapter20-rendering-a-stateful-form">Rendering a stateful form</a></li>
</ul></li></ul></div>
    <div class="contents unfolded"><div class="close">&lt; close</div><section id="_preface"><h1><a class="self-ref" id="_preface-introduction" href="#_preface-introduction"># </a>Introduction</h1>
<p>With the rapid pace of progress in the creation of libraries and tools for web development, most information comes in brief articles and blog posts.  There are not very many comprehensive guides to all that may be needed from A to Z.</p>
<p>This book intends to fill that gap. We will go step by step gathering the tools and utilities we need for each step and explaining how to use them and coding a full, modern single page application.</p>
<p>We will avoid dumping a whole suite of tools and sample code all at once. There are many <a href="https://github.com/facebook/react/wiki/Complementary-Tools#full-stack-starter-kits">full-stack solutions</a> or 'boilerplates' available, however, they are often quite hard to assimilate all at once. They contain too many pieces all strung together without much explanation.  We prefer to go one step at a time.  You may jump ahead and go to the end but then you wouldn't know why we did things the way we did and wouldn't know how to fix it if you disagree.</p>
<p>We will make many mistakes in the way.  <strong>Don't take a sample from any chapter blindly</strong>.  The purpose of this book is to learn, not to provide recipes. We get to a working solution towards the end but we hope you would have learned enough while getting there to devise your own. Beyond using React and Redux, we are not selling a particular way of doing things, we want you to be able to decide on which one out of the many available out there.</p>
<p>We won't cover all the alternatives -that would be impossible- but we will present a very good one. We will use Facebook's <a href="https://facebook.github.io/react/index.html">React</a> coupled with <a href="http://redux.js.org/index.html">Redux</a> for data handling.</p>
<p>We will write both server and client code and keep track of its development via <a href="https://github.com/">GitHub</a>.  We will lint, test, check its performance and package it for faster delivery and automate all these processes.  We will turn our app isomorphic, that is, able to render fully formed pages straight from the server for faster rendering on slow devices or for SEO purposes.</p>
<p>Sample code showing each feature as it is described within the book are available for download. The <a
  href="https://github.com/Satyam/book-react-redux/archive/chapter-00-00.zip"
  class="download"
><img
  title="Download Chapter 00-00 from GitHub"
  src="octocat.png"
/>&dArr;</a> icon points to ZIP files containing the code. It can be downloaded and expanded anywhere. Then the code can be installed and made ready to run by doing:</p>
<pre><code class="language-sh">npm install
npm run build
npm start
</code></pre>
<p>We will explain the purpose of those commands <a href="#chapter03">later on</a>.</p>
<p>A brief itinerary of what we will go through follows, however, you may skip straight into <a href="#chapter01">chapter 1</a>.</p>
<h2><a class="self-ref" id="_preface-base-software" href="#_preface-base-software"># </a>Base software</h2>
<p>There is some software we need to make sure we have installed.  You might already have it or not.  We'll check that in the first chapter.  To begin with we will need NodeJS, which gives us the ability to leverage our knowledge of JavaScript at both ends.  It is fair to say that JavaScript is not the only alternative on the server side, you might have already used or heard about PHP or Java but unless you have any legacy system and/or experience, nowadays JavaScript is the way to go, one single language across all the application.</p>
<p>Then, we need to create a repository on <a href="http://github.com">GitHub</a>. A repository is the place up in the cloud where all the development team can store and share their work.  GitHub is one major provider of such shared space. Even if we work alone, GitHub will help us to keep track of the progress of the project, report and respond to issues and keep a nice set of safe copies of our job up there in the cloud. It not only works with code, documentation can be stored there as well; after all both this book and the accompanying code are up there in GitHub.</p>
<p>To use GitHub we need to install a GIT client.</p>
<h2><a class="self-ref" id="_preface-server-side-code" href="#_preface-server-side-code"># </a>Server side code</h2>
<p>In the next few chapters we will work on the server-side. Our browser will show whatever information the server is able to provide so it makes sense to start on that side. Most of what we learn on the server side we will later use on the client side.</p>
<p>Moreover, the server is also a simpler environment.   When we are on the client side we need to take into account too many other issues. This can make it all very confusing.  In the simpler environment of the server, we can go a step at a time.</p>
<p>We will learn to install and create a web server using Express and how to serve data from it by using REST (Representational state transfer) architecture.</p>
<p>To avoid unintended errors, we will do a static check of our code using a <em>linter</em>, a sort of compiler that checks the syntax and formatting of our code and only produces a listing of errors, if any.  This will also help us keep a consistent style on the code we produce.  When developing in teams, it is better to have a consistent coding style everyone can easily recognize.</p>
<p>Before releasing this server-side software to the world, it is better to test it dynamically, not just do a static syntax check, which we will do by setting an automated testing system.  This not only ensures that our code works as we meant it to, but also that during development, any changes we make do not break any functionality that was already there.</p>
<p>Once we are sure our code is good, we send the new version back to the GitHub repository.  In this way we share it with the rest of the team so that it can all rejoice and celebrate or, at least, get on with the rest of the project.</p>
<p>Up to this point, in our examples, we would have been storing our data in-memory within the web server.  This would have allowed us to concentrate on the topics described above, however, for any meaningful amount of data, memory storage is not a good idea. There are very many ways to store data server-side.  The first big decision to make is whether to go for an SQL server or a non-SQL or <em>NoSQL</em> one. Then, within each of those, which particular implementation.</p>
<p>For the purpose of this book, we will use a simple SQL database, <a href="https://www.sqlite.org/">SQLite</a>. The SQL language is quite standard, in fact, it is both an ANSI (American) and ISO (international) standard. Admittedly, there are small inconsistencies in between actual implementations, but at least there is a solid base, which NoSQL databases lack.  Within all the SQL databases available, we will use SQLite because it is the simplest one to set up and install.  It is not apt for a serious web service, but for teaching purposes, it works fine.</p>
<p>Once we do the conversion to SQL, we will run the tests again, to make sure we didn't break anything in the migration.  Here, we can clearly see the benefit of having a set of tests made.  We have completely changed our back end software and we can still assure that our server still works as it did before.</p>
<p>As always, after testing, we save it in our GitHub repository.</p>
<h2><a class="self-ref" id="_preface-client-side" href="#_preface-client-side"># </a>Client side</h2>
<p>First of all we will learn how to retrieve the data from the server we have been building in the previous chapters.  Our first renderings will be rather crude, but we'll fix that in a moment.</p>
<p>For the browser, we have opted to use Facebook's <a href="http://facebook.github.io/react/">React</a> as the rendering library.  This is just one of very many options out there and plenty of books could be devoted to praising one or the other.  Many articles certainly have.  It would be easy to say that it handles the V in the MVC model, but that would get us into equally endless discussions about MVC and the many abbreviations derived from it and which of them applies.</p>
<p>A web developer should be able to reach all users using any sort of browser.  It is not admissible to have an application that only works in the most recent release of a particular browser.  The great majority of browsers do not support the latest version of JavaScript, formally EcmaScript 2015, often shortened to ES6.  To deal with that, and the various incompatibilities amongst browsers we will use <a href="http://babeljs.io/">Babel</a>, what is now know as a <em>transpiler</em>, that is, a compiler that reads ES6 code and translates it to ES5 code that can run in any browser.</p>
<p>Browsers don't know about <em>modules</em> and <em>packages</em> as NodeJS does. ES6-style modules are not supported in most browsers, if any. To be able to use modules in the client side, we will use a packager called <a href="http://webpack.github.io/">WebPack</a> which will produce a single bundle that any browser can easily load and simulate NodeJS-style modules for us.</p>
<p>We will use <a href="https://github.com/rackt/react-router">React-Router</a> to be able to convert our separate pages into a Single-Page Application (SPA) by allowing the user to navigate across all of our application without resorting to the server.</p>
<p>We will then see how we can consolidate all our data into various models (the M in MVC), separate from the rendering components (the V in MVC) so we can avoid duplication of data and ensure proper synchronization of information across all of our application.</p>
<p>Now that we have the data properly managed, we can start changing it by responding to user interaction. We will do that by using <a href="http://redux.js.org/index.html">Redux</a> one of the various implementations of the <a href="https://facebook.github.io/flux/">Flux</a> uni-directional data-flow architecture.   Flux, as originally defined, is a good concept but its implementation as a library is somewhat lacking. Redux, is very well documented and while it is an amazingly small piece of code, it is quite complete and has a good number of tools that supplement it when needed.</p>
<p>As we progress in our application we will see how to improve its looks by using an external style library.  We will use the popular <a href="http://getbootstrap.com/">Bootstrap</a> though there are many alternatives. We will just use its built-in styles and avoid using its active components so as to show how to code working components.  In practice, once you settled on a user interface style library, you would use its components.</p>
<p>One of the advantages or having JavaScript on the server is that we may run the very same code that runs in the browser. One reason to do that is to improve the user perception of speed.  On slow devices on slow connections, which usually means smart phones, a complex page might take quite a while to load and render.  If a static image of that same page can be produced on the server, it can be immediately displayed to the user even before the application has been loaded.  The other reason is that search engines won't execute your application to find out what it produces in order to index it. A page composed on the fly at the browser is invisible to search engines. Producing a static version of it at the server is the way to have it indexed.  This is called isomorphism, the ability to look the same at either end. We will see what needs to be done to turn our application into an isomorphic one.</p>
<p>Finally we will deal with internationalization, the ability of an application to show up in different languages and using regional conventions to display numbers or dates.</p>
<p>All along we will make an aside on writing the code to check it by linting and testing it.</p>
<p>It is unfortunate that we will not be able to show any utility to provide automated documentation.  The existing utilities lag behind the tools we will be using, the docs they provide fall quite short of really describing the code.  The best ones analyze the code itself to fill in part of the documentation.  While this is a good idea to reduce the work of the programmer, many of these are unable to understand ES6 or JSX (more on JSX later) so they get totally confused.  The results are quite unsatisfactory so we will not cover them.  We will just hold on to the basic principle of writing small modules in separate files with sensible names placed in a logical folder structure and providing self-describing identifiers to any named thing.</p>
</section><section id="chapter01"><h1><a class="self-ref" id="chapter01-initial-software-setup" href="#chapter01-initial-software-setup"># </a>Initial software setup</h1>
<h2><a class="self-ref" id="chapter01-nodejs" href="#chapter01-nodejs"># </a>NodeJS</h2>
<p>For a long time, Web developers had to learn one of several languages to code on the server, usually PHP, Python, Java or whatever your company had available.  Shyly, some developers started adding some interactivity to web pages using JavaScript.  JavaScript started to grow with sophisticated web applications such as Google Maps or fancy email clients. Thus, developers ended up having to use two different languages, one for the client, JavaScript, and another for the server.</p>
<p>All that changed in 2009 when Ryan Dahl adapted Google's open source V8 JavaScript engine to work in Linux. With later versions made to work in all popular platforms, NodeJS allowed web developers to use one single language everywhere: JavaScript.</p>
<p>We need to check if we have NodeJS already installed. At a command prompt we can type <code>node --version</code> or <code>node --help</code> which will either fail if NodeJS is not installed or produce a suitable response.  At the time of reviewing this chapter, the version for NodeJS is 4.4.2.  If you do have an older NodeJS it means you already know how to install it and hopefully how to upgrade it.</p>
<p>To install NodeJS simply go to the download page on their <a href="https://nodejs.org/">site</a>. The home page will detect which download is suitable for your computer and offer it as a download.  NodeJS offers two versions, the <code>LTS</code> (Long Term Support) which is the safest one, which is what we will be using, and a more adventurous one for developers willing to experiment with the upcoming features.</p>
<h2><a class="self-ref" id="chapter01-npm" href="#chapter01-npm"># </a>NPM</h2>
<p>NodeJS became quite a success and suddenly lots of developers were writing software to run on it.  NodeJS promotes a very modular way of writing code.  Instead of big source files containing hundreds of lines of code, it is much better to split the code in small, very maintainable pieces called <em>modules</em>. Several of those <em>modules</em> can be grouped together to make a <em>package</em>.  To help in managing those packages, Isaac Z. Schlueter wrote <code>npm</code>, NodeJS Package Manager. Initially, <code>npm</code> had to be installed separately, currently it is installed along NodeJS so there is nothing you have to do, if you installed NodeJS, you have <code>npm</code>.</p>
<p>NPM is not just software, there is also a web site <a href="https://www.npmjs.com/">npmjs.com</a> that contains above two hundred thousand free packages. Npm, Inc, the company that runs the site, does not evaluate the quality of those packages but it provides good information to evaluate its worth. There are very many well known excellent packages. We will use several of those.</p>
<h2><a class="self-ref" id="chapter01-editor" href="#chapter01-editor"># </a>Editor</h2>
<p>Comprehensive IDEs such as Eclipse or Microsoft's Visual Studio have fallen out of favor mostly because they are too heavy and slow. As Web development changes fast, it is impossible for the large IDEs to keep pace. The current trend is towards smaller and fast text-editors with a flexible plugin architecture so, whatever the original designers left out, someone else can add.</p>
<p>If you don't have a beloved text editor installed in your system I'd like to suggest a couple of interesting options Adobe <a href="http://brackets.io/">Brackets</a> and GitHub <a href="https://atom.io/">Atom</a>.  Both are very capable and fast editors and both have a large list of plugins to add any features not already built-in.  The most interesting feature of both is that they are written mostly in JavaScript running in NodeJS, which you should have installed by now.</p>
<p>Both editors are also open source and anyone of us can contribute to its development or add plugins.  As any such large collaborative project, they are both hosted in GitHub (<a href="https://github.com/adobe/brackets"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /> Brackets</a> and <a href="https://github.com/atom/atom"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /> Atom</a>)</p>
<h2><a class="self-ref" id="chapter01-github" href="#chapter01-github"># </a>GitHub</h2>
<p>Teams of developers, possibly continents apart, need somewhere to put their source code which they can all reach. GitHub has become the place of choice for that. The last two links in the previous section point to software stored in GitHub. The little icon before each name is Octocat, GitHub's mascot. Lots of people got creative with this little creature and there is the Octocat Index or <a href="https://octodex.github.com/">Octodex</a> showing many of its personalities. We will use that icon along links pointing to code residing in GitHub.</p>
<p>It is now time to setup your GitHub account.  Go to <a href="https://github.com/">GitHub</a> and create your account. Just follow the instructions on the screen.  To finish the account creation process, GitHub will send an e-Mail message to validate the address you have provided. GitHub will recognize you by your e-Mail address so it is vital that it works but it will not make it public unless you tell it to.</p>
<p>All your postings in GitHub will show the user name you have given when you created the account.  Do provide a good user name because that is how everyone will refer to you and, hopefully, make you famous.  Your Twitter handle or similar known alias would be a good choice. GitHub will use your name for a folder where all your stuff will be stored.  Unfortunately, many good, short names are already taken, some of which you don't even see because they might be private projects.</p>
<p>Software in GitHub is stored in <em>repositories</em>.  Repositories can be public or private.  Public repositories are free. Absolutely everyone can see what you store in them but only those you set as collaborators can modify it.  If you want to keep your code secret, then you have to create a private repository and pay a fee.</p>
<p>Though we will use GitHub to store computer code, it can actually be used for any kind of text, such as this book <a href="https://github.com/Satyam/book-react-redux">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> or all sorts of documents like those issued by government agencies <a href="https://github.com/GSA">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. Many legal firms, editors and publishers, translators and others sharing large amounts of documents also use it though, understandably, they tend to use private repositories.</p>
<p>Though everyone can see and download anything in public repositories, to actually change anything, besides having permission to do so, you can either use the on-line editor, which is only practical for minor modifications, or use a git client which lets you synchronize your local working copy and the one in the remote repository.</p>
<h2><a class="self-ref" id="chapter01-git" href="#chapter01-git"># </a>GIT</h2>
<p>Git is a source control system. It allows a distributed team of people to share and keep track of changes in source code over time. It was initially designed in 2005 by Linus Torvalds to manage the Linux kernel, the version of Unix he wrote and named after himself.  Linux which, at the time, was the largest open source project in the world, needed a safe, secure and fast means of allowing its collaborators to work together.  None of the existing systems satisfied all the expectations of the team so they developed one of their own.</p>
<p>The basic Git client software can be downloaded from their <a href="http://git-scm.com/downloads">download page</a>.  The basic Git client software is a command-line utility with no user interface.  Several <a href="http://git-scm.com/downloads/guis">GUI clients</a> are listed in the same site. In this book, however, we will use the command-line commands, since they are the standard. For Windows or Mac users I would suggest <a href="https://desktop.github.com/">GitHub's own desktop</a> since that is where we will store our code. Many popular coding text editors and IDEs (Integrated development environment) have plugins for Git.</p>
<p>Once Git is installed, we need to set it up.  Since Git will interact with remote servers, you need to provide it with information about you.</p>
<p><code>git config --global user.name &quot;YOUR USER NAME&quot;</code></p>
<p><code>git config --global user.email &quot;YOUR EMAIL ADDRESS&quot;</code></p>
<p>It is best to use the same user name and e-mail address you used on your GitHub account. GitHub will use the e-Mail address to associate your commits with your GitHub account. GitHub will not make your e-Mail public unless you explicitly tell it to. Do not change the e-Mail address once you set it up, otherwise, GitHub will no longer recognize you.  The user name you give to your git client may or may not match your GitHub account name, but then, why wouldn't it?</p>
<p>In order to prevent GitHub from requesting your login information too often, you might want to tell git to temporary remember you.</p>
<p><code>git config --global credential.helper cache</code></p>
<p>Git will remember you for about 15 minutes after a login, if you want to change that, you can do:</p>
<p><code>git config --global credential.helper 'cache --timeout=3600'</code></p>
<p>Timeout is measured in seconds so the above gives you one hour.</p>
<p>If you have a Git GUI or a plugin for your editor, they will usually offer to save your credentials for you.</p>
<h2><a class="self-ref" id="chapter01-working-with-repositories" href="#chapter01-working-with-repositories"># </a>Working with repositories</h2>
<h3><a class="self-ref" id="chapter01-creating-a-repository" href="#chapter01-creating-a-repository"># </a>Creating a repository</h3>
<p>Go to <a href="https://github.com">GitHub</a> and, if you are a new user, you will see a mostly empty page except for some pictures linking to some tutorials.  Somewhere on that page (the design might vary over time) there will be a button to create a <kbd>New repository</kbd>. Click on it (nothing will happen until you confirm it) and fill in the name and description.  Select a public (free) repository, opt to have a README file and select a <code>.gitignore</code> for <code>Node</code> and a license.</p>
<p>As Nicholas C. Zakas explains in a recent <a href="https://www.nczonline.net/blog/2015/12/why-im-not-using-your-open-source-project/">article</a> selecting a license is vital.  You might assume that by not imposing a license requirement you are leaving your code open for anybody to use.  Quite the opposite, in most countries unless you explicitly surrender your rights, the copyright is yours.  You can either pick one of the very many licenses on offer (I suggest the MIT License) or state your own terms. Don't try to be funny with the terms of your license if you make your own.  A well known piece of software added the clause &quot;The Software shall be used for Good, not Evil&quot; and caused quite a <a href="https://en.wikipedia.org/wiki/JSLint#License">lot of trouble</a>.</p>
<p>Finally, click on the <kbd>Create repository</kbd> button.  You can actually add both the <code>README</code>, <code>.gitignore</code> and license files later on and if you are not happy with the name or description, you can change it as well.  And if you don't like anything in it, you can delete it though, once you start working on your project, it would be a shame.</p>
<h3><a class="self-ref" id="chapter01-cloning-your-repository" href="#chapter01-cloning-your-repository"># </a>Cloning your repository</h3>
<p>So far you have the basic structure of a project but it is only up there in GitHub, you have nothing in your own computer.  The first thing we need to do is to make a local working copy of it and to do that we will <em>clone</em> it.</p>
<p>Somewhere in the page (now it is above the file listing but it used to be on the right so, just look for it) there is a dropdown that lets you pick either <kbd>SSH</kbd> or <kbd>HTTPS</kbd> and to its right there will be a long string that looks like an URL, for example, if you select <kbd>HTTPS</kbd> you might see:</p>
<p><code>https://github.com/MyUserName/MyNewRepository.git</code></p>
<p>Copy that string.</p>
<p>In a terminal, command prompt or whatever you call it in your operating system type <code>git clone</code> and then paste the URL you copied from GitHub. The <code>git clone</code> command  will create a folder with the repository name under your current folder and  download everything in the repository.  It will also add a <code>.git</code> folder with some configuration information related to the repository.</p>
<p>If you now do a <code>cd MyNewRepository</code> (or whatever you called it) you will see your <code>README.md</code>, <code>LICENSE</code> and <code>.gitignore</code> files.  Unix-based systems, by default will not show files starting with a dot so you might not see the <code>.gitignore</code> file.  We will see the purpose of this file later on.</p>
<p>The <code>LICENSE</code> file is a plain text file containing the terms of the license you have selected.</p>
<p>The <code>README.md</code> file is what contains the text that is shown right below the file listing in the GitHub repository.  It is a plain text file written in <a href="https://guides.github.com/features/mastering-markdown/">Markdown</a> format, the same used in writing this book.  The sample file will contain the name of the repository as its main heading and the description provided when you created the repository as its content.</p>
<p>You might want to change some of the text in that README.md file to try out some of the styles shown in the <a href="https://help.github.com/articles/markdown-basics/">guide</a>. Markdown was <a href="https://daringfireball.net/projects/markdown/">originally designed</a> to be an easier way to generate simple HTML, improving on the usual <code>readme.txt</code> files that used to be distributed along software packages.</p>
<p>If you are using the <a href="http://brackets.io/">Brackets</a> editor you might want to install the <a href="https://github.com/gruehle/MarkdownPreview">MarkdownPreview</a> extension.  If you are using <a href="https://atom.io/">Atom</a> you already have the <a href="https://atom.io/packages/markdown-preview">markdown-preview</a> plugin installed. Either will let you see a preview of how your README.md will look once uploaded to GitHub.   GitHub uses a particular <a href="https://help.github.com/articles/github-flavored-markdown/">flavor</a> of Markdown so except for the Atom previewer the results shown on others might be slightly different.</p>
<h3><a class="self-ref" id="chapter01-uploading-the-changes" href="#chapter01-uploading-the-changes"># </a>Uploading the changes</h3>
<p>We want to change something in our working copy so we can see how to upload our changes to GitHub. We have already played a little bit with our README.md.  Now, lets go and create a folder called <code>server</code> where we will put the code we are about to write. Lets put a file there, an empty file called <code>index.js</code>.  We will fill it up later, but for now, lets just see how git works.</p>
<p>Go to the terminal or command prompt and type <code>git status</code>.  This will show which files have been modified such as the README.md, and which files are <em>untracked</em> which means they have been newly created and git has no clue about them yet.  This already tells us something, git keeps track of the files it knows about, namely, those that have been brought from your GitHub repository.</p>
<p>Uploading files to your remote repository is a process similar to sending a package through the mail.  First you put everything into a box. In git parlance this is called <em>staging</em>. Git already knows about those files you have received, however, it doesn't know about the new files you have added or which files you want to include in the box. For whatever reason, you might want to ship your files in separate packages but, if you know that everything in your working folder should go, you can simply do a <code>git add .</code> .  Note the dot after <code>add</code>, meaning the current working folder.  This will add to the box every file and folder it finds in the current folder and in those below.</p>
<p>If you repeat the <code>git status</code> command, you will see the files previously listed in red (if your terminal/command prompt supports such coloring) now showing in green meaning that they are in the box, that is, <em>staged</em>. <code>git status</code> is always a handy command to use. Another useful one is <code>git diff README.md</code> which will show a list of the differences in between your working version of the README.md file (or any other you ask for) and the copy in the repository.</p>
<p>Now that you have everything in the box, you have to close it and label it.  You do that with <code>git commit -m &quot;my first commmit&quot;</code>.  The <code>-m &quot;whatever&quot;</code> is optional and if you don't provide that option, git will fire up whichever your default text editor might be configured in your system (notepad, gedit, etc.) and let you write a brief description of what you have changed in this commit.</p>
<p>Finally, you just have to dispatch it.  You do this by pushing it: <code>git push origin master</code>. You will then be asked for your user name and password.  So far there had been no need for identifying yourself. Since the repository is public, everyone can read it and clone it.  All the changes you then do in your local workspace are of no concern to git, however, when you <code>push</code> your changes back GitHub needs to make sure you are authorized to do that.</p>
<p>The basic command is <code>git push</code> but you need to add some destination address to your shipment.  We won't deal with that right now but suffice it to say that git is able to manage multiple versions or <em>branches</em> of the same project and also deal with hierarchies of repositories so that, for example, in our case a sub-team might deal with server-side development and another with client-side development and each have a sub-repository from the main repository. That is the reason for those extra options.  Since, for the time being, we are the only users of our single repository, we will always do <code>git push origin master</code>.</p>
<p>If we go to <a href="https://github.com">GitHub</a> we will now see our changes reflected in the repository.  If we did any changes in the README.md file, the home page of the project, shown right below the file listing, will display the new text.  We can also dig down into the <code>server</code> folder where we will find the <code>index.js</code>.  The description we provided when we issued the <code>git commit</code> command with the <code>-m</code> option will be shown along the files affected as well as the date of the change.</p>
<p>If we open the README.md file, we will see its raw, unformatted contents and at the top we can see there is a button labeled <code>History</code>.  This will show us each of the changes done on the file (not many right now) each accompanied with its commit description and time stamp and, if we click on any of the entries, we will see the file with its changes marked green for the additions and red for the deletions. Two columns of line numbers on the left correspond to the before and after source files.</p>
<p>There is not much to see right now but try it out later on once we have done some few changes. There is far more to git and GitHub than what we have mentioned so far.  It really shines when used with large teams in big projects but, for the time being, it is good to becomes somewhat familiar with it.</p>
<h2><a class="self-ref" id="chapter01-summary" href="#chapter01-summary"># </a>Summary</h2>
<p>We have learned how to install several of the tools we will need to develop our application: NodeJS, NPM and optionally some JavaScript editors written in JavaScript.</p>
<p>We have also installed GIT which allows us to work with GitHub, a place where we can store our code, keep track of the changes, share it with others, track bugs and issues and, in general, manage much of the process of creating an application.</p>
<p>Finally, we created a <em>repository</em> within GitHub to test these tools.</p>
</section><section id="chapter02"><h1><a class="self-ref" id="chapter02-creating-a-simple-web-server" href="#chapter02-creating-a-simple-web-server"># </a>Creating a simple web server</h1>
<p>NodeJS has been designed to be used primarily in web sites so creating a web server is pretty easy. In many other languages such as PHP we would need to have a web server, such as <a href="https://httpd.apache.org/">Apache</a> plus the interpreter for <a href="http://www.php.net/">PHP</a>. Not so in NodeJS. The following code is all we need to start with:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const http = require('http');

const PORT = 8080;

const server = http.createServer();

server.on('request', (req, res) =&gt; {
  console.log(`Received request for ${req.url}`);
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.write('Hello World!\n');
  res.end(`Received request for ${req.url}`);
});

server.on('listening', (error) =&gt; {
  if (error) {
    console.error(error);
  } else {
    console.log(`Server running at http://localhost:${PORT}/`);
  }
});

server.listen(PORT);</code></pre></div>
<blockquote>
<p>All the code for the book is available at <a href="https://github.com/Satyam/book-react-redux">https://github.com/Satyam/book-react-redux</a> which includes <a href="https://github.com/Satyam/book-react-redux#sample-code-for-each-chapter">instructions</a> on how to see or download the code for any of the chapters. You can see the original of the segments of code included in this book by clicking on the <em>Octocat</em> <img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /> icon in the frame.  The Octocat is GitHub's mascot.</p>
</blockquote>
<p>NodeJS programs are made of <em>modules</em>, little bits of code that provide useful functionality.  NodeJS already offers a good number of such <a href="https://nodejs.org/docs/latest/api/index.html">modules</a>.  One of them is <code>http</code> and to load it we do:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">const http = require('http');</code></pre></div>
<p>We save a reference to that module in the <code>http</code> constant.  It is usual, though not required, to name the references to the modules after the name of the module itself.</p>
<p>We are using the <code>const</code> keyword instead of a simple <code>var</code> because we want to make sure we don't accidentally change its contents later on.  It might surprise C programmers because in in C constants are numeric or string literals.  In JavaScript any variable can contain anything, numbers, booleans, functions or full objects.  By declaring it as <code>const</code> we just mean that we want to protect it from accidental changes later on.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">const PORT = 8080;</code></pre></div>
<p><code>PORT</code> is more of a traditional constant in the C sense, a plain numeric value.  Following the regular convention, we use an all-uppercase name for it.  This is not mandatory, just a convention.  The <code>PORT</code> will be the part after the <code>:</code> in the URL:</p>
<p><code>http://localhost:8080</code></p>
<p>We might already have an active web server running on our machine which will be listening in the standard port number of 80.  We don't want to interfere with any existing web server so we put ours to listen on another port.  The low port numbers (below 1024) are mostly reserved for <a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports">well known services</a>.  It is customary to use 8080 for temporary test web servers.  If we get an error stating that the port is already in use, we can simply use some other number.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-js">const server = http.createServer();</code></pre></div>
<p>The <code>http.createServer</code>  function creates an instance of a web server, which we save into the variable <code>server</code> declared as a constant to keep it safe.</p>
<p>We want to know when our server receives any request, that is, a user has navigated to an URL on this web server.  So, we tell  the <code>server</code> that <code>on</code> receiving a <code>'request'</code> it should let us know.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L7-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">server.on('request', (req, res) =&gt; {
  console.log(`Received request for ${req.url}`);
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.write('Hello World!\n');
  res.end(`Received request for ${req.url}`);
});</code></pre></div>
<p>It will do so by calling the function we provide.  We are using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow functions</a> which were incorporated in ECMAScript 2015 or <em>ES6</em> as it is often called (<code>const</code> is also new to ES6). Basically, the two fragments below are more or less equivalent:</p>
<pre><code class="language-js">(req, res) =&gt; {

function (req, res) {
</code></pre>
<p>So, for each request our web server receives it will call our function providing it with two arguments, a request <code>req</code>, containing information about the request just received such as the URL (<code>req.url</code>) or the headers.  It also provides a response object <code>res</code> that allows us to return a response to the browser.</p>
<p>We use <code>res.writeHead</code> to start the reply to the browser by giving it the 200 HTTP response code for Ok, then we add one header to change the default <code>Content-Type</code> of <code>text/html</code>.  We want to send back plain text instead of HTML so we change it to <code>text/plain</code>.</p>
<p>With <code>res.write</code> we start sending the text we mean to show on the browser. The <em>response</em> object <code>res</code> will keep accepting text as long as we keep writing into it.  To tell it we are done we do a final call to <code>res.end</code>. We are using the same <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings">template string</a> as in the earlier <code>console.log</code> where we tell JavaScript to interpolate the value of <code>req.url</code> into the template.</p>
<p>We also want to know when the server becomes ready to start listening so we ask the <code>server</code> that <code>on</code> <code>'listening'</code>, it should let us know by calling the function we provide.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L14-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">server.on('listening', (error) =&gt; {
  if (error) {
    console.error(error);
  } else {
    console.log(`Server running at http://localhost:${PORT}/`);
  }
});</code></pre></div>
<p>This is also an <em>arrow function</em>. It receives an <code>error</code> argument which, if not null, will contain an error message, otherwise, it means the server is ready.</p>
<p>Finally we tell the <code>server</code> we want to <code>listen</code> on the given <code>PORT</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-01/server/index.js#L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-js">server.listen(PORT);</code></pre></div>
<p>If you clicked in any of the OctoCat <img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /> links above you might have noticed that they point  to highlighted lines or ranges of lines in the sample code in GitHub.  This is just one of many features in GitHub that makes it great when doing development in teams, we can use these links to talk about code with other people, as we are doing here.</p>
<p>We can run this brief script by typing <code>node server</code>.  Since <code>server</code> is a folder, NodeJS will try to run a file named <code>index.js</code>.  The program will soon print</p>
<p><code>Server running at http://localhost:8080/</code>.</p>
<p>Now, if we go to a browser and navigate to that URL, the server script will print:</p>
<pre><code>Received request for /
Received request for /favicon.ico
</code></pre>
<p>The first line is due to the URL we requested.  The second is because most modern browsers look for a file called <code>favicon.ico</code> at the root of the site, which it will use as the icon to associate with the site.</p>
<p>On the browser, we will see the reply from the server:</p>
<pre><code>Hello World!
Received request for /
</code></pre>
<p>We can add whatever we want to that URL and the server will report whatever else we asked after the site root.  Thus <code>http://localhost:8080/this/that?something=else</code> will produce:</p>
<pre><code>Hello World!
Received request for /this/that?something=else
</code></pre>
<p>By parsing and analyzing the URL and the rest of the information the <code>request</code> object provides we can respond in any way we want by sending back files, presumably HTML files or images, or assembling web pages on the fly.  Doing all these would be somewhat tiresome, like re-inventing the wheel.  Instead, in the next chapter, we will use a <em>package</em> which will do much of the work for us.</p>
<h2><a class="self-ref" id="chapter02-important-nodejs-features" href="#chapter02-important-nodejs-features"># </a>Important NodeJS features</h2>
<p>This simple example allows us to learn about some of the goodies that JavaScript and NodeJS gives us.</p>
<h3><a class="self-ref" id="chapter02-modules" href="#chapter02-modules"># </a>Modules</h3>
<p>NodeJS allows us to break up a big project into little pieces called <em>modules</em>, each a piece of JavaScript code that does very well a very simple thing.  This is great for working in teams because each individual can concentrate on a simple, well-defined module and not be concerned with anything beyond.  Even a single solitary developer benefits from Modules because it makes it easy to know where the various parts of a project go.  It also allows us to reuse the same code over and over again.</p>
<p>Modules are gathered into <em>packages</em>. NodeJS comes with NPM, its own package manager.  A public repository of packages <a href="https://www.npmjs.com/">npmjs.com</a> collects thousands of packages.  We will use one of those in the next chapter to improve on our web server.  <a href="https://www.npmjs.com/package/express">Express</a> is actually one of the most popular packages for NodeJS.</p>
<p>Let us have a look at the entry for <a href="https://www.npmjs.com/package/express">Express</a> in the NPM registry.  On the right hand there is a column with plenty of information. They are on a 4.xx version, which means it is a mature product that has gone through many major revisions. It has an MIT license meaning we can freely use it. There is a link to the GitHub repository <a href="https://github.com/expressjs/express">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> where we can find the source code and all the history of its development.  We can see that in the last month it had millions of downloads, which speaks of its popularity.</p>
<p>If we scroll further down, we can see a list of Dependencies and Dependents.  Here lies the beauty of packages and of the whole NPM ecosystem.  Each developer does something that depends on the code done by someone else and will see his/her own package used by others and depended upon by many other packages.</p>
<p>This is open source at its best.</p>
<h3><a class="self-ref" id="chapter02-event-loop" href="#chapter02-event-loop"># </a>Event loop</h3>
<p>Much of the efficiency and simplicity of NodeJS comes from the <em>event loop</em>. <em>Events</em> are simply things that happen.  We are used to events such as button clicks in the browser.  We don't know when or even if an event will happen, it is up to the user of the browser. This has proved a powerful concept in interfacing with the user.  Instead of prompting the user for information one piece at a time as we did in the age of teletypewriters (well, at least some of us did), we give the user freedom to interact with our pages in multiple ways and have our applications respond to that.</p>
<p>It seems a little bit of a stretch to extend this to the server, where there is no user, however, it works wonderfully well, as we've seen.  In our simple web server, we don't know when a request from a browser will come.  Thus, we tell our <code>server</code> that <code>on</code> receiving a <code>'request'</code> it should let us know.  Likewise, we don't know how long will it take to setup the server and get it ready to <code>listen</code> to requests so, we tell the <code>server</code> that <code>on</code> becoming ready to start <code>'listening'</code>, it should tell us.</p>
<p>This is thanks to the <em>event loop</em>. After initializing, NodeJS reads and executes the script and then enters what is called the <em>event loop</em>. If there is anything listening <code>on</code> something else, it just stays there waiting for that something to happen.  When an event happens, it notifies whomever it might concern by executing the function provided as a callback and loops back to the event loop.  While NodeJS is executing those callbacks, events get queued so on returning to the event loop NodeJS first checks the queue and processes the events queued in it.</p>
<p>NodeJS changes the way we do many other operations, for example, reading a file.  In most other languages, we have to open the file and read it.  When we tell the operating system (<em>OS</em>) to open the file, our application is temporarily frozen until the OS does get the file open and returns a handle.  Then, when we order the OS to read the file, our program gets frozen once again until the file is actually read and its contents made available somehow to our program.  NodeJS doesn't work like that (it can, but it is not encouraged).</p>
<p>In NodeJS, we tell the OS that we wish to have the file opened and tell it to let us know when it has complied.  Likewise, when we read from a file, we tell the OS to read the file for us and let us know when the chunk we have requested is available.  Our program is never frozen. Once we place our requests to the OS, we are free to continue doing something else or, most likely, go idle, allowing NodeJS to return to the event loop and see if something else has happened that might be of interest to some other application.</p>
<p>Contrast this to, for example, PHP.  It has the library functions to write a simple web server just like NodeJS but it cannot deal with concurrency, that is, multiple request coming from various sources.  It can easily do one at a time and, in principle, it seems NodeJS does the same.  However, there is a big difference. When the incoming request needs a file to be read, PHP freezes until the read operation is done and no other request can be processed.  NodeJS doesn't freeze, it simply returns to the event loop and allows other events to be processed, be them further HTTP requests or files read by previous requests that are still pending.  That is why PHP and so many other languages require complex environments such as an <a href="http://httpd.apache.org/">Apache web server</a> or Microsoft's <a href="https://www.iis.net/">IIS</a> to juggle with the various PHP processes each dealing with a single request.</p>
<h3><a class="self-ref" id="chapter02-callbacks" href="#chapter02-callbacks"># </a>Callbacks</h3>
<p>Unlike in most other languages, functions in JavaScript are just one more type of object and they can be assigned to variables, passed as arguments to functions and, of course, called.  This sits nicely with the event loop because that is the way to tell NodeJS or the browser what to do when an event happens.  We just give it a function.  Basically, we are saying &quot;when <em>this</em> happens, call me back&quot;. It is the kind of thing we would wish we could do when calling customer support; instead of listening to the &quot;All our customer support representatives are busy ... yada yada ...&quot; we let them know we need help and have them call us back. That is why we have <em>callback</em> functions.</p>
<p>In the code above, we have supplied both our event listeners with callback functions.  In one we print suitable messages depending on whether the server succeeded in listening to incoming requests, in the other we process those requests.</p>
<p>In other languages, for example, Java, we cannot use functions so freely because we cannot pass functions as arguments.  Instead we have to define a class which implements a particular interface that declares a method which will be called when the event occurs, then we pass the whole class instance to the event listener.  Sounds complicated?  Well, you get used to it, but the JavaScript way is so much easier!  And since ES6 and its <em>arrow functions</em> it is even easier.  In JavaScript, when we need a function, we write it right there.</p>
<h3><a class="self-ref" id="chapter02-chaining" href="#chapter02-chaining"># </a>Chaining</h3>
<p>Functions don't always return values.  In other languages we had <em>functions</em>, which always return some value, and <em>subroutines</em> or <em>procedures</em> which we call (often using the <code>call</code> statement) to do something, but that don't return anything.</p>
<p>In JavaScript there are only functions and they always return something, even if that something is <code>undefined</code>.  Someone, and I think it was John Resig in jQuery, thought that returning <code>undefined</code> was a waste so all the methods (functions in object instances) that have nothing better to return will return a reference to itself.
In our sample web server, we call several functions within the <code>server</code> instance (that is, <em>methods</em>) and never use any return from those functions.  Actually, all those functions return a reference to the same object they belong to.</p>
<p>Using those references to the very same object they belong to allow for what is called <em>chaining</em> where we can chain one function call right after the other.</p>
<p>We can see this in action in the following example:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-02/server/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-02</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const http = require('http');

const PORT = 8080;

http.createServer()
  .on('request', (req, res) =&gt; {
    console.log(`Received request for ${req.url}`);
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.write('Hello World!\n');
    res.end(`Received request for ${req.url}`);
  })
  .on('listening', (error) =&gt; {
    if (error) {
      console.error(error);
    } else {
      console.log(`Server running at http://localhost:${PORT}/`);
    }
  })
  .listen(PORT);</code></pre></div>
<p>It is our very same web server changed to use chaining.  First thing to notice is that we are no longer declaring a variable <code>server</code>.  The <code>http.createServer()</code> function already returns an instance of an HTTP server and all the functions, such as <code>on</code>, that would otherwise have nothing better to return, keep returning references to the same HTTP server instance they belong to.  We have chained several operations one after another to the same instance.</p>
<p>Good styling dictates that when doing chaining the chained functions (<code>.on</code> or <code>.listen</code>) to start with the dot on a separate line indented one position from the original source of the object instance.  All functions chained to the same object should be at the same depth.  Also note that there are no semicolons at the end of the chained functions because otherwise the statement would be finished and the object reference lost.</p>
<p>You might expect <code>res</code> to be similarly chainable but, unfortunately it is not. the <code>write</code> method does return information while the other two used here return <code>undefined</code>, which is a waste.</p>
<h2><a class="self-ref" id="chapter02-and-finally" href="#chapter02-and-finally"># </a>... and finally</h2>
<p>We can shorten our code even more:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-03/server/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-02-03</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const http = require('http');

const PORT = 8080;

http.createServer((req, res) =&gt; {
    console.log(`Received request for ${req.url}`);
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.write('Hello World!\n');
    res.end(`Received request for ${req.url}`);
  })
  .listen(PORT, () =&gt; {
    console.log(`Server running at http://localhost:${PORT}/`);
  });</code></pre>:</div>
<p>Subscribing to the <code>request</code> and <code>listening</code> events is such a frequent thing to do that the developers of the <code>http</code> module have made it easier, we just pass the request handler function to the <code>createServer</code> method and the <code>listening</code> callback to the <code>listen</code> method.  Also, we don't actually need to check for the <code>error</code> argument because most of the errors at that stage simply produce fatal errors and the application will terminate before we have any chance to do something about it.</p>
<h2><a class="self-ref" id="chapter02-summary" href="#chapter02-summary"># </a>Summary</h2>
<p>We have seen how easy it is to have a web server up and running using plain NodeJS without any extras, which is due to several features built into NodeJS, such as its <em>module</em> system, and, most important of all, the <em>event loop</em>.</p>
<p>We have also seen some standard coding practices such as the use of <em>callbacks</em> and <em>chaining</em>.</p>
</section><section id="chapter03"><h1><a class="self-ref" id="chapter03-npm-packages" href="#chapter03-npm-packages"># </a>NPM Packages</h1>
<p>So far we have written a very primitive web server and we could go on and make it really useful, but that would be a real waste of effort to repeat standard behavior and we don't want to re-invent the wheel.  Instead, we will use one of NPM's most popular packages, <a href="https://www.npmjs.com/package/express">Express</a>.</p>
<p>We also want to keep a record of what packages we install for our application so that anyone else can set it up in the same way.  NPM uses a file called <code>package.json</code> to do that.</p>
<p>To create our <code>package.json</code> file, we go to the root of our project and type <code>npm init</code> and answer a few questions.  It is not crucial that we answer them right the first time, the file is editable and we can change much of it later on.  NPM will offer defaults for each answer which we might accept by pressing <kbd>Enter</kbd> so, if you are not sure about something, simply accept what NPM offers.</p>
<p>NPM knows about Git and GitHub so it will link to the repository created in chapter 1.  It also adds an entry for bug tracking:</p>
<pre><code class="language-json">&quot;bugs&quot;: {
  &quot;url&quot;: &quot;https://github.com/Satyam/book-react-redux/issues&quot;
},
</code></pre>
<p>Bug tracking is one of many extras offered by GitHub beyond serving Git requests.  In the current version of GitHub, a series of tabs at the top of the page allow you to access several features of any project.  So far we have seen the <code>Code</code> tab but there are several others such as <code>Issues</code>, <code>Wiki</code> or <code>Graphs</code> that are very useful.  The <code>Settings</code> tab allows us to decide which of these features we want in our repositories.</p>
<p>The <code>package.json</code> file is in <a href="http://www.json.org/">JSON</a> format, a data -interchange format first devised by Douglas Crockford and now an ECMA standard. The file is made of simple text so it is editable.  Open it up to have a look at it.  You will easily find out where most of the responses you provided to <code>npm init</code> have gone.</p>
<p>Now we may fix some of them.  NPM suggests version <code>1.0.0</code>.  Those numbers follow the <a href="http://semver.org/">semver</a> <em>semantic versioning</em> standard. The first number is called the <em>major version</em>.  A major version of 1 at this point would be somewhat presumptuous from us since it would suggest it is a finished product in its first release.  We can change that to <code>0.1.0</code> or something like that.  A major version of 0 clearly states that it is still a prototype.</p>
<h2><a class="self-ref" id="chapter03-running-the-script" href="#chapter03-running-the-script"># </a>Running the script</h2>
<p>Something else we might want to change is the <code>&quot;main&quot; : &quot;index.js&quot;</code> entry.  That came from the prompt <code>entry point: (index.js)</code>.  Lets change it to <code>&quot;main&quot; : &quot;server/index.js&quot;</code>. Save the change and go to a terminal/ command prompt and type <code>node .</code>.  The server will now be started.  Originally, we had to do <code>node server</code> or <code>node server/index.js</code>.  When given a folder instead of a full file name, NodeJS actually looks first for a file called <code>package.json</code> for the <code>main</code> entry and if it doesn't find it, only then it goes searching for an <code>index.js</code> which is what we've been doing so far.  Now that we do have a <code>package.json</code> we can let NodeJS find it for us.  Note the dot at the end of <code>node .</code>, otherwise, NodeJS runs in interactive mode and prompts us for input.</p>
<p>The main entry point declared in <code>package.json</code> is mostly used for libraries, that is, when your code is meant to be depended upon, not when doing an application.  To start running an application, it is much better to use the <code>scripts.start</code> property.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-01/package.json#L6-L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
},</code></pre></div>
<p>The <code>npm init</code> command already created a <code>scripts.test</code> property which we will use later on.  We simply add the <code>start</code> entry whose value is the command to start the server.  Then we can do:</p>
<pre><code class="language-bash">npm start
</code></pre>
<p>and the server will start.  Using the <code>npm start</code> command for running applications is  the recommended way. Most developers, when looking at your application, on seeing a <code>package.json</code> file will expect to find the command to start your application there.</p>
<p>Actually, <code>npm start</code> is a shortened form of <code>npm run start</code>. The <code>npm run xxxx</code> command will look for a <code>xxxx</code> property in the <code>scripts</code> object and execute the string it finds there. Doing <code>npm run</code> without any extra arguments will list all the available scripts. Only a few of them have shortened forms: <code>npm start</code>, <code>npm restart</code>, <code>npm stop</code> and <code>npm test</code>.</p>
<p>There are also a series of <em>pre</em> and <em>post</em> entries that, if found, will be executed automatically before and after some other commands are run.  You can check them out in the <a href="https://docs.npmjs.com/misc/scripts">NPM manual</a>.</p>
<p>There is an extra benefit of running commands from NPM.  All of the information in the <code>package.json</code> file will be available to the program being run with the <code>npm_package_</code> prefix with underscores instead of dots separating the properties.  For example, you can read <code>npm_package_version</code> or <code>npm_package_scripts_start</code>.</p>
<p>You can freely add your own properties though, to avoid conflicts with existing options, it is better to use your own property object name. The <code>config</code> property already exists so avoid using that one.  Existing properties are all lowercase so mixing some uppercase characters is a good idea, for example:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-01/package.json#L10-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 10</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-json">"myWebServer": {
  "port": 8080
},</code></pre></div>
<p>Our server program can now have:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-01/server/index.js#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">const PORT = process.env.npm_package_myWebServer_port || 8080;</code></pre></div>
<p>This will allow other team members to easily find configuration options without having to go looking into the source files.</p>
<h2><a class="self-ref" id="chapter03-installing-dependencies-express" href="#chapter03-installing-dependencies-express"># </a>Installing dependencies: Express</h2>
<p>As mentioned earlier, NodeJS comes with some packages pre-installed such as <code>http</code> which we have used earlier.  For extra packages, we have to use NPM to install them.  For <a href="https://www.npmjs.com/package/express">Express</a>, we do:</p>
<pre><code class="language-bash">npm install express --save
</code></pre>
<p>The command <code>npm install</code> will look for the package name in the <a href="https://www.npmjs.com/">NPM registry</a> and, if found, download and install it. The name given in the command should be exactly as in the heading of the entry in the NPM registry for Express it should be <a href="https://www.npmjs.com/package/express">express</a>.  The <code>--save</code> option instructs the installer to save the reference to that package in our <code>package.json</code> file.  If we take a look at it, we may see that it now has the following added:</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;express&quot;: &quot;^4.13.4&quot;
}
</code></pre>
<p>This is how NPM keeps track of the extra modules it loads, it means that our app needs the <code>express</code> package version <code>4.13.4</code> or higher up to, but not including, any <code>5.y.z</code>.  Changes in the major version usually mean there might be some incompatible changes with the previous one so, once you program for a particular major version, you want to keep within that one.</p>
<p>Once the <code>npm install</code> command finishes, it shows what it has done, listing the module it has downloaded plus all its dependencies.  Each entry contains the registered name of the package and the version it has actually installed.</p>
<p>Now you will find an extra folder in your project called <code>node_modules</code> and inside it, a folder called <code>express</code>.  That is where the downloaded package has gone.  Each package will also have its own <code>package.json</code> file and its <code>node_modules</code> folder with its dependencies, each of which will have its <code>package.json</code> file and its <code>node_modules</code> and so on.</p>
<p>Let us add some other packages.  The following are optional sub-modules of Express itself which we will use later on.  Do:</p>
<pre><code class="language-bash">npm install body-parser --save
npm install cookie-parser --save
</code></pre>
<p>The <code>package.json</code> file will now show more dependencies:</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;body-parser&quot;: &quot;^1.15.0&quot;,
  &quot;cookie-parser&quot;: &quot;^1.4.1&quot;,
  &quot;express&quot;: &quot;^4.13.4&quot;
}
</code></pre>
<p>and the <code>node_modules</code> folder will contain a folder for each of those extra packages.</p>
<p>One of the benefits of the <code>package.json</code> files is that it records all the dependencies so that anyone can recall them.  Lets go and delete the <code>node_modules</code> folder. Now, we don't have any of the dependencies. However, we still have the <code>package.json</code> file so we can reestablish all the dependencies.  If we now do:</p>
<pre><code class="language-bash">npm install
</code></pre>
<p>with no extra arguments, NPM looks into the <code>package.json</code> file and installs all the dependencies listed in it.</p>
<h2><a class="self-ref" id="chapter03-installing-developer-dependencies-eslint" href="#chapter03-installing-developer-dependencies-eslint"># </a>Installing developer dependencies: ESLint</h2>
<p>The <a href="https://www.npmjs.com/">NPM registry</a> not only contains many packages we can use in our application, it also contains plenty of packages that can help us in the development process.  We will install one such utility: <a href="http://eslint.org/">ESLint</a>.   A <em>linter</em> is a sort of compiler that doesn't actually produce any code, instead, it checks the syntax of the code to warn us of any possible errors and may check style, such as whether the indentation for each line is right.  ESLint is such a <em>linter</em> for <strong>E</strong>CMA<strong>S</strong>cript, thus ESLint.</p>
<p>ESLint is the third generation of linters for JavaScript.  The first one, <a href="http://www.jslint.com/">JSLint</a> was written by the same Douglas Crockford that gave us JSON. However, it had always been a very opinionated product.  It has a limited number of options and many rules are fixed to follow Crockford's preferences, admitting no alternatives.  A more customizable <a href="http://jshint.com/">JSHint</a> followed years later and ESLint, by Nicholas Zakas, is the newest and, by far, the most customizable and flexible of the lot.</p>
<p>Do:</p>
<pre><code class="language-sh">npm install eslint --save-dev
</code></pre>
<p>We have used the <code>--save-dev</code> option instead of simply <code>--save</code>.  This means that this package dependency is meant to help us in development, not for the final product. Using the <code>--production</code> option when doing <code>npm install</code> will not install them (the default is to install all dependencies). In <code>package.json</code> we now have:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/package.json#L35-L40"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 35</div>
    <div class="to">To: 40</div>
  </div>
  <pre><code class="language-json">"devDependencies": {
  "eslint": "^2.7.0",
  "eslint-config-standard": "^5.1.0",
  "eslint-plugin-promise": "^1.1.0",
  "eslint-plugin-standard": "^1.3.2"
}</code></pre></div>
<p>Let us go and add another script <code>lint</code> to <code>package.json</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/package.json#L6-L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "lint": "eslint . || exit 0",
  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
},</code></pre></div>
<p>If we now do:</p>
<pre><code class="language-sh">npm run lint
</code></pre>
<p>We will get one fatal error message on the first <code>const</code> because it is an ES6 keyword and ESLint cannot parse it with its default rules. To find  why there is that <code>|| exit 0</code> after the <code>eslint .</code> command simply delete it and run it again.</p>
<p>To tell ESLint what we want it to do we need to add a <em>rules</em> file.  We can write one of our own or pick one of several standard ones available in the NPM registry, for example:</p>
<pre><code class="language-sh">npm install eslint-config-standard --save-dev
</code></pre>
<p>Though this ESLint rule set is named <code>standard</code> there is no actual standard backing it.  It is a reasonable compilation of many often-used rules but it is not endorsed by any standards body or group.  However, it wouldn't be bad if it were.</p>
<p>This downloads and installs the rules, but it does not tell ESLint that it should follow them.  There are various ways to do that.  In this book we will  add a configuration file <code>.eslintrc.json</code>  containing:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: .eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "extends": "standard",
  "env": {
    "node": true
  },
  "rules": {
    "semi": [1, "always"]
  }
}</code></pre></div>
<p>This tells ESLint that</p>
<ul>
<li>our rules will be an extension of those in <code>eslint-config-standard</code> (the <code>eslint-config</code> prefix can be omited)</li>
<li>that our code is meant to be executed by NodeJS, which helps it make some assumptions about features we will use</li>
<li>that we will customize those same rules by requiring that <a href="http://eslint.org/docs/rules/semi.html">semicolons are always present</a> at the end of statements.</li>
</ul>
<p>There are very many <a href="http://eslint.org/docs/rules/">rules</a> that really allow us to customize our code in any way we want.  Many companies have their internal standards available in the NPM registry, just search for <a href="https://www.npmjs.com/search?q=eslint-config">eslint-config</a> and, at the time or writing this, almost five hundred of such rules are listed.</p>
<p>Though we are using the <code>.json</code> extension on the  ESLint configuration files, ESLint  can do without the extension, figuring out the internal format from reading the contents. It can actually accept files in YAML format instead of JSON and it is quite relaxed about what it accepts as JSON.</p>
<p>Now we can repeat the <code>npm run lint</code> command and it should show no errors.  Change the <code>server/index.js</code> file making some errors and lint it again to see the effect.</p>
<p>Both Brackets and Atom have plugins to have ESLint integrated into the editor window.</p>
<p>JavaScript can manage without semicolons at the end of its statements, it is what is called ASI, <em>Automatic Semicolon Insertion</em>.  It has become fashionable to write code without semicolons and let JavaScript figure out when a statement ends.  It was originally designed to make it more forgiving to sloppy first time coders and it works quite well, but it implies some degree of guessing from the JavaScript interpreter and I don't like ambiguities. Anyway, I can't imagine what could I possibly do in a life already full of much reveling and frolicking with the half a minute or so a day I could shave off my coding time by skipping the semicolons.</p>
<h2><a class="self-ref" id="chapter03-global-installs-eslint" href="#chapter03-global-installs-eslint"># </a>Global installs: ESLint</h2>
<p>Usually, ESLint is installed <em>globally</em> to make it accessible directly as a command in your terminal/command prompt window.  We haven't done it this way to avoid polluting our global space.  <em>Global</em> in NPM parlance means it is installed in a way that can be shared in between all applications within our computer.  It also saves some disk space since only one copy of it is needed for all apps instead of one for each.</p>
<p>To install applications <em>globally</em> we use the <code>-g</code> option on <code>npm install</code> and we don't use the <code>--save</code> or <code>--save-dev</code> options because we don't actually want it listed on our <code>package.json</code> file.  Thus, we would do:</p>
<pre><code class="language-bash">npm install -g eslint
npm install -g eslint-config-standard
</code></pre>
<p>These two commands will install both ESLint and the <code>standard</code> set of rules in a shared folder (<code>/usr/lib/node_modules</code> for Linux users).  We can still have a <code>.eslintrc.json</code> file in our home folder (<code>~/.eslintrc.json</code>) with our preferences so that we can use the <code>eslint .</code> command right from the terminal in any project and check anything anywhere with our home set of rules.</p>
<p>We can still set per-project rules by creating a local <code>eslintrc</code> file extending our own defaults plus adding our own, as we already did:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/.eslintrc.json#L2"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: .eslintrc.json</div>
    <div class="from">From: 2</div>
    <div class="to">To: 2</div>
  </div>
  <pre><code class="language-json">"extends": "standard",</code></pre></div>
<p>ESLint configuration files can go on forever extending one another with the later rules overriding the previous settings.</p>
<h2><a class="self-ref" id="chapter03-ignored-files" href="#chapter03-ignored-files"># </a>Ignored files</h2>
<p>Looking at our GitHub repository <a href="https://github.com/Satyam/book-react-redux/tree/chapter-03-02">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> once we committed and pushed all these changes, we can see that there is no <code>node_modules</code> folder, which is a good thing since, at this point, it has about 17MB of data and it makes no sense to put a copy of all that in GitHub.  After all, the <code>npm install</code> command can easily reconstruct it from the dependencies listed in <code>package.json</code>.</p>
<p>That trick is thanks to the <code>.gitignore</code> file which is a list of file patterns of files and/or folders that Git should ignore, with comments preceded by sharp <code>#</code> signs.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-02/.gitignore"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-02</div>
    <div class="filename">File: .gitignore</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-"># Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directory
# https://www.npmjs.org/doc/misc/npm-faq.html#should-i-check-my-node_modules-folder-into-git
node_modules</code></pre></div>
<p><code>node_modules</code> is listed down at the end of the list.  This file was produced by GitHub when we originally created our repository and asked for a <code>.gitignore</code> file for <code>Node</code> which adds NodeJS-specific entries such as <code>node_modules</code>.</p>
<h2><a class="self-ref" id="chapter03-summary" href="#chapter03-summary"># </a>Summary</h2>
<p>We have seen how NPM, the Node Package Manager allows us to leverage thousands of NodeJS packages, in this case, to improve on our previous very basic web server.  We installed Express to add advanced features to our server.</p>
<p>NPM uses the <code>package.json</code> file to store its configuration and it also allows us to use it to store our own application configuration and the commands to start, test and run any script we might need to help in developing or running our application.</p>
<p>There are tools both to run our application as well as to help us develop it.  A <em>linter</em> is one such development tool.  It helps us check our code statically, that is just looking at the source without running it. We installed ESLint and some associated plugins and configurations, saw how this was recorded in <code>package.json</code> and added a script to run it.</p>
<p>Finally, we had a look at <code>.gitignore</code> and how it spares us from uploading unnecessary large volumes of data to GitHub.</p>
</section><section id="chapter04"><h1><a class="self-ref" id="chapter04-creating-an-express-web-server" href="#chapter04-creating-an-express-web-server"># </a>Creating an Express Web Server</h1>
<p>We will modify our previous web server <a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-03/server/index.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> to use Express:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-01/server/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const http = require('http');
const express = require('express');
const app = express();

const PORT = process.env.npm_package_myServerApp_port || 8080;

app.get('*', (req, res) =&gt; {
  console.log(`Received request for ${req.url}`);
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.write('Hello World!\n');
  res.end(`Received request for ${req.url}`);
});

http.createServer(app)
  .listen(PORT, () =&gt; {
    console.log(`Server running at http://localhost:${PORT}/`);
  });</code></pre></div>
<p>It really doesn't look that much different, we can actually see the difference <a href="https://github.com/Satyam/book-react-redux/commit/aecc6b2b8c800f3be18ab90ac1b03da4c1d63075#diff-0861d6d6b50d7d695344bf2d86d6e5e6">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> in GitHub.</p>
<p>First we load the Express package into the constant <code>express</code> and then create an instance of the Express server by running the default function in the package, which we store in <code>app</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-01/server/index.js#L2-L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 2</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">const express = require('express');
const app = express();</code></pre></div>
<p>That <code>app</code> will handle the requests for us.  When we call <code>createServer</code>, instead of providing a function to handle the <code>'request'</code> event as we did before <a href="https://github.com/Satyam/book-react-redux/blob/chapter-02-03/server/index.js#L5">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we let the Express request handler <code>app</code> to do it for us:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-01/server/index.js#L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-js">http.createServer(app)</code></pre></div>
<p>That allows us to use the <a href="http://expressjs.com/en/guide/routing.html">Express router</a>.  There are four basic methods in the <code>app</code> object that corresponds to HTTP request methods: <code>app.get</code>, <code>app.post</code>, <code>app.put</code> and <code>app.delete</code>. These methods register a callback function to listen to a particular type of request. Each gets as its arguments the path they should respond to and the function to call back when the path is matched.</p>
<p>Here, we have used <code>app.get</code> which is the standard request you get when navigating to a URL.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-01/server/index.js#L7"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 7</div>
  </div>
  <pre><code class="language-js">app.get('*', (req, res) =&gt; {</code></pre></div>
<p>The first argument is a wildcard <code>'*'</code> which means we want to respond to a request for any URL, the second is the very same arrow function we used earlier.  It still receives the very same <code>req</code> and <code>res</code> objects as before, but greatly augmented with very many extra properties and methods.   Using those new methods, we could now write our callback function like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-02/server/index.js#L11-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-02</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">app.get('*', (req, res) =&gt; {
  console.log(`Received request for ${req.url}`);
  res.type('text')
    .status(200)
    .send(`Received request for ${req.url}`);
});</code></pre></div>
<p>The first thing to highlight is that the new methods are now chainable. The <code>type</code> method allows us to set the content type in a far easier way than <code>writeHead</code> did and likewise with <code>status</code>. Though the <code>send</code> method doesn't look that much different from <code>write</code> or <code>end</code> it is actually able to do some extra magic which we will use later on.</p>
<p>There is no limit to the number of routes you can register with the router.  We have added a couple of extra routes:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-02/server/index.js#L7-L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-02</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-js">app.get('/hello', (req, res) =&gt; res.send('Hi, long time no see!'));

app.get('/bye', (req, res) =&gt; res.send('See you later'));</code></pre></div>
<p>Now, if we navigate to <code>http://localhost:8080/hello</code> we will get <code>Hi, long time no see!</code> and if we go to <code>http://localhost:8080/bye</code> we get <code>See you later</code>. Since we haven't used neither <code>type</code> or <code>status</code>, Express will assume the default <code>text/html</code> content type and a 200 response status code. Since now the reply is HTML, the browser will show it in a different typeface than it did with the <code>text/plain</code> response.</p>
<p>The syntax of the new ES6 arrow functions allows us to write the callback far more succinctly than before.</p>
<p>Whatever other URL we navigate to, it will fall through to the wildcard response. Express matches the routes in the order they are registered so we should never put a the wildcard first because it would then match all requests and never reach the other responses.  We will rarely use such a catch-all wildcard route except for diagnostics.  The Express router will reply with a regular <code>404 Not Found</code> page if no route matches the requested URL.</p>
<p>The router also supports a <a href="http://expressjs.com/en/guide/routing.html#route-paths">limited form</a> of regular expressions.</p>
<h2><a class="self-ref" id="chapter04-request-parameters" href="#chapter04-request-parameters"># </a>Request parameters</h2>
<p>It would be impossible to plan for routes matching all possible queries with variable parts.  Express allows for parameters within the routes.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-03/server/index.js#L7"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-03</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 7</div>
  </div>
  <pre><code class="language-js">app.get('/hello/:name?', (req, res) =&gt; res.send(`Hi ${req.params.name}, long time no see!`));</code></pre></div>
<p>A segment of a path with a leading colon <code>:</code> and up to the next slash <code>/</code> represents a parameter. Express will accept anything in that position and will save it in the <code>req.params</code> object under the given parameter name.  The above will match <code>http://localhost:8080/hello/John</code> and reply with <code>Hi John, long time no see!</code>, however it will not match our previous <code>http://localhost:8080/hello</code> because there is no <code>/:name</code> parameter.  Parameters must be there for the route to match. However, a question mark <code>?</code> after the parameter name makes it optional.</p>
<p>Express will also accept any mix of fixed and variable parts:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-03/server/index.js#L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-03</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 9</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-js">app.get('/elect/:fname/:lname?/for/:position', (req, res) =&gt; res.send(req.params));</code></pre></div>
<p>With such a route, navigating to <code>http://localhost:8080/elect/joe/doe/for/mayor</code> will produce <code>{&quot;fname&quot;:&quot;joe&quot;,&quot;lname&quot;:&quot;doe&quot;,&quot;position&quot;:&quot;mayor&quot;}</code> and it will also accept <code>http://localhost:8080/elect/joe/for/mayor</code> resulting in <code>{&quot;fname&quot;:&quot;joe&quot;,&quot;position&quot;:&quot;mayor&quot;}</code>. The <code>send</code> method is smart enough to convert the <code>req.params</code> object to JSON when sending it.</p>
<p>Express will also look for query parameters (the part of the URL after the question mark). Query parameters do not affect the route.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-03/server/index.js#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-03</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-js">app.get('/search', (req, res) =&gt; res.send(`You are searching for "${req.query.q}"`));</code></pre></div>
<p>In response to <code>http://localhost:8080/search?q=whatever</code>, it will respond with <code>You are searching for &quot;whatever&quot;</code>.  In response to <code>http://localhost:8080/search</code> it will reply <code>You are searching for &quot;undefined&quot;</code>.</p>
<p>Express cannot retrieve the part of the URL after the hash <code>#</code> mark since browsers do not send that to the server but handle it locally once the page has arrived.</p>
<h2><a class="self-ref" id="chapter04-using-middleware" href="#chapter04-using-middleware"># </a>Using Middleware</h2>
<p>The functionality offered by Express can be extended via <em>middleware</em>. Only one comes prepackaged, <a href="http://expressjs.com/en/4x/api.html#express.static"><code>express.static</code></a>:</p>
<pre><code class="language-js">app.use(express.static(path.join(__dirname, '../public')));
</code></pre>
<p>We are telling Express to <code>use</code> the <code>express.static</code> middleware which should serve static files from the <code>/public</code> folder within our project folder.  Middleware is registered in Express just like routes so the order is important. In general, our dynamic responses have to go first, otherwise Express might assume they are file requests.  Only if no route matches should Express look for static files.</p>
<p>The <code>path.join</code> function is part of NodeJS but it is not loaded by default so we had to add <code>const path = require('path');</code> to make it available.</p>
<p>We have dropped the wildcard route at the end of the list of routes because we are now serving actual files for everything but our matched routes or returning a <code>404 Not Found</code> error otherwise.  We now have a home page at <code>/public/index.html</code> <a href="https://github.com/Satyam/book-react-redux/tree/chapter-04-04/public">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. We could also put a <code>favicon.ico</code> there so it gets shown in the address bar.</p>
<p>We will add more middleware to our server which we first load:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L5-L6"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 6</div>
  </div>
  <pre><code class="language-js">const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');</code></pre></div>
<p>and then use:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L12-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 12</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">app.use(bodyParser.urlencoded({extended: false}));
app.use(cookieParser());</code></pre></div>
<p>Unlike the <code>express.static</code> middleware, we put these two before our dynamic routes because we want them to have the request processed for any request. They don't send anything back to the browser. They act like filters, pre-processing the information received before it gets acted upon.</p>
<p>So far we have only dealt with HTTP GET requests and the information that comes encoded in the URL itself.  <a href="https://github.com/expressjs/body-parser#body-parser"><code>body-parser</code></a> allows us to access the information sent in the body of the request. When there is information sent in the body and it can be decoded, <code>body-parser</code> will populate the <code>req.body</code> object.</p>
<p>The body can be sent encoded in various ways and the <code>body-parser</code> middleware provides several decoders.  The original middleware tried to figure out how the body was encoded and produce some sort of result, which wasted processing time.  Now, we have to explicitly state which parser to use.  All parsers can be added and each will give it a try in turn. If a filter fails, it doesn't reject a request, it simply lets it pass through so other filter, if there is any other one after, can try.</p>
<h2><a class="self-ref" id="chapter04-reading-data-from-a-form" href="#chapter04-reading-data-from-a-form"># </a>Reading data from a form</h2>
<p>Our home page now has a form with a single input field in it:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/public/index.html#L10-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: 10</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-html">&lt;form method="post" action="form"&gt;
  &lt;input name="field1"/&gt;
&lt;/form&gt;</code></pre></div>
<p>The value of that field will be posted to the <code>/form</code> path, where we can read it:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 23</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">app.post('/form', (req, res) =&gt; res.send(`You have entered "${req.body.field1}"`));</code></pre></div>
<p>Here we have used <code>app.post</code> instead of <code>app.get</code> as we've done so far since that is the method declared in the <code>&lt;form method=&quot;post&quot;&gt;</code> tag.</p>
<p>Middleware can also be restricted to respond to specific routes.  For example, all our data <em>post</em>s and <em>put</em>s will go in JSON to the <code>/data</code> route so we limit our decoding to just that route leaving the rest to be url-decoded:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-js">app.use('/data', bodyParser.json());</code></pre></div>
<p>We have also added the <a href="https://github.com/expressjs/cookie-parser"><code>cookie-parser</code></a> middleware which reads the cookies we might have sent in earlier responses via <a href="http://expressjs.com/en/api.html#res.cookie"><code>res.cookie</code></a> and makes them available in the <code>req.cookies</code> object.</p>
<p>We now have the <code>http://localhost:8080/cookie</code> path to read and increment the <code>chocolateChip</code> cookie count and <code>http://localhost:8080/naughtyChild</code> to clear it.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L25-L36"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-04-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 25</div>
    <div class="to">To: 36</div>
  </div>
  <pre><code class="language-js">app.get('/cookie', (req, res) =&gt; {
  var chocolateChips = parseInt(req.cookies.chocolateChip || 0, 10);
  res
    .cookie('chocolateChip', chocolateChips + 1)
    .send(`I now have ${chocolateChips} chocolate chip cookies`);
});

app.get('/naughtyChild', (req, res) =&gt; {
  res
    .clearCookie('chocolateChip')
    .send('No cookies for you');
});</code></pre></div>
<h2><a class="self-ref" id="chapter04-summary" href="#chapter04-summary"># </a>Summary</h2>
<p>We have seen how to create an Express server and tell it how to respond to various URLs and how to read extra query parameters.</p>
<p>We have also learned about <em>middleware</em> how to load it and use it in our web server.  We've seen how to load and use the body and cookie parser middleware besides the built int <em>static</em> middleware.</p>
<p>We have used the body parser middleware to be able to decode information received from an HTML form and manipulated information in <em>cookies</em> via the cookie parser.</p>
</section><section id="chapter05"><h1><a class="self-ref" id="chapter05-rest" href="#chapter05-rest"># </a>REST</h1>
<p>Representational State Transfer, <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> is the standard way in which plain data, that is, not formatted for human consumption, is requested and transfered in the Web.</p>
<p>Every piece of data in the web can have an URL (or more precisely an URI, but we won't dwell on the difference) and from previous chapters, we know how we can respond to any URL our server receives.</p>
<p>Once we identified the data, we need to tell the server what to do with it. We have the HTTP request codes for that.  In data handling terms we have four basic operations known by their initials: Create, Read, Update and Delete (CRUD).  These map one to one with the HTTP request methods we've already mentioned though, unfortunately, they don't result in any acronym we could use:</p>
<ul>
<li>Create: POST</li>
<li>Read: GET</li>
<li>Update: PUT</li>
<li>Delete: DELETE</li>
</ul>
<p>So, if we do a GET to our server for, say, <code>/employees</code> we will get a list of all employees, but if we ask for <code>/employees/123435</code> we will get more detailed information about an employee with that record number.  If we POST an employee record to <code>/employees</code> it means we want to create a record for a new hire.  The server will respond with the record number it assigned to that employee (assuming, as it is often the case, that it is the server that assigns the record identifier). If we do a DELETE on <code>/employees/123435</code> that record would be deleted while if we do a PUT along some information, for example, a new home address because the employee has moved, the record for that employee would get updated.  In theory this scheme can be stretched to absurd limits <code>/employees/12345/lname/2</code> might mean the second character of the last name of that particular employee which just serves to show how generic and flexible URIs can be though it would be impractical to stretch it that far.</p>
<p>REST requests can be further qualified with query parameters.  For example, a GET on <code>/employees?search=lname%3DSmith</code> instead of bringing up the list of all employees, it would only return the results of performing the database search for employees whose last name is Smith: <code>lname=Smith</code> (the <code>%3D</code> is the url-encoding of the equals sign).</p>
<p>We might handle further qualifiers, for example, <code>/employees?search=lname%3DSmith&amp;fields=fname,ZIPcode</code> would return the names and postal codes for all the Smiths in the database.</p>
<p>It is also important to know who is asking for the information.  Nobody wants their salaries disclosed to just about anyone.  So, beyond what the URL says, the server has to decide whether someone can access or change some particular piece of information.  Usually this is done through <em>cookies</em>.  In the previous chapter we have already seen how to deal with cookies <a href="https://github.com/Satyam/book-react-redux/blob/chapter-04-04/server/index.js#L25-L36">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> using the <code>cookie-parser</code> middleware.  After the user is positively identified (logs in) we send as a cookie some temporary token that allows us to recognize that user during one particular session, and know his/her permissions.</p>
<p>Defining what URLs we support and the expected responses is a very important part of defining a project.  Many large web services companies have very well defined public APIs, for example <a href="https://developer.github.com/v3/repos/">GitHub</a> or <a href="https://developers.google.com/gmail/api/v1/reference/">Google</a>, though some might adopt some <a href="http://wiki.freebase.com/wiki/Mql">proprietary format</a>.</p>
<p>Defining our API also allows us to split the responsibility of the project in between separate people, the server-side team dealing with responding to these requests and the client-side team taking care of requesting and presenting this information to the user and translating the user commands into server requests. The REST API is the contract in between these two teams.</p>
<h2><a class="self-ref" id="chapter05-defining-our-rest-api" href="#chapter05-defining-our-rest-api"># </a>Defining our REST API</h2>
<p>First, we have to separate our data requests from any other request our web-server might have to serve. Thus, the root for all our data requests will be <code>/data</code>.  This doesn't mean we have to create a folder of that name, it is simply a path our server will respond to.</p>
<p>Occasionally, it is a good idea to reflect on our own fallibility. We might get things wrong and if we define our API too rigidly, we might get in trouble. To be able to change our API in the future it is better to include a version number in our API requests so, if we ever have to change it, we change the version number. For a certain time, we can respond to requests in either format, both versions coexisting until everything gets updated and the old version finally gets dropped.  For this API we will then use the prefix <code>/data/v1</code>.</p>
<p>For our application, we will have a series of projects and for each project a series of tasks to perform.  This is just a twist on the popular TODO list application with one such TODO list for each of our projects.  This would be our API:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>URL</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><code>/projects</code></td>
<td>Returns a list of project ids, names and descriptions</td>
</tr>
<tr>
<td>GET</td>
<td><code>/projects/:pid</code></td>
<td>Returns the name and description of the given project and its list of tasks, providing their id, description and completion status</td>
</tr>
<tr>
<td>GET</td>
<td><code>projects/:pid/:tid</code></td>
<td>Returns the task id, description and completion status for a particular task within a particular project</td>
</tr>
<tr>
<td>POST</td>
<td><code>/projects</code></td>
<td>Accepts the name and description for a new project, returns project id</td>
</tr>
<tr>
<td>POST</td>
<td><code>/projects/:pid</code></td>
<td>Accepts the description and completion status for a new task for a given project, returns the id for the new task. Completion status defaults to false.</td>
</tr>
<tr>
<td>PUT</td>
<td><code>/projects/:pid/:tid</code></td>
<td>Updates the given task with the information in the body</td>
</tr>
<tr>
<td>DELETE</td>
<td><code>/projects/:pid/:tid</code></td>
<td>Deletes the given task</td>
</tr>
<tr>
<td>DELETE</td>
<td><code>/projects/:pid</code></td>
<td>Deletes the given project and all its tasks</td>
</tr>
</tbody>
</table>
<p>The REST standard doesn't really force you to do things in any particular way.  For example, deleting a project should also delete all existing tasks or should it fail if the task list is not empty?  When creating a new record, which fields are mandatory and which have defaults?  That behavior has to be described.</p>
<p>Optional query parameters should also be specified such as those that allow queries by field value or to enumerate the fields to be returned, as we commented earlier.</p>
<h2><a class="self-ref" id="chapter05-loading-sample-data" href="#chapter05-loading-sample-data"># </a>Loading sample data</h2>
<p>For the time being, we will store our information in memory.  This is certainly not practical for any real-life application, but it will help us concentrate on issues other than data storage. Our data comes from a JSON file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/data.json">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which we will read and keep in memory.</p>
<p>We need to load the <a href="https://nodejs.org/docs/latest/api/fs.html">File System</a> package which is included in the NodeJS distribution so we don't need to install it via NPM.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L6"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 6</div>
    <div class="to">To: 6</div>
  </div>
  <pre><code class="language-js">const fs = require('fs');</code></pre></div>
<p>We then use the <code>readFile</code> method to read the full file.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L10-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">fs.readFile(path.join(__dirname, 'data.json'), (err, data) =&gt; {
  if (err) {
    console.error(err);
    process.exit(1);
  }
  global.data = JSON.parse(data);</code></pre></div>
<p>To compose the pathname to the file we use the <a href="https://nodejs.org/docs/latest/api/path.html#path_path_join_path1_path2"><code>path.join</code></a> method in a similar way we did when we set the folder to fetch static content from.</p>
<p>The <code>readFile</code> method is asynchronous so we have to provide a callback for it to tell us when the read has succeeded.  In most NodeJS async methods, the first argument is an error object which, if it is not <code>null</code>, means the operation has not succeeded.  If that is the case, we show the error and exit.  Otherwise, the second argument <code>data</code> will contain the full contents of the file.  Since it is in JSON, we parse it and save it to <code>global.data</code>.</p>
<h2><a class="self-ref" id="chapter05-global-variables" href="#chapter05-global-variables"># </a>Global variables</h2>
<p>As it name implies, <a href="https://nodejs.org/docs/latest/api/globals.html"><code>global</code></a> is NodeJS global object, available everywhere, much as the <code>window</code> object is in a browser.  Every property of <code>global</code> is accessible just by name, for example, there is <code>global.setTimeout</code> just like there is a <code>window.setTimeout</code> in the browser and both can be called by its name, <code>setTimeout</code>, the global name being implicit.  We have already used a couple of such properties.  Both <code>__dirname</code> and, to some extent, <code>require</code> are properties of <code>global</code>.</p>
<p>We can make our own properties globally accessible just by setting them as properties of <code>global</code>, we just have to make sure we are not colliding with an existing property.  Since we are going to use the data we've just read everywhere, it makes sense to make it globally accessible.</p>
<p>ESLint will complain about using the global variable <code>data</code>.  ESLint knows about the standard, well-known global names for <a href="http://eslint.org/docs/user-guide/configuring#specifying-environments">whichever environment</a> we are working on, that is why we specified that our environment would be <code>node</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/.eslintrc.json#L3-L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: .eslintrc.json</div>
    <div class="from">From: 3</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-json">"env": {
  "node": true
},</code></pre>.</div>
<p>If there is anything beyond those globals, it will flag it as an <em>undeclared</em> variable, which usually signals a typo.  To prevent that, we add our own list of globals (for the time being just <code>data</code>) to <code>eslintrc.json</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/.eslintrc.json#L9-L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: .eslintrc.json</div>
    <div class="from">From: 9</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"globals": {
  "data": false
}</code></pre></div>
<p>The <code>false</code> value means we don't want this global variable written, only read.  This might sound strange, how do we set it if it is read-only?  When we set it we did <code>global.data = .... whatever</code>. ESLint doesn't mind us changing the <code>data</code> property of the <code>global</code> object, it would have complained if we did <code>data = ...</code> even though both amount to the same thing.</p>
<p>Our earlier server code has been trimmed of all those <code>app.get( ...</code> routes we had put there to try out different features, which we don't need any more.  There is another change that might pass unnoticed, the earlier code is now contained within the callback function <a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L11-L30">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  This is because only if and when we succeed reading the <code>data.json</code> file it makes any sense to start the web server.  It would make no sense to start it if there is no data to serve.</p>
<h2><a class="self-ref" id="chapter05-writing-a-module-to-respond-to-rest-requests" href="#chapter05-writing-a-module-to-respond-to-rest-requests"># </a>Writing a module to respond to REST requests</h2>
<p>The Express server has a default router which we have been using so far.  All those <code>app.get</code> we wrote earlier are registered with the default router which will dispatch each of the callbacks according to the full path in the URL received.  When we have many routes sharing the very same prefix, in this case <code>/data/v1</code>, it is inefficient (and boring) to repeat it over and over again.  For these cases we can create an additional router that will respond to that prefix and will deal with the rest of the path from that point on.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L19-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 19</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">const projectsRouter = express.Router();
  app.use('/data/v1/projects', projectsRouter);

  const projects = require('./projects.js');
  projects(projectsRouter);</code></pre></div>
<p>First, we request a new router instance from Express which we call <code>projectsRouter</code>.  We tell our instance of the Express server to <code>use</code> that router to deal with paths starting with <code>/data/v1/projects</code>.  Finally, we call <code>projects</code> and provide it with this router instance.</p>
<p>Where did <code>projects</code> came from?  It is a module we created ourselves. We loaded it right before we used it via:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-js">const projects = require('./projects.js');</code></pre></div>
<p>The <code>projects</code> come from the file <code>./projects.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which we created ourselves.  When the <code>require</code> function gets a module name starting with <code>.</code> or <code>/</code> it will not search for that module in the usual places ( NodeJS built-in library or <code>node_modules</code>) but will assume you are providing a full file name to a very specific file and load that one instead.</p>
<p>Loading modules in NodeJS is not the same as loading them in the browser via the <code>&lt;script&gt;</code> tag. In the browser, everything in the loaded file gets merged into whatever is already there, as if all those JavaScript files were concatenated together. This can get quite messy as all the variables declared in all files get into the same name space, possibly colliding with one another.</p>
<p>In NodeJS when you <code>require</code> another module, you only get to see whatever the loaded file exports.  In our sample, we export a <em>fat arrow</em> function which will receive our router instance.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">module.exports = (router) =&gt; {</code></pre></div>
<p>Since what we exported is a function, on the other side, we can execute it:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 23</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">projects(projectsRouter);</code></pre></div>
<p>For example, if we receive a request for <code>/data/v1/projects</code> the <code>projectsRouter</code> will recognize it is the path it is meant to respond to and pass on the implicit <code>/</code> at the end.  We then respond to the <code>/</code> path like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L5-L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-js">router.get('/', (req, res) =&gt; {
  res.json(Object.keys(data).map((pid) =&gt; ({
    pid: pid,
    name: data[pid].name,
    descr: data[pid].descr
  })));
});</code></pre></div>
<p>We use <code>Object.keys</code> list all the keys in the <code>data</code> object, which happen to be the <code>pid</code>s.  <code>Object.keys</code> returns an array and we use the <code>map</code> method of this Array instance.  We then use the <code>pid</code> to assemble each item in the response with the <code>pid</code> then the <code>name</code> and description <code>descr</code>.  Since <code>data</code> was set as a global earlier we can use it freely here.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L15"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 15</div>
  </div>
  <pre><code class="language-js">global.data = JSON.parse(data);</code></pre></div>
<p>We can use <code>res.send</code> instead of <code>res.json</code> since when Express is requested to send an Object or an Array, it will send it JSON-encoded.  However, it is better to state our intent as clearly as possible.</p>
<p>We can try it out by starting our server via <code>npm start</code> and then, in a browser go to <code>http://localhost:8080/data/v1/projects</code> which will show in our browser more or less like this:</p>
<pre><code class="language-json">[{&quot;pid&quot;:&quot;25&quot;,&quot;name&quot;:&quot;Writing a Book on Web Dev Tools&quot;,&quot;descr&quot;:&quot;Tasks required to write a book on the tools required to develop a web application&quot;},{&quot;pid&quot;:&quot;34&quot;,&quot;name&quot;:&quot;Cook a Spanish omelette&quot;,&quot;descr&quot;:&quot;Steps to cook a Spanish omelette or 'tortilla'&quot;}]
</code></pre>
<p>It might not look good but it is not meant to be seen by humans, it is meant for our client-side code to read.</p>
<p>For our second route <code>'/:pid'</code> we need to access the <code>pid</code> which we do by using <code>req.params.pid</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L13-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">router.get('/:pid', (req, res) =&gt; {
  const prj = data[req.params.pid];
  if (prj) {
    res.json(prj);
  } else {
    res.status(404).send(`Project ${req.params.pid} not found`);
  }
});</code></pre></div>
<p>If we find no actual project for that number, we respond with a regular <code>404</code> HTTP response code, however, in this case it is not a page that was not found but a specific project.</p>
<p>We respond very much the same way for the next route either with the task data or a 404 error when the project or the task is not found.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L22-L34"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 34</div>
  </div>
  <pre><code class="language-js">router.get('/:pid/:tid', (req, res) =&gt; {
  const prj = data[req.params.pid];
  if (prj) {
    const task = prj.tasks[req.params.tid];
    if (task) {
      res.json(task);
    } else {
      res.status(404).send(`Task ${req.params.tid} not found`);
    }
  } else {
    res.status(404).send(`Project ${req.params.pid} not found`);
  }
});</code></pre></div>
<p>For a POST operation, i.e.: adding a new record, we have to receive data, not send it.  We cannot receive large amounts of data via the URL as we have been doing with the few parameters we have been using so far.  To be able to receive data we need to access it from the body.</p>
<p>We have access to <code>req.body</code> because we already loaded the <code>body-parser</code> middleware.  Since we are only going to use JSON on the REST data exchanges, we will parse JSON  only on the <code>/data</code> path.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L17"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 17</div>
    <div class="to">To: 17</div>
  </div>
  <pre><code class="language-js">app.use('/data', bodyParser.json());</code></pre></div>
<p>We don't include the version part of the path since it is fair to assume that other versions would use the same data format.  Most middleware such as <code>body-parser</code> is quite versatile and tolerant.  If in a later version  we decide to use another data format, instead of failing, <code>body-parse</code> will let it go through, expecting that some later parser might deal with it.  Also, if we want to parse JSON on another path, we can add as many instances of <code>body-parser</code> elsewhere as needed.</p>
<p>To create a new project  we first try to create a new project id <code>pid</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L36-L41"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 36</div>
    <div class="to">To: 41</div>
  </div>
  <pre><code class="language-js">router.post('/', (req, res) =&gt; {
  const pid = nextId++;
  const prj = Object.assign({name: '', descr: ''}, req.body || {});
  data[pid] = prj;
  res.json({pid: pid});
});</code></pre></div>
<p>We get it from the variable <code>nextId</code> which we set at the very top of the file to a number larger than any ID in the data file.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">var nextId = 100;</code></pre></div>
<p>We increment that value as soon as we read from it.  It might seem strange that we go through so much trouble to get a <code>pid</code> when we might as well push the new record into an Array of projects and figure out its position.  As it happens, we don't want to use an Array even though our indexes are numeric, because items within an array can move and what now has index 10 may become 9 after record 5 is deleted.  Though within JavaScript empty Array slots take no memory, there is no way to skip over empty slots in JSON.  We want our <code>pid</code>s and <code>tid</code>s to be permanent and not be just temporary indexes.  That is why we take the trouble of producing unique, permanent IDs.  In an SQL database, we would use an auto-increment integer field, in a noSQL database, we would take whatever unique record identifier that the database generated for us.</p>
<p>We build our new record using <code>Object.assign</code> to merge a couple of default values with the data coming from the client in <code>req.body</code>.  Since there might be no data (we might want to validate for that) we also default to an empty object.</p>
<p>We then store that project record into the array at the position given by our new <code>pid</code> and return that <code>pid</code> to the client.</p>
<p>For updating records via <code>put</code> we first locate the existing record (project or task) and use <code>Object.assign</code> to merge the new values from <code>req.body</code> into the existing record.  We return an error if the record does not exist.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L54-L62"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 54</div>
    <div class="to">To: 62</div>
  </div>
  <pre><code class="language-js">router.put('/:pid', (req, res) =&gt; {
  const prj = data[req.params.pid];
  if (prj) {
    Object.assign(prj, req.body || {});
    res.json(prj);
  } else {
    res.status(404).send(`Project ${req.params.pid} not found`);
  }
});</code></pre></div>
<p>For deleting we simply delete the whole entry.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/projects.js#L79-L86"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 79</div>
    <div class="to">To: 86</div>
  </div>
  <pre><code class="language-js">router.delete('/:pid', (req, res) =&gt; {
  if (req.params.pid in data) {
    delete data[req.params.pid];
    res.send();
  } else {
    res.status(404).send(`Project ${req.params.pid} not found`);
  }
});</code></pre></div>
<p>We first try to locate the record to be deleted and return an error if not found.  We might have handled things differently.  We might not check for the existence of the record assuming that if not found it has already been deleted, which should be fine as that is what the user wanted.  We might have also returned the old record as it was before deletion though, being a potentially big piece of data, it might be a waste of bandwidth.  If the client code wanted it, it might have gotten it first.</p>
<h2><a class="self-ref" id="chapter05-summary" href="#chapter05-summary"># </a>Summary</h2>
<p>We have learned about the REST (<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer) protocol to accept and respond to data requests from the client.  We have defined the API we will be using in our application.</p>
<p>We have loaded a sample of data and showed how we can read it via suitable URLs.</p>
<p>We have learned how to write our own modules which we can use as well as the ones loaded via NPM.  We wrote one such module to  handle our REST request.</p>
<p>By separating our code into various modules we keep each modules small, focused and thus easy to understand and maintain.</p>
</section><section id="chapter06"><h1><a class="self-ref" id="chapter06-testing-our-server" href="#chapter06-testing-our-server"># </a>Testing our server</h1>
<p>So far we've tested the server we wrote in a very primitive and limited manner.  We can issue some HTTP GET requests from any browser and get a few responses from our server.  We can even test the REST API, at least the <code>get</code> requests but we can't test much else unless we create actual HTML pages with <code>&lt;form&gt;</code> tags for any of the other methods and input fields with suitable values.  Still, browsers transmit the form's contents url-encoded, not JSON-encoded which is what we will be using, so we can't really do much.</p>
<p>We can just keep going ahead, hoping for the best, and use the client, the one we haven't written so far, to do the testing.  The problem is, we would be testing two previously un-tested elements at once.  If we find something doesn't work, which of them is at fault?  This can be harder if development is split in between two teams.</p>
<p>Testing the REST API is like verifying the deliverables of a contract.  The server-side developers know what is required of their code and they can show it complies.  The client-side developers know that, once tested, the server-code can be trusted.</p>
<p>Moreover, software tends to have a life longer than we could expect. Over that time, issues and bugs might show up and, in attempting to fix them, we might mess up something else.  It is really hard to try this kind of collateral damage because when we fix something and then manually test whether it is fixed we tend to forget or prefer to avoid testing everything else. So, the best thing to do is to automate testing so we can ensure all works as it had before.</p>
<p>Once the basic testing infrastructure is in place, adding further tests is easy.  The first step to fix an issue is to reproduce it, and a new test is the easiest way to do so.  Adding a test to our existing battery can help us understand what went wrong and ensures it won't happen again. Thus, testing also helps us fix new issues by reproducing them and lets us know we have fixed them when they no longer fail.</p>
<p>Looking at our <code>pakage.json</code> file, we can see that the <code>npm init</code> command has already created an entry for a script test.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-03-01/package.json#L6-L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-03-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
},</code></pre></div>
<p>It hasn't added any other placeholders for any of the other possible scripts.  Moreover, the <code>npm test</code> command can be shortened to <code>npm t</code>.  These are indications that at least NPM takes testing seriously.  And so should we.</p>
<h2><a class="self-ref" id="chapter06-loading-testing-software" href="#chapter06-loading-testing-software"># </a>Loading testing software</h2>
<p>We will load several NodeJS packages that will help us in testing.  First of all, <a href="https://mochajs.org/">Mocha</a>, the basic testing framework to run our tests.  The <a href="http://chaijs.com/">Chai</a> package lets us make assertions, that is, ensure our expectations are fulfilled.  Finally, <a href="https://www.npmjs.com/package/axios">Axios</a> allows us to create any kind of HTTP request.  We use NPM to install them:</p>
<pre><code class="language-sh">npm i mocha --save-dev
npm i chai --save-dev
npm i axios --save
</code></pre>
<p>The <code>npm install</code> command can be shortened to <code>npm i</code>.  We have installed the first two packages with the <code>--save-dev</code> options so that they are saved  into <code>package-json</code> as development dependencies along ESLint, all listed in alphabetical order.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/package.json#L36-L43"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 36</div>
    <div class="to">To: 43</div>
  </div>
  <pre><code class="language-json">"devDependencies": {
  "chai": "^3.5.0",
  "eslint": "^2.7.0",
  "eslint-config-standard": "^5.1.0",
  "eslint-plugin-promise": "^1.1.0",
  "eslint-plugin-standard": "^1.3.2",
  "mocha": "^2.4.5"
}</code></pre></div>
<p>Axios, however, was installed with the <code>--save</code> option since it is a package that we will end up using in production so it is a regular dependency.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/package.json#L36-L43"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 36</div>
    <div class="to">To: 43</div>
  </div>
  <pre><code class="language-json">"devDependencies": {
  "chai": "^3.5.0",
  "eslint": "^2.7.0",
  "eslint-config-standard": "^5.1.0",
  "eslint-plugin-promise": "^1.1.0",
  "eslint-plugin-standard": "^1.3.2",
  "mocha": "^2.4.5"
}</code></pre>)</div>
<p>We also need to replace that test script in <code>package.json</code> with something useful.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/package.json#L6-L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "lint": "eslint . || exit 0",
  "test": "mocha"
},</code></pre></div>
<p>It is customary to separate test files from those used in production code so our test files will go into a separate folder.  Unless we explicitly tell Mocha which script file or files to run, it will search for files using the pattern <code>./test/*.js</code> and run all the scripts it finds.</p>
<p>We will place all our test scripts into the <code>/test</code> folder <a href="https://github.com/Satyam/book-react-redux/tree/chapter-06-01/test">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and will start with <code>server.js</code>.</p>
<p>Mocha will add serveral <em>global</em> methods such as <code>describe</code> and <code>it</code> that ESLint doesn't know about, so it will complain about them.  We could add a comment at the beginning of our source files to give instructions to ESLint:</p>
<pre><code class="language-js">/*globals describe:false, it:false, before:false, after:false*/
</code></pre>
<p>However, doing this on each and every test file would become tedious.  ESLint allows us to add extra <code>.eslintrc</code> files in any folder with extra configuration options. When ESLint enters a folder, it first checks for an <code>.eslintrc</code> file there and, if it finds one, it will merge the configuration options in that file with the options it is already working with.  Thus, by adding a <code>.eslintrc.json</code> file in the <code>/test</code> folder we can tell ESLint about our new <em>globals</em>. Actually, this is even easier because ESLint already knows about Mocha so we can just tell it to assume the environment these files are meant to run in is, besides NodeJS, Mocha so that it will immediately accept all of Mocha's globals.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/.eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "env": {
    "node": true,
    "mocha": true
  }
}</code></pre></div>
<p>Then we load the two NPM packages that will help us do the testing, <code>axios</code> and <code>chai</code>.  Chai offers several different syntaxes for writing our assertions, we will use the <code>expect</code> syntax.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L1-L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">const chai = require('chai');
const expect = chai.expect;
const axios = require('axios');</code></pre></div>
<p>To avoid having to repeat the connection configuration over and over again, Axios lets us create a pre-configured http connection instance. Here we can appreciate the advantages of placing our configuration parameters in <code>package.json</code>, both the server and the server testing software can read the <em>port</em> number from the same location.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L7-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">const PORT = process.env.npm_package_myServerApp_port || 8080;

const http = axios.create({
  baseURL: `http://localhost:${PORT}`,
  responseType: 'json'
});</code></pre></div>
<p>To write a test, we start with a description and what should be expected.</p>
<pre><code class="language-js">describe('Static pages test', function () {
  it('Get / should return home page', function () {
</code></pre>
<p>Both <code>describe</code> and <code>it</code> accept a string which will be printed as the tests are executed, in green for success, in red for failed ones.  As the second argument, both expect a callback function. The documentation for Mocha states that we should not use <em>fat arrow</em> functions because Mocha forces <code>this</code> within the callback to a value of its choice that allows us access to several functions. However, if we don't need to use any of those functions (and right now, we don't), we may use <em>fat arrow</em> functions.</p>
<p>Mocha allows for synchronous or asynchronous tests.  All HTTP operations are asynchronous because we don't actually know when the server will respond.  If we don't tell Mocha that a test is asynchronous, it will assume the test is passed when the test function reaches the end without errors, even if the reply from the server is still to arrive.</p>
<p>There are two ways to tell Mocha that a test is asynchronous.  If a test returns a <code>Promise</code>, Mocha will wait for its resolution and report on its success. This is great since Axios returns a Promise. We will explain the other mechanism later on.</p>
<p>Each test file can contain any number of <code>describe</code> calls and each one of those any number of <code>it</code> calls or further <code>describe</code>. Each <code>describe</code> is a <em>test suite</em> and Mocha allows us to define setup and tear down operations that can be done for each suite. We will use those later on.</p>
<p>Our first test is very simple, we will simply check that the server can respond with our simple home page.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L21-L28"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 21</div>
    <div class="to">To: 28</div>
  </div>
  <pre><code class="language-js">it('Get / should return home page', () =&gt;
  http.get('/')
    .then((response) =&gt; {
      expect(response.status).to.equal(200);
      expect(response.headers['content-type']).to.contain('text/html');
      expect(response.data).to.contain('&lt;title&gt;Sample Web Page&lt;/title&gt;');
    })
);</code></pre></div>
<p>We are sending an <code>http</code> <code>get</code> request on the root <code>'/'</code> and we expect the server to respond with a 200 status code, a content type of HTML and somewhere in the body to be that <code>&lt;title&gt;</code> tag. The <a href="http://chaijs.com/api/bdd/">syntax</a> of the calls chained after <code>expect</code> is provided by Chai as a series of keywords that turn out quite readable.</p>
<p>Axios returns a <code>Promise</code> which will be resolved when a reply arrives. The function at the <code>then</code> part of the Promise will then be called. The <code>then</code> is also chainable so it still returns a Promise which we return  so that Mocha itself can chain to it, wait for its completion and report on its success or failure.</p>
<p>It does not look as if we are returning anything to Mocha since there is no <code>return</code> statement, however, one of the changes in <em>fat arrow</em> functions is that if the body of the function is an expression, the <em>fat arrow</em> function implicitly  returns its value.  Normal <code>function</code> functions return <code>undefined</code> if nothing is returned explicitly, which was always somewhat of a waste. These functions are all equivalent:</p>
<pre><code class="language-js">function (x, y) {
  return x * y;
}

(x, y) =&gt; {
  return x * y;
}

(x, y) =&gt; x * y;
</code></pre>
<p>For the last test, we have to somehow turn around the normal response of Mocha because we do expect an error.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L37-L47"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 37</div>
    <div class="to">To: 47</div>
  </div>
  <pre><code class="language-js">it('Get /xyz should return a "page not found" error', () =&gt;
  http.get('/xyz')
    .then(
      (response) =&gt; {
        throw new Error('Should not have found it');
      },
      (response) =&gt; {
        expect(response.status).to.equal(404);
      }
    )
);</code></pre></div>
<p>The <code>then</code> method of a <code>Promise</code> actually accepts two callbacks, one for success, which is the one we usually use, and a second one for failure.  Here, we listen to both outcomes.  In the <em>success</em> callback, which is invalid in this case, we throw an error which Mocha will report.  In the second, we check that the status code on the <em>failed</em> response is, indeed, 404.  Since the failure is caught and supposedly fixed (unless the status code is something else but 404), the <code>Promise</code> is now considered successful and that is what Mocha will report.</p>
<h2><a class="self-ref" id="chapter06-running-the-tests" href="#chapter06-running-the-tests"># </a>Running the tests</h2>
<p>We have to run both the server and the test.  To do that we may either open two terminal windows and run the server via <code>npm start</code> in one of them and then <code>npm t</code> (shorthand for <code>npm test</code>) in the other.  Alternatively, if the operating system allows it, we could run the server in the background doing <code>npm start &amp;</code> and then <code>npm t</code>.</p>
<p>Unfortunately, we cannot simply chain one command after the other <code>npm start &amp;&amp; npm t</code>  because <code>npm start</code> exits when the server may not yet be listening to requests, and the tests might fail. It might succeed, but it is a matter of chance and how fast the machine is.</p>
<p>All these options are really messy.  What we want is for the tests to start and stop the web server when needed.  To do that, we first need to do some minor changes to our server code.</p>
<p>We need to <code>export</code> the server instance so our test has access to it. Before, we had:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-05-01/server/index.js#L27-L30"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-05-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 27</div>
    <div class="to">To: 30</div>
  </div>
  <pre><code class="language-js">http.createServer(app)
  .listen(PORT, () =&gt; {
    console.log(`Server running at http://localhost:${PORT}/`);
  });</code></pre></div>
<p>This created and set the server to listen to requests all at once.  We have to break that into two so we can export the server.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/server/index.js#L8-L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 8</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-js">const server = http.createServer(app);

module.exports = server;</code></pre></div>
<p>We now create the server instance and export it.  Later on, when the data file <code>data.json</code> has been read, we start listening but only if the script was executed directly and not loaded as a module.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/server/index.js#L31-L35"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 31</div>
    <div class="to">To: 35</div>
  </div>
  <pre><code class="language-js">if (require.main === module) {
  server.listen(PORT, () =&gt; {
    console.log(`Server running at http://localhost:${PORT}/`);
  });
};</code></pre></div>
<p>In NodeJS, when <code>require.main</code>, that is the main module, that which has not been required by any other module is this very same <code>module</code> it means it was run from NodeJS.  Only then we call the <code>listen</code> method to set the server to listen for requests.  This prevents the server to start listening immediately when our tests start.</p>
<p>In our test script we require the server as if it was just any other module.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-js">const server = require('..');</code></pre></div>
<pre><code class="language-js">/* Any of these would do just as well:
const server = require('../server');
const server = require('..');
*/
</code></pre>
<p>Since the server, when loaded as a module, will not start listening, we add these two extra commands to our test suite:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/test/server.js#L15-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-01</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">before('Starting server', (done) =&gt; {
  server.listen(PORT, done);
});
after('Closing the server', (done) =&gt; {
  server.close(done);
});</code></pre></div>
<p>Within each <code>describe</code>, Mocha will look for and execute <code>before</code> callbacks, then it will look for the <code>it</code> tests or further <code>describe</code> test suites and execute those and finally it will call the <code>after</code> callback, if there is any.  There are also <code>beforeEach</code> and <code>afterEach</code> that, if present, will be called not just once per test suite but for each and every individual test within the suite.  We are not using those here.</p>
<p>In our <code>before</code> callback we are telling our server to start listening.  It is the same <code>listen</code> method we used earlier in our web server which accepts a PORT and a callback to let us know when it is ready.  It is an asynchronous operation so we have to tell Mocha to wait until it is finished.  We cannot use the <code>Promise</code> mechanism because we have no <code>Promise</code> to return.  Instead we will use the <code>done</code> mechanism.  When Mocha detects that the test callbacks have accepted an argument, it assumes the test is async and waits for <code>done</code> to be called.  So, we call that <code>done</code> method once the server is ready to listen.  Likewise, we <code>close</code> the server <code>after</code> we are done with the tests.  <code>close</code> is also asynchronous so we accept the <code>done</code> argument and let <code>close</code> call it when it is done.</p>
<p>Now, with <code>npm start</code> we can run the server and with <code>npm t</code> we can run the tests, which will start the server as well. NodeJS allows us to have a script act as both an executable script and a library module.</p>
<p>Time to give it a try and, after that, make it fail. We can try changing the test script to expect a different status code, content type or text within the file or ask for non existing files and see how Mocha reports that.  Change the server script, for example, comment out the <code>express.static</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/server/index.js#L29">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> middleware or change the folder it points to.</p>
<p>Someone might have noticed that while we have dealt with the asynchronicity of the <code>listen</code> method of the server, we have not dealt with that of reading the data file.  There are a few ways to deal with that but, in the end, it really doesn't matter as the use of that <code>data.json</code> file is just an interim way to just get going with the parts of the application we really care about at this point.  Since it works anyway and, in the long run, it will be replaced, we won't deal with this issue right now.  It is noticeable in that the first test is somewhat slow and Mocha reports the delay in yellow as a warning or red as unacceptable.</p>
<h2><a class="self-ref" id="chapter06-testing-the-data-server" href="#chapter06-testing-the-data-server"># </a>Testing the data server</h2>
<p>Testing the REST API has made our <code>server.js</code> test script grow five-fold, even though we haven't tested everything that could possibly be tested.  Later on, we will see how to find out what we have checked and what not.  Most of the test code is quite repetitive, it usually goes like this:</p>
<pre><code class="language-js">it('whatever the test ...', () =&gt;
  http.method(URL /* possible object with data: {descr: 'changed description'} */)
    .then((response) =&gt; {
      expect(response.status).to.equal(200);
      expect(response.headers['content-type']).to.contain('application/json');
      let data = response.data;
      // further tests on the data
    })
);
</code></pre>
<p>Most tests will call some <code>method</code> (<code>get</code>, <code>post</code>, <code>put</code> or <code>delete</code>) on the <code>http</code> object which is a pre-configured Axios instance such as the one we use for static pages:</p>
<pre><code class="language-js">const http = axios.create({
  baseURL: `http://localhost:${PORT}`
});
</code></pre>
<p>Or the one we use to access the REST API, which already points to <code>/data/v1</code></p>
<pre><code class="language-js">const http = axios.create({
  baseURL: `http://localhost:${PORT}/data/v1/projects`,
  responseType: 'json'
});
</code></pre>
<p>Depending on the <em>method</em> we may need to add further information, for example, both the POST and PUT methods need an object with the data to insert or modify, which Axios will take care to JSON-encode.</p>
<p>For all responses, we check whether the response status code is 200 and the content-type is JSON, except for DELETE operations which return no data.  This might not seem strictly necessary since it is to be expected that if one GET returns JSON, all GETs will.  However, testing doesn't happen that often and does not affect response times in production so, why not waste a little time now and spare us trouble later?  After all we are chaining plenty of <code>to</code>, <code>be</code> and other Chai <em>readability</em> methods to our <code>expect</code> assertions though they are completely useless, just to make our tests as clear as possible.</p>
<p>The first few tests <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L60-L114">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> check for the data already contained in the <code>data.json</code> file. Since later testing relies on us being able to read the data we have inserted or changed, it makes sense to ensure we get GETs right.</p>
<p>For later tests, we</p>
<ul>
<li>create a new project <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L158-L171">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
<li>manipulate it <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L181-L267">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
<li>and then delete it <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L173-L179">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</li>
</ul>
<p>Likewise, for tasks, we</p>
<ul>
<li>create a new one <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L223-L235">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
<li>manipulate it <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L245-L265">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
<li>and then delete it <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L237-L243">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</li>
</ul>
<p>For each kind of manipulation test, we repeat the creation and deletion so we have used the <code>beforeEach</code> to create the project or task to manipulate and the <code>afterEach</code> to delete it when done.</p>
<p>In all the tests we return the <code>Promise</code> that Axios creates for each operation so Mocha can check it.  Even the <code>beforeEach</code> and <code>afterEach</code> callbacks are checked for success.</p>
<p>When running the test script, the various tests are shown indented according to the context they are in, as marked by the <code>describe</code> enclosing it. It is interesting to see how Mocha makes it easy for us.  For example, when changing the completion status of a particular tasks within a project, Mocha would have gone through all these steps:</p>
<ul>
<li>Start the server <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L10-L12">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>
<ul>
<li>Create the pre-configured Axios connection <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L55-L58">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>
<ul>
<li>Create a new project <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L158-L171">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>
<ul>
<li>Create a new task within the newly created project <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L223-L235">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>
<ul>
<li>Change the completion status <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L256-L265">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
</ul>
</li>
<li>Delete the task <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L237-L243">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
</ul>
</li>
<li>Delete the project <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L173-L179">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
</ul>
</li>
</ul>
</li>
<li>Stop the server <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L14-L16">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></li>
</ul>
<p>What are we missing? Plenty, for example:</p>
<ul>
<li>Add a second project and make sure it gets a different pid</li>
<li>Add another task to a project and make sure it gets its own tid</li>
<li>Do an actual GET on a changed project or task instead of relying on what the PUT method reports back</li>
<li>Delete a project or task to check it actually fails</li>
<li>Do a GET on a deleted project or tasks and check it fails</li>
<li>Change the information on a project with tasks in it and make sure we don't mess with those tasks</li>
</ul>
<p>Our tests have already paid off.  We were mishandling our tasks.  When creating a new project, we forgot to initialize the tasks list to an empty object. Later on, both when creating a new task or when deleting an existing one, we forgot that they go under the <code>tasks</code> member of the project object and not as part of the project itself. We got it right for changing it, but forgot on the other two operations. GitHub can show us the changes <a href="https://github.com/Satyam/book-react-redux/commit/caf19f304babb96242891b8fda57576c65cf2e13#diff-296f6c56d5ea1830255e4354f0b43f66">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> we did to <code>server/projects.js</code> to fix those errors, the green lines replacing the mistaken red lines.</p>
<p>That is what testing is for.</p>
<h2><a class="self-ref" id="chapter06-summary" href="#chapter06-summary"># </a>Summary</h2>
<p>We have learned how to use Mocha and Chai to automatically test our code and found an error while doing so.</p>
<p>We have modified our server code to enable it to be automatically started when run directly and to control when to start and stop it when run from other code, such as our test scripts.</p>
<p>We have modified our ESLint environment to accept Mocha's globals.</p>
<p>We have also started using Axios, the HTTP client library that we will eventually use in the actual client-side production code. After all, our test code is acting as a client would so it is better to use the same modules our client would.</p>
</section><section id="chapter07"><h1><a class="self-ref" id="chapter07-code-coverage" href="#chapter07-code-coverage"># </a>Code coverage</h1>
<p>In the previous chapter, we made a brief list of some of the things we had not checked in our test script.  Those are the <em>known unknowns</em> which is bad enough, but then, as expected, there are the <em>unknown unknowns</em>.</p>
<p>As exhausting as writing all those tests might have been, they are not yet as exhaustive as they should be. That is because we have not covered all the alternatives.  There are two great subsets of errors, the application logic errors, most of which we have checked and others we haven't, such as those we listed towards the end of the last chapter.</p>
<p>Then, there are coding errors, most of which we have already checked, but several might lay hidden in code that rarely executes, which not even our tests have exercised.  In a compiled language, most of those are discovered at compilation time, but in an interpreted language, if one particular piece of code is never reached, it might never cause the application to fail.  A Linter certainly helps but, as compilers, they are only static checkers, they can't know what the value of the variables are going to be at the time of execution. So, the best alternative is to actually exercise each and every part of the code.</p>
<p>Plenty of times, we check conditions in our code to make sure we only proceed when things are fine.  We may or may not have an <em>else</em> for those conditions that are invalid.  We tend to think linearly, we rarely cover all the alternatives in our minds.  What happens when those <em>elses</em> run?   Quite often, we even forget to check them.  That is exactly what we've done here, most of those <em>elses</em>  returning <code>404</code> errors have not been checked.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/server/projects.js#L71-L75"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-02</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 71</div>
    <div class="to">To: 75</div>
  </div>
  <pre><code class="language-js">} else {
    res.status(404).send(`Task ${req.params.tid} not found`);
  }
} else {
  res.status(404).send(`Project ${req.params.pid} not found`);</code></pre></div>
<p>That is why we need a tool to check our code <em>coverage</em>. We need to make sure that our tests have gone through each end every line of code so that we are sure they all behave correctly.</p>
<p><a href="https://github.com/gotwarlost/istanbul#istanbul---a-js-code-coverage-tool-written-in-js">Istanbul</a> is such a tool. Coupled with Mocha, it makes sure there is not line of code that has not been checked at least once.</p>
<p>Istanbul produces an excellent report.  In order not to waste space in GitHub uploading coverage report for our code, we can have a look at <a href="http://gotwarlost.github.io/istanbul/public/coverage/lcov-report/index.html">Istanbul's own coverage report</a>.  The filenames on the left are links which expand to more and more detail.  Lets take a look at the ones that have the worst coverage, those will show the abundance of information Istanbul can provide.</p>
<p>Beyond the statistics, the uncovered parts of the code are shown highlighted in color <a href="http://gotwarlost.github.io/istanbul/public/coverage/lcov-report/istanbul/lib/reporter.js.html">for each file</a> individually.  When placing the cursor over each highlighted segment, Istanbul will show a brief description of the error.</p>
<p>The column to the right of the line numbers show the number of times each line has been executed.  This can also help us determine which lines are executed the most and thus can most affect our application performance.</p>
<p>Coverage is such a standard operation that the <code>.gitignore</code> file that GitHub automatically generated for us already lists  the standard folder for our coverage report.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/.gitignore#L13-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-02</div>
    <div class="filename">File: .gitignore</div>
    <div class="from">From: 13</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-"># Coverage directory used by tools like istanbul
coverage</code></pre></div>
<h2><a class="self-ref" id="chapter07-installing-istanbul" href="#chapter07-installing-istanbul"># </a>Installing Istanbul</h2>
<p>To set up Istanbul we first need to load it.  Just as ESLint, we may load it globally with <code>npm i -g istanbul</code> as recommended in its <a href="https://github.com/gotwarlost/istanbul#getting-started">home page</a> so we share the same copy for all our applications.  However, we can also load it locally.</p>
<pre><code class="language-sh">npm i --save-dev istanbul@1.0.0-alpha.2
</code></pre>
<p>The part after the package name <code>@1.0.0-alpha.2</code> tells NPM to load that particular version of the package.  The default (without the @ part) is to load the latest stale published version. The problem in this case is that the current stable version of Istanbul does not handle some features we will use later on in this book so we have to go for a pre-release version.  Perhaps by the time you read this book, the <code>1.0.0</code> is the stable release and specifying the version is no longer needed</p>
<p>Anyway, this helps to explain why we are installing it locally instead of globally.  If we were to install a single global version of Istanbul, which one should we install?  The stable or the experimental?  It would be risky to install an experimental version globally, but then, what do we do with this particular application?  That is why it is better to install the tools locally for each application. Each app gets the version it needs.</p>
<p>Besides, local installs get recorded into <code>package.json</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/package.json#L43">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which makes it easier to set up the development environment by simply doing <code>npm install</code> on a fresh download of the application.  Global installs don't get recorded so we have to tell each new developer about all the globals we expect, and those developers might not be happy about us forcing them to provide our preferences.</p>
<h2><a class="self-ref" id="chapter07-running-istanbul" href="#chapter07-running-istanbul"># </a>Running Istanbul</h2>
<p>To execute it, we need to add another command  to the <code>scripts</code> section of our <code>package.json</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/package.json#L6-L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-07-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 6</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"scripts": {
  "start": "node server/index.js",
  "lint": "eslint . || exit 0",
  "test": "mocha",
  "coverage": "istanbul cover node_modules/.bin/_mocha"
},</code></pre></div>
<p>That is it.  Now, we can simply run it.</p>
<pre><code class="language-sh">npm run coverage
</code></pre>
<p>A <code>coverage</code> folder will be created in our project.  Look for <code>/coverage/lcov-report/index.html</code>. Doble-clicking on it will show the report for our application.  We haven't done that bad, the report shows mostly green indicating we have a reasonably good coverage.  Still, what is missing?</p>
<h2><a class="self-ref" id="chapter07-improving-coverage" href="#chapter07-improving-coverage"># </a>Improving coverage</h2>
<p>If we look at the coverage for <code>projects.js</code> we can see that we mostly missed the 404 error returns for non-existing projects or tasks.  We checked that for the GET method, but we haven't checked for wrong <code>pid</code>s or <code>tid</code>s for the other methods.</p>
<p>Once we get those covered, basically by copying and pasting the error-inducing code for the GET method <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/test/server.js#L116-L153">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and changing the method on each copy <a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/test/server.js#L154-L243">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we go from this:</p>
<pre><code>=============================== Coverage summary ===============================
Statements   : 86.42% ( 70/81 )
Branches     : 61.76% ( 21/34 )
Functions    : 100% ( 0/0 )
Lines        : 86.25% ( 69/80 )
================================================================================
</code></pre>
<p>To this level of coverage:</p>
<pre><code>=============================== Coverage summary ===============================
Statements   : 95.06% ( 77/81 )
Branches     : 82.35% ( 28/34 )
Functions    : 100% ( 0/0 )
Lines        : 95% ( 76/80 )
================================================================================
</code></pre>
<p>Since our source code is relatively small, any extra line of code we get covered really makes a whole lot of difference.</p>
<p>Another remaining uncovered branch is the default for non-existing bodies, which is repeated in several places:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-02/server/projects.js#L57"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-06-02</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 57</div>
    <div class="to">To: 57</div>
  </div>
  <pre><code class="language-js">Object.assign(prj, req.body || {});</code></pre></div>
<p>If <code>req.body</code> is <code>null</code> or <code>undefined</code>, we provide an empty object.  We haven't done any tests for PUT and POST with no data.  So, we add those tests and, surprisingly, our coverage results don't improve.  The <code>|| {}</code> alternative is never used.  What is going on?  As it turns out, the <code>body-parser</code> middleware kindly provides an empty object when none is received, thus our default is completely unnecessary. It is not that we missed a test for that condition, it is a condition that can't ever happen. When we drop those:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/server/projects.js#L57"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-07-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 57</div>
    <div class="to">To: 57</div>
  </div>
  <pre><code class="language-js">Object.assign(prj, req.body);</code></pre></div>
<p>our coverage of the branches taken improve further as we got rid of a bunch of useless code.</p>
<pre><code>=============================== Coverage summary ===============================
Statements   : 95.06% ( 77/81 )
Branches     : 92.31% ( 24/26 )
Functions    : 100% ( 0/0 )
Lines        : 95% ( 76/80 )
================================================================================
</code></pre>
<h2><a class="self-ref" id="chapter07-linting" href="#chapter07-linting"># </a>Linting</h2>
<p>If we now run our linter, we will get thousands of errors, all of them from the folder used for the output of Istanbul. The <code>.gitignore</code> file that GitHub produced for us already knows about Istanbul and similar tools <a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/.gitignore#L14">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> so GIT won't bother uploading those files.  We need to do something similar for ESLint.  By providing a <code>.eslintignore</code> file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-07-01/.eslintignore">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> listing the file and folder patterns of files we don't want checked, we can tell ESLint to ignore those files.</p>
<h2><a class="self-ref" id="chapter07-summary" href="#chapter07-summary"># </a>Summary</h2>
<p>Hopefully, these few examples have shown how code coverage can help us improve the quality of our code.  Istanbul is very easy to set up once we have our tests in place and it provides us with plenty of information.  It allows us to be confident that we have every alternative covered as well as strip unnecessary code that will never be executed.</p>
</section><section id="chapter08"><h1><a class="self-ref" id="chapter08-switching-to-sql" href="#chapter08-switching-to-sql"># </a>Switching to SQL</h1>
<p>Our server has been working from data stored in memory, a solution workable only for the smallest data set.  To go any further we should go to some more serious data management system. We have to switch to SQL.</p>
<p>Why not a NoSQL database? The information we have been using so far looks pretty much like the hierarchical information that is usually stored in NoSQL databases so it should be easy to store it in one such.</p>
<p>One reason to go the way of SQL is that it is, indeed, a challenge. We must support the agreed interface so we might as well prove that it can still be supported with any technology.  As long as it complies with the test suite we have written to validate our API, it really doesn't matter what is behind.</p>
<p>A second reason is that there is no NoSQL standard.  If we look at an SQL statement, we know what it means.  NoSQL databases are plagued with a wide variety of proprietary languages.  The purpose of this book is to look into React and Redux, not analyzing particular NoSQL dialects.</p>
<p>Finally, out of the many SQL variants, we will use <a href="https://www.sqlite.org">SQLite</a> for its simplicity. It still falls short of any large-scale database management system or DBMS like the popular and also free <a href="http://www.mysql.com/">MySQL</a>, <a href="http://www.postgresql.org/">PostgreSQL</a> or some larger commercial ones, but for the purpose of this book, it has the benefit of requiring no other installation than using NPM to load the corresponding package. SQLite manages its databases out of a simple file.  Opening a database simply means telling the SQLite driver which file to use. It is also so small that many applications use it to store its own data. For example, <a href="https://www.mozilla.org/en-US/thunderbird/">Mozilla Thunderbird</a>, a popular Open Source eMail client, creates several files with extension <code>.sqlite</code> that are SQLite databases just to hold configuration information.</p>
<p>Moreover, SQLite can use both temporary files or a memory store.  Both are valid through the duration of the application execution, which is all we need for the purpose of this book.</p>
<p>In our earlier version, we loaded the content of the <code>data.json</code> file in memory and handled all the data as a big global <code>data</code> object. Except for loading the <code>data.json</code> file into memory, all data operations where synchronous.  Now, using SQL, all our operations are asynchronous, which more closely resembles a real life scenario, and the purpose of this chapter is to explore that more thoroughly.</p>
<p>To load SQLite we follow the usual procedure. First, we use <code>npm i --save sqlite3</code> to download the package from the NPM registry.  Since we will use SQL in production, we use the <code>--save</code> option instead of <code>--save-dev</code> so it will be saved as a regular dependency in <code>package.json</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/package.json#L37">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Then, in our <code>server/index.js</code> file we add <code>const sqlite3 = require('sqlite3');</code> to load it as we have done with all the packages.  No news there.</p>
<p>So far, the only asynchronous operation we have seriously dealt with has been to put the HTTP server to listen.  We have ignored reading the <code>data.json</code> file, which is also an asynchronous operation, because we were going to drop it.  We are now dropping it but have added some more asynchronous operations.  Now, we do the following operations:</p>
<ul>
<li>Connect to the SQL database</li>
<li>Load the <code>data.sql</code> file containing the database setup</li>
<li>Make SQLite execute that file</li>
<li>Setup some SQL <em>Prepared Statements</em></li>
<li>Set the HTTP server to listen to requests</li>
</ul>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L22-L46"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 46</div>
  </div>
  <pre><code class="language-js">const webServer = {
  start: (done) =&gt; {
    global.db = new sqlite3.Database(':memory:', (err) =&gt; {
      if (err) return done(err);
      fs.readFile(path.join(__dirname, 'data.sql'), 'utf8', (err, data) =&gt; {
        if (err) return done(err);
        db.exec(data, (err) =&gt; {
          if (err) return done(err);
          projects(projectsRouter, (err) =&gt; {
            if (err) return done(err);
            server.listen(PORT, () =&gt; {
              console.log(`Server running at http://localhost:${PORT}/`);
              done();
            });
          });
        });
      });
    });
  },
  stop: (done) =&gt; {
    server.close(done);
  }
};

module.exports = webServer;</code></pre></div>
<p>To make all those operations available both to run the server regularly via <code>npm start</code> or to test it via <code>npm t</code> or <code>npm run coverage</code> we create a <code>webServer object</code> containing a <code>start</code> and a <code>stop</code> function.  We export that <code>webServer</code> object for the benefit of our test script.</p>
<p>In the <code>start</code> method, we create a <code>new sqlite3.Database</code> which will be kept in memory.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L24"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 24</div>
    <div class="to">To: 24</div>
  </div>
  <pre><code class="language-js">global.db = new sqlite3.Database(':memory:', (err) =&gt; {</code></pre></div>
<p>We could use an actual file or pass an empty string which will tell SQLite to create a temporary file, but we don't really have that much data. We make that <code>db</code> instance global by assigning it to <code>global.db</code>.</p>
<p>Then, we use the FileSystem <code>fs</code> module to read <code>data.sql</code> which contains standard SQL statements to create and populate the tables to store our data.  Once read, we tell the <code>db</code> to execute <code>db.exec</code> all those statements at once.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L26-L28"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 26</div>
    <div class="to">To: 28</div>
  </div>
  <pre><code class="language-js">fs.readFile(path.join(__dirname, 'data.sql'), 'utf8', (err, data) =&gt; {
  if (err) return done(err);
  db.exec(data, (err) =&gt; {</code></pre></div>
<p>We need to do some further setup in <code>server/projects.js</code> which is also asynchronous so we have added an extra argument to <code>projects</code>, we give it the router instance and now we also add a callback so it can tell us when it is done.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L30"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 30</div>
    <div class="to">To: 30</div>
  </div>
  <pre><code class="language-js">projects(projectsRouter, (err) =&gt; {</code></pre></div>
<p>Finally, we set our HTTP server to listen.</p>
<p>We do each operation sequentially. Each asynchronous operation takes a callback function whose first argument is an error object.  So, to proceed with each step we first check that the previous step has had no errors.  If <code>err</code> is not null, we call <code>done(err)</code> to notify our caller that there has been an error.  We have used a shortcut, we might have written this like this:</p>
<pre><code class="language-js">if (err) {
  done(err);
  return;
}
</code></pre>
<p>But we know that <code>done</code> does not return anything, thus, we are free to write:</p>
<pre><code class="language-js">if (err) return done(err);
</code></pre>
<p>Since <code>done</code> returns <code>undefined</code> and a solitary <code>return</code> is like <code>return undefined</code>, our shortcut works just the same.  We have not used this kind of shortcut elsewhere because we don't know what the callback might return.</p>
<p>For <code>close</code> we simply close the HTTP server.  Since the database is a temporary one in memory, it really doesn't matter if we close it or not.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L42"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 42</div>
    <div class="to">To: 42</div>
  </div>
  <pre><code class="language-js">server.close(done);</code></pre></div>
<p>To start the server in production mode using <code>npm start</code>, we have:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L48-L55"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 48</div>
    <div class="to">To: 55</div>
  </div>
  <pre><code class="language-js">if (require.main === module) {
  webServer.start((err) =&gt; {
    if (err) {
      console.error(err);
      process.exit(1);
    }
  });
}</code></pre></div>
<p>Once again, we check if this module is the main one and, if so, we call <code>webServer.start</code> to get everything up and running.  We provide a callback function which <code>start</code> would receive as the <code>done</code> argument that, if it does receive an error, it shows it in the console and exits with an error code.</p>
<p>We have made the function which is the default export of <code>server/projects.js</code> an asynchronous one by adding just one more argument to it, the <code>done</code> callback. We had to do this because all SQL operations are asynchronous so at initialization time, when we setup the <em>prepared statements</em> we can let our caller know when we are done or otherwise signal an error.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">module.exports = (router, done) =&gt; {</code></pre></div>
<p>A prepared statement is an optimization present in most varieties of SQL which allows the SQL engine to pre-compile and possibly optimize an SQL statement for future execution. For example, <code>selectAllProjects</code> contains the prepared statement <code>'select * from projects'</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L1-L7"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 7</div>
  </div>
  <pre><code class="language-js">module.exports = (router, done) =&gt; {
  const selectAllProjects = db.prepare('select * from projects', (err) =&gt; {
    if (err) return done(err);
  });
  const selectProjectByPid = db.prepare('select * from projects where pid = $pid', (err) =&gt; {
    if (err) return done(err);
  });</code></pre></div>
<p>Prepared statements can have variable parts which will be filled in when they are executed.  Variable parts can be represented in various ways, we have opted to use an identifier preceded by a <code>$</code> sign.  Thus when we want to execute <code>selectProjectByPid</code>, we have to provide an actual value for <code>$pid</code>.</p>
<p>Now, in response to a request for <code>/data/v1/projects</code>, we ask the <code>selectAllProjects</code> prepared statement to give us <code>all</code> the projects it can find.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L30-L38"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 30</div>
    <div class="to">To: 38</div>
  </div>
  <pre><code class="language-js">router.get('/', (req, res) =&gt; {
  selectAllProjects.all((err, prjs) =&gt; {
    if (err) {
      res.status(500).send(err);
    } else {
      res.json(prjs);
    }
  });
});</code></pre></div>
<p>We give '/' as the path since our <code>projectsRouter</code> already passes on only the requests to <code>/data/v1/projects</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/index.js#L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 16</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">app.use('/data/v1/projects', projectsRouter);</code></pre></div>
<p>We call the <code>all</code> method on our <code>selectAllProjects</code> prepared statement, meaning, we want all the records it returns instead of one at a time. We provide it with a callback that will receive an error, if any, and an array containing all the projects if there is no error.  If we do get an error, we reply with a 500 HTTP error code along the text of the error or otherwise we send back those projects JSON-encoded.</p>
<p>We use a 500 error code here instead of the 404 we have used so far because the only reason for an error is a serious server-side error which fits the error standard description &quot;500: Internal Server Error&quot;.  There are plenty of standard <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">HTTP Status Codes</a> already defined that cover most needs. It is better to use the correct HTTP error code.</p>
<p>Creating a new project via a POST to <code>/data/v1/projects</code> uses parameters:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L82-L93"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 82</div>
    <div class="to">To: 93</div>
  </div>
  <pre><code class="language-js">router.post('/', (req, res) =&gt; {
  createProject.run({
    $name: req.body.name,
    $descr: req.body.descr
  }, function (err) {
    if (err) {
      res.status(500).send(err);
      return;
    }
    res.json({pid: this.lastID});
  });
});</code></pre></div>
<p>Here we run the <code>createProject</code> prepared statement filling in the <code>$name</code> and <code>$descr</code> variables with the corresponding information from the body of the request.  If there is an error, we report it back to the client with a 500 error code, otherwise, we get the <code>pid</code> of the newly inserted record which SQLite stores in <code>this.lastID</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L91"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 91</div>
    <div class="to">To: 91</div>
  </div>
  <pre><code class="language-js">res.json({pid: this.lastID});</code></pre></div>
<p>SQLite has two such variables <code>lastID</code> which represents the row ID of the last record inserted and <code>changes</code> which returns a count of the number of records affected in an insert, update or delete statement.  There is only one copy of each per connection so they must be read immediately after the SQL operation and before any new operation is attempted.  Different SQL engines have different names for these variables but they are always there in one way or another.</p>
<p>We are not using any shortcut to return when an error is found.  The following may work, but it is not safe:</p>
<pre><code class="language-js">if (err) return res.status(500).send(err);
</code></pre>
<p>If we did this, we would be returning a copy of <code>res</code> but we don't know what the Express router might do with that.  We might use:</p>
<pre><code class="language-js">if (err) return void res.status(500).send(err);
</code></pre>
<p>But it lacks clarity, which is important for maintainability, unless the practice is standardized across the organization. One-off hacks are never a good idea but if it becomes standard practice, it would be OK (and it would allow us to improve our coverage statistics).</p>
<h2><a class="self-ref" id="chapter08-building-sql-statements-dynamically" href="#chapter08-building-sql-statements-dynamically"># </a>Building SQL statements dynamically</h2>
<p>We can't use SQL prepared statements everywhere. In an update, what is it we are updating, all of the record or just part of it? In a project, we might independently update the project name or its description.  In a task we might change the description or its completion status. Just two fields per record  would require three prepared statements, one with both SQL field names and another two, each for a separate field.  This is not acceptable.  With more fields the situation would be even worst. So, we build it dynamically by concatenating as many fields as values arrive in the request body:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-01/server/projects.js#L119-L143"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-01</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 119</div>
    <div class="to">To: 143</div>
  </div>
  <pre><code class="language-js">router.put('/:pid', (req, res) =&gt; {
    const sql = 'update projects set ' +
      Object.keys(req.body).map((column) =&gt; `${column} = $${column}`).join(',') +
     ' where pid = $pid';

    db.run(sql, {
      $name: req.body.name,
      $descr: req.body.descr,
      $pid: req.params.pid
    }, function (err) {
      if (err) {
        if (err.errno === 25) {
          res.status(404).send(`project ${req.params.pid} not found`);
        } else {
          res.status(500).send(err);
        }
        return;
      }
      if (this.changes) {
        res.json({pid: req.params.pid});
      } else {
        res.status(404).send(`Project ${req.params.pid} not found`);
      }
    });
  });</code></pre></div>
<p>Since we have no prepared statement, we ask the <code>db</code> to <code>run</code> the <code>sql</code> statement we have just built by concatenating it in bits and pieces. We then provide the parameters to fill into the placeholders in the statement. If either of <code>name</code> or <code>descr</code> is <code>undefined</code> it will not show in the parameter list, but neither will it be in the statement so SQLite won't be expecting it.</p>
<h2><a class="self-ref" id="chapter08-regular-anonymous-functions-vs-fat-arrow-functions" href="#chapter08-regular-anonymous-functions-vs-fat-arrow-functions"># </a>Regular anonymous functions vs. fat arrow functions</h2>
<p>Our use of regular anonymous functions like in the code above and fat arrow functions elsewhere might seem capricious but it is not so. Fat arrow functions are the preferred choice because of their compact syntax and the way they handle <code>this</code>, which has always been an inconvenience in JavaScript.  Regular functions have their <code>this</code> either undefined or set to the global object. This was a problem for callbacks because they lost track of the <code>this</code> from the object instance they were contained in.  In contrast, fat arrow functions retain the <code>this</code> of their containing object.</p>
<p>Many developers have turned this <em>issue</em> into an advantage. Both Mocha and the SQLite driver set the context (the value of <code>this</code>) to a value of their choice which gives access to properties or methods useful to the callback.  Within an <code>it</code> test in Mocha, <code>this.timeout(nnn)</code> allows delays in tests.  In <code>sqlite3</code>, <code>this.lastID</code> and <code>this.changes</code> are accessible to the callback of the SQL operations.  If we were to use fat arrow functions, the <code>this</code> that those utilities give us would be lost.</p>
<h2><a class="self-ref" id="chapter08-testing-the-changes" href="#chapter08-testing-the-changes"># </a>Testing the changes</h2>
<p>We won't go through all of the changes in <code>projects.js</code>, it is basically SQL data handling.  Once all the changes are done, we have to check them and we have two ways of doing so. As always, we run ESLint via <code>npm run lint</code>.  Even if we have added linting to our editor, it is better to do a full check anyway because editors usually lint only the files they actually show.</p>
<p>Then, we need to run the tests via <code>npm t</code>.  These don't come good. Though 10 errors are reported, after analyzing them, it turns out they are only three different types.</p>
<ol>
<li>
<p>We changed the way we report the error messages.  Before, we had <code>Project nnn not found</code> and <code>Task nnn not found</code>, now we have more descriptive messages such as <code>Task nnn in project nnn not found</code> which is better for debugging. This is not a big deal of a change since the message is informative and useful only for debugging but it hardly matters to our client software which will simply check for the 404 error, not for the message.</p>
</li>
<li>
<p>When we are testing whether the server returns a proper error when we are updating a non-existing record, we expect a <code>404 Not Found</code> error, however, we are getting a <code>500 Internal Server Error</code>.  This is because in our tests, we didn't bother sending any actual data to update since we expected an error.  This no longer works with SQL because we are generating the SQL statement dynamically and, if there are no fields to update, the statement is invalid and won't compile. This was an error on our test suite which caused an error different from what we expected.  However the server did report an error so, it is hardly questionable.</p>
</li>
<li>
<p>When doing an update we used to reply with the updated record. This is easy when the data is in memory, but it requires one more SQL operation. Retaining the original behavior would be costly.  Is that cost worth preserving the compatibility? This is not an unusual decision to take at an earlier stage as we are now at.</p>
</li>
</ol>
<p>The first two errors are backward-compatible, a client would not complain about those.  The last one is not. However, it is hard to see an application that would complain about it, after all, the client already has the information, the server reply was just a confirmation, an expensive one at that.  So, we opt to accept the change in behavior.  We will not be providing the changed record on our updates, if we want it, you can always ask for it, which is what we do in our tests. Instead of just expecting the data to arrive with the reply to our update, we do an additional query to verify they were properly done  <a href="https://github.com/Satyam/book-react-redux/commit/f1fcd70b708e832e3e98872dd27728cef5eef8b5#diff-ad3c25167d0354b9b277e3ab6f375274L289">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>Many such changes in behavior are not so simple. The important lesson here is that to do this properly, we need to change the version number in <code>package.json</code>  from <code>&quot;version&quot;: &quot;0.1.0&quot;</code> to:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-02/package.json#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-json">"version": "0.2.0",</code></pre></div>
<p>Whenever we change the first non-zero number part in our version, it means there has been a compatibility change.  If our module were to be listed as a dependency in some other <code>package.json</code> like this:</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;how_to_do_a_todo_app&quot;: &quot;^0.1.0&quot;
}
</code></pre>
<p>NPM would load any version <code>0.1.0</code> or later, such as <code>0.1.1</code> or <code>0.1.999999</code> but it would never load <code>0.2.0</code> because when the first non-zero number changes, it means there is a compatibility issue.</p>
<p>Since we are still in the <code>0.x.x</code> version numbers, it means we are not yet in production so we are still free to do this kind of changes.  Later on, we would need to gently migrate our users to the new version. This would require us to handle two versions at once, the old one on the <code>/data/v1</code> route and the new one in <code>/data/v2</code>.</p>
<h2><a class="self-ref" id="chapter08-handling-url-query-parameters" href="#chapter08-handling-url-query-parameters"># </a>Handling URL Query Parameters</h2>
<p>Within a REST request, each part has a clear function. We have dealt with most of them, namely:</p>
<ul>
<li>
<p>The method (GET, POST, PUT, DELETE) tells the server what to do.</p>
</li>
<li>
<p>The path (<code>projects/34/5</code>) identifies the item we mean to operate upon.</p>
</li>
<li>
<p>The optional body of the request carries non-key data associated with that item, usually for insert or update operations.</p>
</li>
<li>
<p>The optional query parameters (the part following the query mark in the URL) indicate options.</p>
</li>
</ul>
<p>We may add query parameters to our REST API such as search conditions or which fields to return. Often, to handle those cases we need to build the SQL statement dynamically.  However, since the query parameters are usually an exception, we will still use the generic SQL prepared statement for the usual condition and a built one for the exceptional cases.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L30-L50"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-03</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 30</div>
    <div class="to">To: 50</div>
  </div>
  <pre><code class="language-js">router.get('/', (req, res) =&gt; {
  const cb = (err, prjs) =&gt; {
    if (err) {
      res.status(500).send(err);
    } else {
      res.json(prjs);
    }
  };
  if (Object.keys(req.query).length === 0) {
    selectAllProjects.all(cb);
  } else {
    const sql = 'select ' +
      (req.query.fields || '*') +
      ' from projects' +
       (req.query.search
         ? ' where ' + req.query.search.replace(/([^=]+)=(.+)/, '$1 like "%$2%"')
         : ''
       );
    db.all(sql, cb);
  }
});</code></pre></div>
<p>We changed the route handler for the GET on <code>/</code> to handle query parameters.  Since one way or another we are going to use the same callback for queries with or without parameters, we first define the callback function <code>cb</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L31-L37"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-03</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 31</div>
    <div class="to">To: 37</div>
  </div>
  <pre><code class="language-js">const cb = (err, prjs) =&gt; {
  if (err) {
    res.status(500).send(err);
  } else {
    res.json(prjs);
  }
};</code></pre></div>
<p>We check whether there are any query parameters.  Express already parses the query parameters and places them in an object at <code>req.query</code>. If there are none, it will give us an empty object.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L38"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-03</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 38</div>
    <div class="to">To: 38</div>
  </div>
  <pre><code class="language-js">if (Object.keys(req.query).length === 0) {</code></pre></div>
<p>If there are no keys in <code>req.query</code> we use the <code>selectAllProjects</code> prepared statement, otherwise, we build the SQL statement into <code>sql</code> and run it.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L41-L48"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-03</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 41</div>
    <div class="to">To: 48</div>
  </div>
  <pre><code class="language-js">const sql = 'select ' +
  (req.query.fields || '*') +
  ' from projects' +
   (req.query.search
     ? ' where ' + req.query.search.replace(/([^=]+)=(.+)/, '$1 like "%$2%"')
     : ''
   );
db.all(sql, cb);</code></pre></div>
<p>If there is a <code>fields</code> key, we expect it to be a comma separated list of fields to list, such as <code>name,descr</code> and we concatenate that list, otherwise, we ask for all fields <code>'*'</code>.</p>
<p>If there is a <code>search</code> key, we assemble an SQL <code>where</code> clause.  We expect the search to be of the form <code>field=value</code> which we translate, via a regular expression, into <code>field like &quot;%value%&quot;</code> which is an SQL  <em>wildcard</em> search for that value anywhere within the field. This is just an example of how a search could be translated, many others would be just as good.  The REST API we are dealing with is not meant for direct human consumption so its syntax could be far more complex and/or cryptic,  after all, there will be client-side software to translate it from the user request.</p>
<p>As expected, we then test our changes <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/test/server.js#L89-L143">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<h2><a class="self-ref" id="chapter08-sql-injection" href="#chapter08-sql-injection"># </a>SQL Injection</h2>
<p>The previous example shows us the danger of relying on information coming from a remote client to build an SQL statement. We may add the following test to our suite to see how it can be done:</p>
<pre><code class="language-js">it('SQL injection ', () =&gt; http.get('/?fields=* from sqlite_master;select *')
  .then((response) =&gt; {
    expect(response.status).to.equal(200);
    expect(response.headers['content-type']).to.contain('application/json');
    const data = response.data;
    expect(data).to.be.an.instanceof(Array);
    console.log(data);
  })
);
</code></pre>
<p>Our server code accepts two query parameters, <code>fields</code> and <code>search</code>.  The first is expected to contain a comma-separated list of field names such as <code>?fields=name,pid</code> but what if it doesn't? In the code above we cheated the server and injected an extra SQL statement for the server to execute.  When that request is executed, the server code <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-03/server/projects.js#L41-L47">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> will produce the following SQL statement:</p>
<pre><code class="language-sql">select * from sqlite_master;select * from projects
</code></pre>
<p>Many database engines can return the result of two queries at once or will return one or the other.  In this case, SQLite returns the first and ignores the second. The table <code>sqlite_master</code> is an internal table within SQLite that actually contains the information about all the other elements in the database.</p>
<pre><code class="language-js">[ { type: 'table',
    name: 'projects',
    tbl_name: 'projects',
    rootpage: 2,
    sql: 'CREATE TABLE projects (\n  pid INTEGER PRIMARY KEY,\n  name TEXT,\n  descr TEXT\n)' },
  { type: 'table',
    name: 'tasks',
    tbl_name: 'tasks',
    rootpage: 3,
    sql: 'CREATE TABLE tasks (\n  tid INTEGER PRIMARY KEY,\n  pid INTEGER,\n  descr TEXT,\n  completed TINYINT\n)' } ]
</code></pre>
<p>It lists the only two elements we have created, the two tables <code>projects</code> and <code>tasks</code> and the SQL statements used for the creation of each, listing the fields and constraints for each.</p>
<p>Once we know the tables available in the server, we could then issue a HTTP GET request to  <code>'/projects?fields=* from projects;select *'</code> or any other table we had and steal whatever information is within reach.</p>
<p>This process is called SQL Injection and it is one of the main exploits to steal data from servers. We should always check the data received.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/server/projects.js#L41-L48"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-04</div>
    <div class="filename">File: server/projects.js</div>
    <div class="from">From: 41</div>
    <div class="to">To: 48</div>
  </div>
  <pre><code class="language-js">if (req.query.fields &amp;&amp; !/^\s*\w+\s*(,\s*\w+\s*)*$/.test(req.query.fields)) {
  res.status(400).send('Bad request');
  return;
}
if (req.query.search &amp;&amp; !/^\s*\w+\s*=\s*\w[\w\s]*$/.test(req.query.search)) {
  res.status(400).send('Bad request');
  return;
}</code></pre></div>
<p>Our test now shows that trying to inject anything unexpected fails.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/test/server.js#L145-L155"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-04</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 145</div>
    <div class="to">To: 155</div>
  </div>
  <pre><code class="language-js">it('SQL injection ', () =&gt;
  http.get('/?fields=* from sqlite_master;select *')
    .then(
      (response) =&gt; {
        throw new Error('Should not have let it go');
      },
      (response) =&gt; {
        expect(response.status).to.equal(400);
      }
    )
);</code></pre></div>
<p>We should never trust the information coming from a remote source.  It might not actually be a user on a browser.</p>
<h2><a class="self-ref" id="chapter08-summary" href="#chapter08-summary"># </a>Summary</h2>
<p>We have successfully migrated our server from using in-memory data to an external SQL database.</p>
<p>In doing so we have found that our original definition of our REST API had some expensive features. This required us to change the agreed interface causing a compatibility issue.  We indicated that by incrementing our version number of our code in <code>package.json</code>.</p>
<p>It was our tests that allowed us to discover this issue.  We should always write tests.</p>
<p>We have also shown how SQL injection can be done and how to prevent it by validating the requests.  And, of course, we tested for it.</p>
</section><section id="chapter09"><h1><a class="self-ref" id="chapter09-separating-concerns" href="#chapter09-separating-concerns"># </a>Separating Concerns</h1>
<p>Our <code>projects.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/server/projects.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> file is a real mess.  It was useful so far because it allowed us to see in just one glimpse how a request could be handled but it mixed two separate concerns, those of handling the HTTP and the database connections.  As more complexity was added to the routes in some of the examples, they became really difficult to follow.</p>
<p>We fix this mess by separating the concerns.  To start with, it seems our server software will only deal with projects.  This is probably shortsighted, we would eventually have to tackle other concerns, such as user login, which will also require us to manage users.</p>
<p>Our server has already hard-coded a root route to deal with projects:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/server/index.js#L15-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-08-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">const projectsRouter = express.Router();
app.use('/data/v1/projects', projectsRouter);</code></pre></div>
<p>For starters, we will move the code dealing with projects into its own <code>projects</code> folder under <code>/server</code> <a href="https://github.com/Satyam/book-react-redux/tree/chapter-09-01/server">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  This will further give us flexibility to separate the code dealing with projects into various files without crowding the <code>/server</code> folder.</p>
<p>The <code>routes.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/routes.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> file deals with routing the HTTP requests to appropriate handlers and <code>transactions.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/transactions.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> deals with actually handling the data for those requests.</p>
<p>Several clues indicate the split is a good thing.</p>
<ul>
<li><code>routes.js</code>
<ul>
<li>no longer uses <code>db</code>, the global variable holding the database connection.</li>
<li>validates all incoming arguments and issues a <code>400 Bad request</code> HTTP Error.  The 4xx error codes are client-side errors and sending improper values is its concern.</li>
<li>converts incoming text values into proper internal data types (numbers and booleans)</li>
<li>sends <code>500 Internal Server Error</code> when an error comes from <code>transactions.js</code>.  The 5xx error codes are for server-side errors and whatever the specific error might be, from an HTTP standpoint, it is a 5xx error.</li>
</ul>
</li>
<li><code>transactions.js</code>
<ul>
<li>it assumes that the data from the request is present and validated</li>
<li>it is the only one accessing the database</li>
<li>knows nothing about HTTP error codes</li>
<li>knows nothing about where the data is located within the request</li>
</ul>
</li>
</ul>
<p>All the database functionality is contained within an object which is the only export of <code>transactions.js</code>.  Each property in that object is a function. An <code>init</code> function sets everything up, basically, pre-compiling the SQL prepared statements, followed by several functions handling each possible CRUD operation.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/transactions.js#L1-L32"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 32</div>
  </div>
  <pre><code class="language-js">const prepared = {};

module.exports = {
  init: (done) =&gt; {
    prepared.selectAllProjects = db.prepare('select * from projects', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.selectProjectByPid = db.prepare('select * from projects where pid = $pid', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.selectTasksByPid = db.prepare('select tid, descr, completed from tasks where pid = $pid', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.selectTaskByTid = db.prepare('select * from tasks where tid = $tid', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.createProject = db.prepare('insert into projects (name, descr) values ($name, $descr)', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.createTask = db.prepare('insert into tasks (pid, descr, completed) values ($pid, $descr, $completed)', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.deleteProject = db.prepare('delete from projects where pid = $pid', (err) =&gt; {
      if (err) return done(err);
    });
    prepared.deleteTask = db.prepare('delete from tasks where pid = $pid and tid = $tid', (err) =&gt; {
      if (err) return done(err);
    });
    done();
  },

  getAllProjects: (keys, data, options, done) =&gt; {</code></pre></div>
<p>All the functions are asynchronous receiving a <code>done</code> callback function as their last or only argument.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/transactions.js#L49"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 49</div>
    <div class="to">To: 49</div>
  </div>
  <pre><code class="language-js">getProjectById: (keys, data, options, done) =&gt; {</code></pre></div>
<p>All data handling functions, such as the two shown above expect the following arguments:</p>
<ul>
<li><code>keys</code>: Object containing the key or index to locate the item to operate upon.  They are usually <code>pid</code> and/or <code>tid</code>.</li>
<li><code>data</code>: Object containing data associated to the request. They can be <code>name</code> and <code>descr</code> for projects, <code>descr</code> and <code>complete</code> for tasks.</li>
<li><code>options</code>: Object containing request options such as
<ul>
<li><code>fields</code>: list of fields to return</li>
<li><code>search</code>: name of field and value to look for in that field.</li>
</ul>
</li>
<li><code>done</code>: callback function.</li>
</ul>
<p>They all produce the same type of reply through the combination of the two arguments of the <code>done</code> callback function.</p>
<ul>
<li><code>done(null, data)</code>: success.  Requested data is returned.</li>
<li><code>done(err)</code>: error. The database handler produced some sort of error.  The second argument is irrelevant.</li>
<li><code>done(null, null)</code>: not found. The keys provided failed to locate any items.  This is usually an error and <code>routes.js</code> reports it as a <code>404 not found</code> HTTP error.  This is different from a request for a list of items that returns no items because that returns <code>done(null, [])</code> and it is not necessarily an error.</li>
</ul>
<p>Extracting the arguments for each data processing function and processing the replies is mostly handled by the <code>processPrj</code>  function:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/routes.js#L4-L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-js">const processPrj = (op, res, keys, data, options) =&gt; {
  transactions[op](keys, data, options, (err, data) =&gt; {
    if (err) return void res.status(500).send(err);
    if (data === null) return void res.status(404).send('Item(s) not found');
    res.json(data);
  });
};</code></pre></div>
<p>It receives the name of the method within <code>transactions.js</code> that should handle the operation, the <code>res</code> response object from Express and the <code>keys</code>, <code>data</code> and <code>options</code> object for each request, as described above. It calls the given method on the <code>transactions</code> objects which is the result of requiring <code>transactions.js</code></p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/routes.js#L2"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 2</div>
    <div class="to">To: 2</div>
  </div>
  <pre><code class="language-js">const transactions = require('./transactions.js');</code></pre></div>
<p>On receiving the callback call, it checks for errors and sends a 500 error if one is found.  If <code>err</code> is <code>null</code> it then checks whether <code>data</code> is <code>null</code> and if so it sends a 404 error and otherwise just sends the data.</p>
<p>A typical database operation turns out to be quite simple:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/transactions.js#L67-L74"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 67</div>
    <div class="to">To: 74</div>
  </div>
  <pre><code class="language-js">getTaskByTid: (keys, data, options, done) =&gt; {
  prepared.selectTaskByTid.get({$tid: keys.tid}, (err, task) =&gt; {
    if (err) return done(err);
    if (!task || task.pid !== keys.pid) return done(null, null);
    task.completed = !!task.completed;
    done(null, task);
  });
},</code></pre></div>
<p>All operations receive the very same 4 arguments though depending on the operation, some will be empty.  Here, <code>getTaskByTid</code> calls the SQL prepared statement <code>selectTaskByTid</code> providing it with the object that will fill its placeholders, in this case only one <code>$tid</code> for the task Id.  On callback, it checks for errors and return immediately if any is found, it then checks whether a task item was actually returned and if so whether the <code>pid</code> on it matches the <code>pid</code> requested and in either case, it returns both null indicating that no record matched the requested keys.  Finally, it does a data type conversion on the <code>completed</code> field because SQLite does not have an actual  Boolean type but represents it as numbers 0 or not zero.  Just as the <code>routes.js</code> module dealt with type conversion on the data received in the HTTP request, it is the responsibility of the module dealing with the database to do the data type conversion of the values received from it to native JavaScript data types. Finally, it calls <code>done</code> with the data retrieved.</p>
<p>It is always a good rule that the first module receiving the information from an external source (http client, database handler, etc.) is responsible for validating and converting the values to native data types.</p>
<p>We will off-load dealing with specific data routes from our core web server code.  Instead of setting up a sub-router for the whole <code>/data/v1/projects</code> route <a href="https://github.com/Satyam/book-react-redux/blob/chapter-08-04/server/index.js#L15-L18">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we will only deal with <code>/data/v1</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/index.js#L15-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">const dataRouter = express.Router();
app.use('/data/v1', dataRouter);</code></pre></div>
<p>However, it is not a good idea to let every data server plug itself into whichever route it pleases.  It is best to have some centralized place responsible to tell each module which branch off the main <code>/data/v1</code> route it should respond to.  Thus, we tell the module  where it should go when initializing itself:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/index.js#L28-L29"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 28</div>
    <div class="to">To: 29</div>
  </div>
  <pre><code class="language-js">const projectsRoutes = require('./projects/routes.js');
projectsRoutes(dataRouter, '/projects', (err) =&gt; {</code></pre></div>
<p>The projects router will receive the <code>dataRouter</code> and the <code>branch</code> it should respond to.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-01/server/projects/routes.js#L17-L21"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-01</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 17</div>
    <div class="to">To: 21</div>
  </div>
  <pre><code class="language-js">module.exports = (dataRouter, branch, done) =&gt; {
  const projectsRouter = express.Router();
  dataRouter.use(branch, projectsRouter);

  projectsRouter.get('/', (req, res) =&gt; {</code></pre></div>
<p>Each module might choose to generate a new sub-router, as we did here by creating a new <code>projectsRouter</code>, or it might use the <code>dataRouter</code> and concatenate the <code>branch</code> into each of the paths:</p>
<pre><code class="language-js">// With sub-router
projectsRouter.get('/:pid', (req, res) =&gt; {

// Concatenating the branch into the path
dataRouter.get(`${branch}/:pid`, (req, res) =&gt; {
</code></pre>
<p>Within each router, Express checks the routes sequentially in the order they were defined.  By creating sub-routes we turn this sequential list into a tree, which is faster to traverse.  It also allows us to plug any group of routes anywhere else in the tree with little effort should we ever need it.  Besides, we write less.</p>
<p>It might well be noted that in our database handlers, the arguments <code>keys</code>, <code>data</code> and <code>options</code> copy values from <code>req.params</code>, <code>req.body</code> and <code>req.query</code> respectively.  It might seem that we are coupling our data-handling functions with the REST API, just changing the name of things. This is not so.</p>
<p>As we mentioned <a href="#chapter08-handling-url-query-parameters">earlier</a>, each part of the URL has a specific purpose. The path, such as <code>/data/v1/projects/25</code> is meant to identify a resource, the <code>25</code> in this case being the <code>pid</code>, thus, it matches the concept of a <code>key</code> in an indexed database or any other data-retrieval mechanism.  The data associated with that resource should go elsewhere, <code>req.body</code> in the request or the <code>data</code> argument in each data handling function.  Finally, it is equally fitting that the <code>options</code> come in the form of query parameters in <code>req.query</code>.</p>
<p>Thus, it is far from coincidence.  However, this is in no way enforced by Express or any of the other library modules we have been using. It is just our own convention.</p>
<h2><a class="self-ref" id="chapter09-simplifying-validation-with-middleware" href="#chapter09-simplifying-validation-with-middleware"># </a>Simplifying validation with middleware</h2>
<p>We have already seen how flexible Express can be in the way we can match routes.  We have transformed a large sequential list of routes to a tree quite easily. Routes also allows us to use variable parts in routes and extract them as parameters.</p>
<p>Express is also flexible in the way we handle that route once it has been matched.  So far, we have used the pattern:</p>
<pre><code class="language-js">router.method('route pattern', (req, res) =&gt; {
  // ...
});
</code></pre>
<p>However, Express allows any number of handlers to be chained after each route pattern.</p>
<pre><code class="language-js">router.method('route pattern', handler1, handler2, /* .... */ (req, res) =&gt; {
  // ...
});
</code></pre>
<p>This can be very useful in validating the data received.  It is obvious from our <code>routes.js</code> file how we keep repeating the very same validation code over and over again.  We can simplify this by using chained handlers which is basically what middleware does.</p>
<p>All route handlers have three arguments, <code>req</code> and <code>res</code> which we have been using so far and <code>next</code> which we haven't even mentioned yet.</p>
<p>The third, <code>next</code>, argument is a function that, when called, tells Express to call the next handler in the chain and, if there are no further handlers for that route, to go back to route matching.</p>
<p>Handlers can add information to both <code>req</code> and <code>res</code> and each successive handler in the chain will see the changes the previous one has made on those objects.  That is what, for example, <code>body-parser</code> does.  It reads and parses the information received in the request body and places it in <code>req.body</code>. Then, it calls <code>next()</code> so Express continues matching routes.</p>
<p>We have moved our validators to a separate <code>validators.js</code> file. This is our <code>pid</code> validator:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/validators.js#L12-L19"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/validators.js</div>
    <div class="from">From: 12</div>
    <div class="to">To: 19</div>
  </div>
  <pre><code class="language-js">validatePid: (req, res, next) =&gt; {
  const pid = Number(req.params.pid);
  if (Number.isNaN(pid)) return send400(res);
  req.$valid.keys = {
    pid
  };
  next();
},</code></pre></div>
<p>It converts the <code>:pid</code> parameter from string to number.  If it is <code>NaN</code> it means the conversion failed and sends back a 400 HTTP error. Otherwise, we store the converted <code>pid</code> into <code>req</code> in an object of our own called <code>$valid</code> under <code>keys</code>.  Finally, it calls <code>next</code> to chain into the next validator or the final handler.</p>
<p>The <code>send400</code> function sends our default response to invalid request data:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/validators.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/validators.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">const send400 = (res) =&gt; void res.status(400).send('Bad request');</code></pre></div>
<p>When we return from sending the 400 response, we are not calling <code>next</code> because there is no point in continuing further down the chain, a response has already been sent. We only call <code>next</code> on a successful validation.</p>
<p>The choice of using a <code>req.$valid</code> object to store validated values is completely arbitrary.  It simply needs to be some property that doesn't collide with any existing property names.  Express does not use the <code>$</code> for its properties.  Traditionally, though variable names can start with an underscore <code>_</code> or a dollar sign <code>$</code>, they are somewhat reserved.  Identifiers starting with underscore are meant to signal a <em>private</em> member.  It doesn't meant they are really private in the sense of other languages that make them invisible to other modules, it just signals the intent to keep them private.  In other words, it signals that developers should not count on it.  A developer is expected to support the <em>public</em> interface of their modules.  If any public interface is broken, then you have a <em>backward compatibility</em> issue.  Developers are not expected to support their <em>private</em> interfaces and they signal those by using the underscore prefix.  If you use any private interface from a third party module, you do it at your own risk.</p>
<p>The dollar sign usually signaled temporary or auxiliary variables whose existence is ephemeral. Then came JQuery, but that is another story. So, using <code>$valid</code> under <code>req</code> should be quite safe.</p>
<p>Our validators all assume there is a <code>req.$valid</code> object.  To ensure that, we use another chained handler:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/validators.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/validators.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">const send400 = (res) =&gt; void res.status(400).send('Bad request');</code></pre></div>
<p>We have to put this chained handler before any validators and we already have the perfect place to do so.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/routes.js#L14-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">module.exports = (dataRouter, branch, done) =&gt; {
  const projectsRouter = express.Router();
  dataRouter.use(branch, validators.add$valid, projectsRouter);</code></pre></div>
<p>Our <code>projectsRouter</code> sub-route handler is just another piece of middleware and any number of such handlers can be chained even when defining a new sub-route.  So, we add our <code>add$valid</code> middleware right in front of the sub-route handler to ensure <code>req.$valid</code> will already be available for any handler below.</p>
<p>This makes all our routes quite simple, even boringly so:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/routes.js#L50-L54"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 50</div>
    <div class="to">To: 54</div>
  </div>
  <pre><code class="language-js">projectsRouter.put('/:pid/:tid',
  validators.validateTid,
  validators.validateTaskData,
  (req, res) =&gt; processPrj('updateTask', req, res)
);</code></pre></div>
<p>To PUT (change) a task, we need to validate both the <code>tid</code> (which includes validating the <code>pid</code>) and the data to change.  If each of these validators succeeds, each will call <code>next</code> until the chain falls into our own handler which calls <code>processPrj</code> with the name of the method to execute.  Note that the last handler in the chain does not call <code>next</code> because it will take care of the request itself and no further handlers need to be concerned with it.  If it did call <code>next</code>, Express would continue the route matching process and with no further handlers matching this particular route, it would go all the way until the end and then send a <code>404 not found</code> reply, which is not good, mostly because of the time wasted since the valid reply would have already been sent long before.</p>
<p>The <code>processPrj</code> function has not changed that much from the previous version.  Instead of expecting the <code>keys</code>, <code>data</code> and <code>options</code> arguments, it expects to find those same arguments within <code>req.$valid</code> so it uses those.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-02/server/projects/routes.js#L5-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-02</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">const processPrj = (op, req, res) =&gt; {
  const valid = req.$valid;
  transactions[op](valid.keys, valid.data, valid.options, (err, data) =&gt; {
    if (err) return void res.status(500).send(err);
    if (data === null) return void res.status(404).send('Item(s) not found');
    res.json(data);
  });
};</code></pre></div>
<p>Can we go a little further?  <code>processPrj</code> receives <code>req</code> and <code>res</code> like all handlers. Can we make it a piece of middleware?
Sure!</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-03/server/projects/routes.js#L5-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-03</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">const processPrj = (op) =&gt; (req, res) =&gt; {
  const valid = req.$valid;
  transactions[op](valid.keys, valid.data, valid.options, (err, data) =&gt; {
    if (err) return void res.status(500).send(err);
    if (data === null) return void res.status(404).send('Item(s) not found');
    res.json(data);
  });
};</code></pre></div>
<p>Lets take a look at both versions side by side.  The difference is just in the very first line:</p>
<pre><code class="language-js">// Previous:
const processPrj = (op, req, res) =&gt; {

// Now:
const processPrj = (op) =&gt; (req, res) =&gt; {
</code></pre>
<p>We turned <code>processPrj</code> from a function that receives three arguments into a function that receives the single <code>op</code> argument and returns a function that is the actual handler that will eventually receive the <code>req</code> and <code>res</code> arguments and respond with the requested data, which is what a route handler does.  In other words, <code>processPrj</code> is now a function that returns route handlers already bound to a particular <code>op</code>. The inner function will have access to <code>op</code> in the outer function via closure.  This is called <em>currying</em>.</p>
<p>A route in our list of route handlers ends up quite succinct:</p>
<pre><code class="language-js">projectsRouter.put('/:pid',
  validators.validatePid,
  validators.validatePrjData,
  processPrj('updateProject')
);
</code></pre>
<p>It is just a number of chained middleware and handlers each doing its part in the processing of the request.</p>
<h2><a class="self-ref" id="chapter09-summary" href="#chapter09-summary"># </a>Summary</h2>
<p>Now we have much less code repetition than we had before, all our validation is concentrated each in one simple validator. Should we later change the <code>pid</code>s or <code>tid</code>s to something else instead of plain integers, for example, UUIDs such as <code>{3F2504E0-4F89-41D3-9A0C-0305E82C3301}</code> we can change it in a few places.</p>
<p>Our code coverage also increases.  Since there is less repetition, there are fewer repeated lines and branches that need to be separately tested with extra tests.  Now, with the same number of tests, we go through most of the code.</p>
<p>Another interesting effect in our code coverage is that the column showing the number of times a certain line of code has been used increases since those fewer lines are used more times each.</p>
<p>We haven't added any tests since doing SQL Injection but we certainly should, though they wouldn't add much for the purpose of this book. Please feel free to try on your own. Our validators should be thoroughly checked forcing errors and making sure they detect them. One advantage of putting our validators into a separate file is that they can be tested on their own, without having to go through Express' routing or doing actual SQL transactions.  As a general rule, there should be one set of tests for each file, as a matter of fact, the <code>/test</code> folder should reproduce the file structure of the rest of application, having one test file per application file.</p>
<p>To top this off, we will do further chaining of the JavaScript kind.  The <code>get</code>, <code>post</code>, <code>put</code> and <code>delete</code> methods are also chainable so all our routes definitions can be reduced to the following:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-09-03/server/projects/routes.js#L18-L58"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-09-03</div>
    <div class="filename">File: server/projects/routes.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 58</div>
  </div>
  <pre><code class="language-js">projectsRouter
  .get('/',
    validators.validateOptions,
    processPrj('getAllProjects')
  )
  .get('/:pid',
    validators.validatePid,
    processPrj('getProjectById')
  )
  .get('/:pid/:tid',
    validators.validateTid,
    processPrj('getTaskByTid')
  )
  .post('/',
    validators.validatePrjData,
    processPrj('addProject')
  )
  .post('/:pid',
    validators.validatePid,
    validators.validateTaskData,
    processPrj('addTaskToProject')
  )
  .put('/:pid',
    validators.validatePid,
    validators.validatePrjData,
    processPrj('updateProject')
  )
  .put('/:pid/:tid',
    validators.validateTid,
    validators.validateTaskData,
    processPrj('updateTask')
  )
  .delete('/:pid',
    validators.validatePid,
    processPrj('deleteProject')
  )
  .delete('/:pid/:tid',
    validators.validateTid,
    processPrj('deleteTask')
  )
;</code></pre></div>
</section><section id="chapter10"><h1><a class="self-ref" id="chapter10-client-side" href="#chapter10-client-side"># </a>Client side</h1>
<h2><a class="self-ref" id="chapter10-the-way-not-to-do-it" href="#chapter10-the-way-not-to-do-it"># </a>The way not to do it</h2>
<p>Perhaps the best way to learn why we do things in a certain way is to see what would happen if we did it otherwise.  This is our new <code>index.html</code> file that shows the list of projects in the database.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-01/public/index.html"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-01</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="/node_modules/axios/dist/axios.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      axios.get('/data/v1/projects')
        .then(response =&gt; {
          document.getElementById('contents').innerHTML =
          `&lt;h1&gt;Projects:&lt;/h1&gt;&lt;ul&gt;${
            response.data.map(item =&gt;
              `&lt;li&gt;&lt;a href="project.html?${item.pid}"&gt;${item.name}&lt;/a&gt;&lt;/li&gt;`
            ).join('\n')
          }&lt;/ul&gt;`;
          document.title = "Projects";
        });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>In the body we create a <code>&lt;div id=&quot;contents&quot;&gt;</code> to put our page content in.  We then load Axios, our HTTP request library, from <code>node_modules</code>. We added a new route for static content to our Express server to let it access <code>node_modules</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-01/server/index.js#L18-L19"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 19</div>
  </div>
  <pre><code class="language-js">app.use('/node_modules', express.static(path.join(__dirname, '../node_modules')));
app.use(express.static(path.join(__dirname, '../public')));</code></pre></div>
<p>While the regular <code>use</code> of the <code>express.static</code> middleware is a catch-all for any path not already taken care for, in this new route we specifically tell it to deal with routes pointing to <code>node_modules</code>.  As such, we place it before the catch-all.  Though in this case it wouldn't have made a difference, it is always better to place the more specific routes before the more generic ones.</p>
<p>Since the browser doesn't know about <code>package.json</code> and NodeJS's module search mechanism, we have to be very specific regarding the exact location of the file we are loading as the browser won't look for it.  As a matter of fact, our server-side NodeJS script would load the version in <code>axios/lib</code> while we load the one in <code>axios/dist</code>. They are slightly different and we will see why later.</p>
<p>The code in this page simply sends an HTTP GET request to <code>'/data/v1/projects'</code> using Axios, just as we have already done in our Mocha tests in earlier chapters. On receiving the response, we locate the <code>&lt;div&gt;</code> by its ID and set its <code>innerHTML</code> to the string we compose using ES2015 template strings. With the ability to interpolate any sort of expressions into the template placeholders and the ability to extend to multiple lines, this looks pretty much like using PHP jumping in and out of HTML to PHP mode or, in this case, from template string to JS expression.</p>
<p>We have done pretty much the same with project.html with a different template and a different data request.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-01/public/project.html#L1-L27"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-01</div>
    <div class="filename">File: public/project.html</div>
    <div class="from">From: 1</div>
    <div class="to">To: 27</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="/node_modules/axios/dist/axios.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      axios.get(`/data/v1/projects/${window.location.search.substr(1)}`)
        .then(response =&gt; {
          const prj = response.data;
          document.getElementById('contents').innerHTML =
            `&lt;h1&gt;${prj.name}&lt;/h1&gt;&lt;p&gt;${prj.descr}&lt;/p&gt;&lt;ul&gt;${
              Object.keys(prj.tasks).map((tid) =&gt; {
                const task = prj.tasks[tid];
                return `&lt;li&gt;&lt;input type="checkbox" ${
                  task.completed ? 'checked' : ''
                } /&gt; &amp;nbsp; ${task.descr}&lt;/li&gt;`
              }).join('\n')
            }&lt;/ul&gt;`;
          document.title = `Project ${prj.pid}: ${prj.name}`;
        });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>For <code>project.html</code> we build the URL dynamically:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-01/public/project.html#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-01</div>
    <div class="filename">File: public/project.html</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-js">axios.get(`/data/v1/projects/${window.location.search.substr(1)}`)</code></pre></div>
<p>To try out these pages, we start the server as usual with <code>npm start</code> and then navigate to <code>http://localhost:8080</code> to get the project list and, by clicking on any of the projects, to each of the tasks list.</p>
<p>Depending on which browser we have and which version it is, this app may or may not work. ECMAScript 2015 is just starting to show up in some browsers and neither template strings or fat arrow functions might work. These are changes to the language itself and a pre-ES2015 browser will not even understand the script. It certainly will not work for most of our potential users.</p>
<h2><a class="self-ref" id="chapter10-polyfills" href="#chapter10-polyfills"># </a>Polyfills</h2>
<p>Older browsers will also lack Promises which Axios uses extensively. This is a different kind of error because this can be patched, it is a missing global object which can be added. It can also be a property within an existing object, such as <code>Object.keys</code> which can also be added. These are called <em>polyfills</em> and, if we check, for example, Mozilla's documentation, we <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys#Polyfill">will see</a> such polyfills listed for each method recently added.</p>
<p>Thus, we can change our code to make it available to more browsers.  It doesn't take long, we just need to add a couple of external scripts and change something.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-02/public/index.html#L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-02</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: 10</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-html">&lt;script src="//cdn.polyfill.io/v1/polyfill.min.js?features=Promise" defer async&gt;&lt;/script&gt;</code></pre></div>
<p>We simply added two extra external scripts.  The first one, from <code>polyfill.io</code> is from <a href="http://cdn.polyfill.io/v1/docs/">FT Labs</a>, the web development team at the Financial Times newspaper. It reads the <code>user-agent</code> header from the HTTP request which identifies which browser is making the request, for example, in the one I'm using right now, it shows:</p>
<pre><code>User-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36
</code></pre>
<p>In this case, this strings identifies the browser as Google Chrome major version 48.  It then goes to its own <a href="http://cdn.polyfill.io/v1/docs/features/">features table</a> and decides it doesn't need almost anything and returns less than 1k of polyfills.  On the other hand, if I go to my old laptop with IE9 the polyfills add up to almost 5k. In this case, the base URL has <code>?features=Promise</code> added because developers might not be using Promises at all or might have already been using their own polyfill for that so FT Labs polyfill service doesn't include it by default and you have to request it explicitly. Once again, in modern browsers it wouldn't bother to load it at all since it is already there, but would load it for older browsers.</p>
<h2><a class="self-ref" id="chapter10-transpiling" href="#chapter10-transpiling"># </a>Transpiling</h2>
<p>As for the language issue, it is somewhat more complex because it is a change to the language itself, not just to a part of its built-in library.  To deal with that, we need a <em>transpiler</em>, a sort of compiler that instead of generating native machine code, it simply translates source code from one version of a language to a different version of the very same language.</p>
<p>Here we are using <a href="http://babeljs.io/">Babel</a> which has become the standard.  We are loading the browser version of Babel to let it transpile on the client-side.  To let Babel know what it is expected to transpile, we have changed the <code>&lt;script&gt;</code> tag enclosing our code to signal it as of <code>type=&quot;text/babel&quot;</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-02/public/index.html#L11-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-02</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: 11</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-html">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"&gt;&lt;/script&gt;
&lt;script type="text/babel"&gt;</code></pre></div>
<p>By default the type of <code>&lt;script&gt;</code> tags is <code>text/javascript</code> which will make the browser execute the code within.  However, if the <code>type</code> given is any other, the browser will ignore it.  That gives Babel a chance to do something about that code before the browser attempts to understand it.  Babel searches for all <code>&lt;script type=&quot;text/babel&quot;&gt;</code>, transpiles them and executes the resulting code.</p>
<p>This is what Babel ends up with for the code in in IE9 (Babel skips transpiling features that the browser supports natively so in my latest Chrome, Babel does nothing):</p>
<pre><code class="language-js">function anonymous() {
  'use strict';

  axios.get('/data/v1/projects/' + window.location.search.substr(1)).then(function (response) {
    var prj = response.data;
    document.getElementById('contents').innerHTML = '&lt;h1&gt;' + prj.name + '&lt;/h1&gt;&lt;p&gt;' + prj.descr + '&lt;/p&gt;&lt;ul&gt;' + Object.keys(prj.tasks).map(function (tid) {
      var task = prj.tasks[tid];
      return '&lt;li&gt;&lt;input type=&quot;checkbox&quot; ' + (task.completed ? 'checked' : '') + ' /&gt; &amp;nbsp; ' + task.descr + '&lt;/li&gt;';
    }).join('\n') + '&lt;/ul&gt;';
    document.title = 'Project ' + prj.pid + ': ' + prj.name;
  });
}
</code></pre>
<p>All the fat arrow functions have been changed to regular functions, the <code>const</code>s turned into <code>var</code>s and the template string replaced by a simple concatenation of small segments of string. If <code>this</code> had been used at any point within the fat arrow function, Babel would have provided a copy of the context of the enclosing function for the inner function to use. It is smart enough to know when it is not needed at all so in more modern browsers, it doesn't change the code at all.</p>
<p>When running this version of our client-code, there is a noticeable delay until the page shows up.  This is not just because all of the Babel transpiler had to load but it also has to run and transpile the code.  With a modern browser, it would probably figure out it doesn't really need to do anything at all, but it first has to check it all out.</p>
<p>So, even if not used, Babel is a hefty load. It doesn't make sense to force such a big download and heavy processing to the client.  To any and all clients, some powerful, some not so much, some with good and fast connections, some on a tablet on a 3G cell-phone network.</p>
<p>That is why the above mechanism has been deprecated by the developers of Babel. We are loading the 5.x version of Babel because there is no 6.x version of this particular browser-side transpiler.  I doubt that it has ever been used on a production environment at all. Instead, we will transpile off-line as part of the development process.</p>
<p>To do that, we will install the command-line version of Babel:</p>
<pre><code>npm install --save-dev babel-cli babel-preset-es2015
</code></pre>
<p>This installs Babel and the presets to transpile EcmaScript 2015 and also saves the dependencies to <code>package.json</code>. As shown above, NPM can install more than one package in one go.</p>
<p>We will also add an extra script to <code>package.json</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/package.json#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-03</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"build": "babel client --presets es2015 --out-dir public/lib"</code></pre></div>
<p>This will allow us to transpile every script found in the <code>client</code> folder into old-style JavaScript, using the <code>es2015</code> presets into the <code>lib</code> folder under the <code>public</code> folder which we already reserved for files meant for the browser.</p>
<p>Thus, we need to separate the in-line scripts from the html files and place them in the <code>client</code> folder.  For example, <code>client/project.js</code> looks like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/client/project.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-03</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">axios.get(`/data/v1/projects/${window.location.search.substr(1)}`)
  .then((response) =&gt; {
    const prj = response.data;
    document.getElementById('contents').innerHTML =
      `&lt;h1&gt;${prj.name}&lt;/h1&gt;&lt;p&gt;${prj.descr}&lt;/p&gt;&lt;ul&gt;${
        Object.keys(prj.tasks).map((tid) =&gt; {
          const task = prj.tasks[tid];
          return `&lt;li&gt;&lt;input type="checkbox" ${
            task.completed ? 'checked' : ''
          } /&gt; &amp;nbsp; ${task.descr}&lt;/li&gt;`;
        }).join('\n')
      }&lt;/ul&gt;`;
    document.title = `Project ${prj.pid}: ${prj.name}`;
  });</code></pre></div>
<p>The code is the same as it was within the script tag in <code>projects.html</code>.</p>
<p>Now, if we do:</p>
<pre><code>npm run build
</code></pre>
<p>Babel will create two files in <code>/public/lib</code> for each of the original JS files.  They look just like the one shown before produced by the in-browser transpiler</p>
<p>We now have to include it into the HTML page and drop the Babel in-line compiler:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/public/project.html"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-03</div>
    <div class="filename">File: public/project.html</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="/node_modules/axios/dist/axios.js"&gt;&lt;/script&gt;
    &lt;script src="//cdn.polyfill.io/v1/polyfill.min.js?features=Promise" defer async&gt;&lt;/script&gt;
    &lt;script src="lib/project.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>Finally, since the files in <code>/public/lib</code> are generated as the product of those in <code>/client</code>, we add them to <code>.gitignore</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/.gitignore#L29">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> so they don't get uploaded into the GitHub repository. We also add that folder to <code>.eslintignore</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/.eslintignore#L3">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> so they won't be linted, because they will fail.  We have also added a <code>/client/.eslintrc.json</code> to tell ESLint that the contents of that folder are meant to be run in a browser so it should expect to find well-known globals such as <code>window</code> or <code>document</code> and also tell it to expect <code>axios</code> as a global variable.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-10-03/client/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-10-03</div>
    <div class="filename">File: client/.eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "env": {
    "browser": true
  },
  "globals": {
    "axios": false
  }
}</code></pre></div>
<p>When starting the server via <code>npm start</code> and then pointing the browser to <code>http://localhost:8080</code>, the pages will show up immediately.  Instead of wasting time having the browser load Babel and then letting it transpile the code for us, we did that off-line via <code>npm run build</code> so the transpiled version is immediately available.  All browsers, even modern ones supporting ES2015, will get the old-style JavaScript code which doesn't use the new features.</p>
</section><section id="chapter11"><h1><a class="self-ref" id="chapter11-modules-imports-and-exports" href="#chapter11-modules-imports-and-exports"># </a>Modules, Imports and Exports</h1>
<p>Only recently, with ECMAScript-2015 has JavaScript has built-in support for modules, at least in its syntax since no platform actually knows what to do with it.  Babel helpfully transpiles <code>import x from 'myModule'</code> into <code>const x = require('myModule')</code> which NodeJS understands but no browser would.</p>
<p>The only mechanism to load external modules into a browser is via the <code>&lt;script&gt;</code> tag which is far from perfect.  The biggest issue is that whatever gets loaded goes into the same global namespace as everything else. If we had complete control of what goes into the browser we could be careful of what gets loaded and avoid any name collisions, however, with applications getting ever more complex, this is hard. What if we are using <a href="https://lodash.com/">Lodash</a> and some widget loads <a href="http://underscorejs.org/">Underscore</a> both of which load as <code>window._</code> in the browser? The one that loads last would end up overwriting the other and, though they are more or less compatible, Lodash is a superset of Underscore and whatever incompatibility there might be in between them might ruin our application.</p>
<p>The beauty of the way NodeJS modules load, is that when we <code>require</code> a certain module, we tell it where we want it, both in name and scope; we say <code>const axios = require('axios');</code> because we want it to be called <code>axios</code> in whichever scope that <code>axios</code> variable is being declared and, if we wanted it called something else, we could do, say, <code>const http = require('axios');</code>.  In browser-land, we don't have that option, we load Axios via <code>&lt;script&gt;</code> and it goes into <code>window.axios</code>, we have no control of name (axios) or scope (global).</p>
<p>This prevents the development of modular applications.  In our server script, we broke our simple app into several source files which <em>require</em>d one another each keeping its internals well hidden from each other exposing only what each explicitly exported.  Over time, several mechanisms to fix this were developed and nowadays, two module packagers are at the top, <a href="http://browserify.org/">Browserify</a> and <a href="http://webpack.github.io/">WebPack</a>.</p>
<p>Inadvertently, we have been using WebPack all along. Remember earlier on that we mentioned there were different versions of Axios, one for NodeJS (which we used for our tests) and the browser version?  Our <code>node_modules/axios</code> folder contains two different folders, <code>dist</code> for the browser version and <code>lib</code> for the NodeJS version.  Looking at the first few lines in the code for the <a href="https://github.com/mzabriskie/axios/blob/master/dist/axios.js">browser version</a> we can see it starts with <code>(function webpackUniversalModuleDefinition(root, factory) {</code> and later on we find a lot of lines preceded with <code>/******/</code>.  All those are added by WebPack. The Axios version on <code>/lib</code> is the original, non-packed version and we can see that the same code from <a href="https://github.com/mzabriskie/axios/blob/master/lib/axios.js#L1">/lib/axios.js</a>   starts about line 60 something in <a href="https://github.com/mzabriskie/axios/blob/master/dist/axios.js#L64"><code>/dist/axios.js</code></a> after all the WebPack packaging handling stuff.</p>
<h2><a class="self-ref" id="chapter11-webpack" href="#chapter11-webpack"># </a>WebPack</h2>
<p>To install WebPack, we do as we've been doing so far:</p>
<pre><code>npm i --save-dev webpack
</code></pre>
<p>We can change our code to use <code>require</code> just as we've done in the server-side code:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-01/client/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-01</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const axios = require('axios');
axios.get('/data/v1/projects')
  .then((response) =&gt; {
    document.getElementById('contents').innerHTML =
    `&lt;h1&gt;Projects:&lt;/h1&gt;&lt;ul&gt;${
      response.data.map((item) =&gt;
        `&lt;li&gt;&lt;a href="project.html?${item.pid}"&gt;${item.name}&lt;/a&gt;&lt;/li&gt;`
      ).join('\n')
    }&lt;/ul&gt;`;
    document.title = 'Projects';
  });</code></pre></div>
<p>Which means we no longer need to load Axios separately in <code>index.html</code> since our web-packaged code will already contain it. The earlier <code>&lt;script src=&quot;/node_modules/axios/dist/axios.js&quot;&gt;&lt;/script&gt;</code> is now gone:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-01/public/index.html"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-01</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="//cdn.polyfill.io/v1/polyfill.min.js?features=Promise" defer async&gt;&lt;/script&gt;
    &lt;script src="lib/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>In <code>.eslintrc.json</code> we can now drop declaring <code>axios</code> as a global variable, leaving only the <em>environment</em> declaration:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-01/client/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-01</div>
    <div class="filename">File: client/.eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "env": {
    "browser": true
  }
}</code></pre></div>
<p>We can change our earlier <code>build</code> script in <code>package.json</code> to use WebPack:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-01/package.json#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-01</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"build": "webpack client/index.js public/lib/index.js &amp;&amp; webpack client/project.js public/lib/project.js"</code></pre></div>
<p>So if we now do <code>npm run build</code> we will have our code packaged with Axios. If we look into the resulting files in <code>/public/lib</code> we can recognize our code right after the WebPack un-packager and then the code for Axios.</p>
<p>We can now run this as we did before, we type <code>npm start</code> to launch our server and go to <code>http://localhost:8080</code> in our browser and the app will most likely work if we have an updated browser.  One problem now is that WebPack has packed our code, but has not transpiled it so it still has the ES2015 features.  If we try to run it in an older browser, it will fail.</p>
<h2><a class="self-ref" id="chapter11-packaging-and-transpiling" href="#chapter11-packaging-and-transpiling"># </a>Packaging and Transpiling</h2>
<p>WebPack can use what it calls <em>loaders</em>, utilities that process the code before it gets packed.  Babel has such a loader for WebPack, which we can use:</p>
<pre><code>npm install --save-dev babel-loader babel-core
</code></pre>
<p>We already have <code>babel-preset-es2015</code> installed along <code>babel-cli</code>, otherwise, we should have installed it as well.</p>
<p>To tell WebPack what loaders it should use, we add a configuration file which, by default, is called <code>webpack.config.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-02/webpack.config.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-02</div>
    <div class="filename">File: webpack.config.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">module.exports = {
  module: {
    loaders: [
      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components)/,
        loader: 'babel'
      }
    ]
  }
};</code></pre></div>
<p>Here, we are telling WebPack that for files whose filename match the given regular expression (in this case, they end with <code>.js</code> or <code>.jsx</code>), unless they are under <code>node_modules</code> or <code>bower_components</code>, it should use <code>babel</code> (the <code>-loader</code> suffix is assumed). The <code>.jsx</code> extension is for React files, which we will use later on. <a href="http://bower.io/">Bower</a> is another package manager like NPM which we are not using.  We don't want Babel to waste time trying to transpile code from NPM or Bower libraries because they should already be compatible with old-style JavaScript.</p>
<p>We also need to configure Babel. Earlier on, we did it via an option in the NPM script:</p>
<pre><code>babel client --presets es2015 --out-dir public/lib
</code></pre>
<p>We can also configure Babel via a configuration file called <code>.babelrc</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-02/.babelrc"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-02</div>
    <div class="filename">File: .babelrc</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "presets": ["es2015"]
}</code></pre></div>
<p>After all this, if we do <code>npm run build</code>, we will get both JS files both transpiled and packed.</p>
<p>That means we will no longer be using Babel standalone so we might as well drop <code>babel-cli</code>:</p>
<pre><code>npm uninstall --save-dev babel-cli
</code></pre>
<p>Now, we should make some numbers, the resulting <code>index.js</code> is 32.2kB in size, <code>project.js</code> is 32.4kB.  Most of that is due to Axios and a little bit comes from WebPack which is exactly the same for both.  The difference is in the pre-packaged sources, <code>/client/index.js</code> which is 341 bytes long while <code>/client/project.js</code> is 594 bytes long.</p>
<p>This might seem an extreme situation because we are doing so little in our code, but it is not that different from a real application.  We are using just two common libraries, Axios and WebPack.  In larger applications we would have more such common utilities, for example, standard UI components such as calendars, tabbed interfaces, menus and what not.</p>
<p>We are forcing our web pages to load two scripts which are basically the same.  We can take a look at those two files side by side (using GNU <code>diff</code> or some such) and we will see there is very little difference in between them.</p>
<h2><a class="self-ref" id="chapter11-almost-a-single-page-application" href="#chapter11-almost-a-single-page-application"># </a>Almost a Single Page Application</h2>
<p>We can pack both our client scripts into the same bundle with Axios and WebPack and have our client do just one load. Once the script is in the browser's cache, all pages would benefit from that single download.</p>
<p>To do that, we must first convert our two separate scripts to loadable modules and to do that we have to export something.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/client/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const axios = require('axios');
module.exports = function (contentEl) {
  axios.get('/data/v1/projects')
    .then((response) =&gt; {
      contentEl.innerHTML =
      `&lt;h1&gt;Projects:&lt;/h1&gt;&lt;ul&gt;${
        response.data.map((item) =&gt;
          `&lt;li&gt;&lt;a href="project.html?${item.pid}"&gt;${item.name}&lt;/a&gt;&lt;/li&gt;`
        ).join('\n')
      }&lt;/ul&gt;`;
      document.title = 'Projects';
    });
};</code></pre></div>
<p>We export a function that, when called, will execute mostly the very same code we had so far.  To avoid repetition, the function receives the DOM element that is to receive the content.  We do the same for <code>project.html</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/client/project.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const axios = require('axios');
module.exports = function (contentEl) {
  axios.get(`/data/v1/projects/${window.location.search.substr(1)}`)
    .then((response) =&gt; {
      const prj = response.data;
      contentEl.innerHTML =
        `&lt;h1&gt;${prj.name}&lt;/h1&gt;&lt;p&gt;${prj.descr}&lt;/p&gt;&lt;ul&gt;${
          Object.keys(prj.tasks).map((tid) =&gt; {
            const task = prj.tasks[tid];
            return `&lt;li&gt;&lt;input type="checkbox" ${
              task.completed ? 'checked' : ''
            } /&gt; &amp;nbsp; ${task.descr}&lt;/li&gt;`;
          }).join('\n')
        }&lt;/ul&gt;`;
      document.title = `Project ${prj.pid}: ${prj.name}`;
    });
};</code></pre></div>
<p>Now we have to glue them together which will decide, based on the URL of the page requested, which content to use. Its function is not dissimilar to that of the routers we have been using on the server side so we call it <code>router.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/client/router.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const index = require('./index.js');
const project = require('./project.js');
const contentEl = document.getElementById('contents');
if (/^\/(index\.html)?$/i.test(location.pathname)) {
  index(contentEl);
} else if (/^\/project\.html$/i.test(location.pathname)) {
  project(contentEl);
} else {
  contentEl.innerHTML =
    `Page ${location.pathname} is not available`;
}</code></pre></div>
<p>We require both modules then, depending on the path of the URL requested, we execute one or the other.  The path might be either '/' or <code>/index.html</code> for the default page or <code>/project.html</code>.  If it doesn't match any of the regular expressions for them, we simply show a message. The later should never happen since this script would be loaded by either of those HTML pages.</p>
<p>Now, instead of building two separate packages, we build just one which includes both options.  We can do that by using the WebPack configuration file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/webpack.config.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: webpack.config.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">module.exports = {
  entry: './client/router.js',
  output: {
    path: './public/lib',
    filename: 'bundle.js'
  },
  module: {
    loaders: [
      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components)/,
        loader: 'babel'
      }
    ]
  }
};</code></pre></div>
<p>We are telling WebPack that the entry point for our app is <code>/client/router.js</code> and our packaged file should be called <code>bundle.js</code> and will go into <code>/public/lib</code>.  WebPack loads the file that is the entry point, parses it and locates all its calls to the <code>request</code> function, then loads and parses those looking for their <code>require</code>s and so on until it packages all of the dependencies into <code>bundle.js</code>.</p>
<p>The build script in <code>package.json</code> is now far simpler since all the information is now in the configuration file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/package.json#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"build": "webpack"</code></pre></div>
<p>We also need to change both <code>index.html</code> and <code>project.html</code> because instead of each loading its own separate JavaScript file, they both load <code>bundle.js</code> which, with the router and all, has grown to 33.9kB:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-03/public/index.html"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-03</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Sample Web Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="contents"&gt;&lt;/div&gt;
    &lt;script src="//cdn.polyfill.io/v1/polyfill.min.js?features=Promise" defer async&gt;&lt;/script&gt;
    &lt;script src="lib/bundle.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
<p>The <code>/public/lib</code> folder might still contain <code>index.js</code> and <code>project.js</code> files from previous compilations. We may delete those since they are no longer used.</p>
<p>Not surprisingly, both HTML files are exactly the same, their content determined by the single JavaScript file <code>bundle.js</code> which decides what to show.  Unfortunately, the browser doesn't actually know the two files are alike, since each comes from a different URL it will load each HTML file separately.  We still need the two files because the user might enter either of the two URLs, unless we fix that in the router.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-04/server/index.js#L20-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-11-04</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 20</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">app.use(
  /\/((index.html)|(project.html))?/,
  express.static(path.join(__dirname, '../public/index.html'))
);</code></pre></div>
<p>The routing functions of Express can take regular expressions instead of strings. We use that ability to tell Express that if the user requests <code>/</code>, <code>/index.html</code> or <code>/project.html</code>, it should return the very same <code>index.html</code> file.  We can now delete <code>/public/project.html</code>.</p>
<p>Now it really starts to look like a Single Page Application.  We have a single <code>index.html</code> and a single <code>bundle.js</code> to serve both requests.  However, whenever the user navigates from one page to the other, those requests will still go all the way to the server.  Browsers keep copies of what they load in their caches so, most likely, it will load the cached copy, however, it will still do a quick check with the server to make sure those files are still valid.</p>
<p>It would be good to be able to tell the browser to load it only once and avoid bothering the server with these requests.</p>
<p>It would also be nice to have a more capable router than our improvised <code>router.js</code> is.</p>
<p>Fortunately, there is already software to do both things, client-side routing software can handle routes pretty much as Express does and will capture navigation requests and prevent them from generating unnecessary traffic.</p>
<h2><a class="self-ref" id="chapter11-summary" href="#chapter11-summary"># </a>Summary</h2>
<p>We've seen how we can benefit from the same module-loading capability of NodeJS in the browser by using a bundler such as WebPack or Browserify.</p>
<p>By using a primitive router, we have managed to put our two earlier JS files into a single bundle and by configuring our server, we can deliver our application using only one set of files.</p>
</section><section id="chapter12"><h1><a class="self-ref" id="chapter12-client-side-routing" href="#chapter12-client-side-routing"># </a>Client-side Routing</h1>
<p>In our latest version of <code>router.js</code> we used regular expressions to match the URL of the page requested to the routes we are handling so as to run either of our rendering scripts.  Basically, it is the equivalent of what we've been doing in the server thanks to Express.  There is client software to do the same on the client.  This is our routes configuration</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L10-L18"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 18</div>
  </div>
  <pre><code class="language-js">const routeConfig = {
  path: '/',
  component: App,
  indexRoute: { component: Index },
  childRoutes: [
    { path: 'index', component: Index },
    { path: 'project/:pid', component: Project }
  ]
};</code></pre></div>
<blockquote>
<p>Unlike most of the successive versions of the sample application in this book, the branch <code>chapter-12-01</code> does not work, it is just an intermediate step still incomplete.</p>
</blockquote>
<p>It is easy to relate the array of routes under the <code>childRoutes</code> property, they are basically the same as we had before with some minor differences. The paths  lack the <code>.html</code> ending and the <code>pid</code> parameter is part of the route path instead of a query parameter, so it follows the standard where the item should be identified by the route itself while the query parameters are meant for options.  Also, in the earlier example, it was the <code>project.js</code> module the one that read the <code>pid</code>.  Here it is more like in Express, where the router picks it up from the route itself. Likewise, route matching is sequential within an array so the order is important.</p>
<p>Routes in the client work somewhat different than in the server. In the server routes result in running some piece of script that sends a stream of HTML code, images, JSON data or any other sequential collection of bytes with a single call to <code>res.send()</code> or its variations. There is only one stream of data going out of the server.</p>
<p>Routes in the client are meant to affect a two-dimensional screen where each part of the route might influence a particular section of it.  For example, most web pages will have a standard look, starting with an enclosing frame with the basic color scheme, perhaps the company logo, a copyright sign and so on.  Within that frame there might be other standard sections such as a header or footer, perhaps a menu or tabbed interface and finally, there will be one or more sections that are totally dependent on the route.  For example, a mail-client program will have a main section that contains the list of folders for the <code>/</code>, a list of messages in the inbox for <code>/inbox</code> or a particular message for <code>/inbox/de305d54-75b4-431b-adb2-eb6b9e546014</code>.   Each responds to a fragment of the full URL and they all combine to build the full screen.</p>
<p><img src="routes.png" alt="email program layout"></p>
<p>The image above shows how the different parts of the URL bring up different sections on the screen layout for such application, with each section dealing with a little bit more of the URL and enclosing the more specific section. That is why client-side routes are hierarchical and why our routes from the previous example are <code>childRoutes</code> within the root route. Each section is handled by a <em>component</em>. A typical application will handle more levels than this simple example, nesting many more components. Our router includes two components:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L5-L6"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 6</div>
  </div>
  <pre><code class="language-js">const Index = require('./index.js');
const Project = require('./project.js');</code></pre></div>
<p>Our <code>Index</code> and <code>Project</code> components will be React versions of the former <code>index.js</code> and <code>project.js</code>, as we will soon see.  For our overall frame, responding to the <code>/</code> part of the path, we have an <code>App</code> component which is quite simple indeed:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 8</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-js">const App = (props) =&gt; props.children;</code></pre></div>
<p>Basically, what it says is that the App frame, which will receive some <code>props</code> properties, most of them from the router and amongst them the <code>children</code> property, should just return whatever the children produce. Of course it usually is something more elaborate, some frame, logo or some such, but right now, this should suffice. We must have a single overarching frame, even if it does nothing more than enclosing any number of children because, after all, we only have one screen.</p>
<p>With the <code>indexRoute</code> option we are also telling the router that when no route is specified, the <code>Index</code> component should be shown.  In other words, we are defaulting to showing the <code>Index</code> component whether we explicitly ask for it with <code>/index</code> or not, very much like the regular <code>index.html</code> default.</p>
<h2><a class="self-ref" id="chapter12-react-router" href="#chapter12-react-router"># </a>React Router</h2>
<p>We are using <a href="https://www.npmjs.com/package/react-router">React Router</a> which works along <a href="https://facebook.github.io/react/">React</a> so we first have to install those.</p>
<pre><code class="language-bash">npm i --save react react-dom react-router history
</code></pre>
<p>We install these with the <code>--save</code> option, not <code>--save-dev</code> because they are part of the production code, not just development tools, and so they go into the <code>dependencies</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/package.json#L33-L43">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> section of <code>package.json</code>. Besides React and React Router, we are installing <code>react-dom</code> which contains the parts of React specific to browsers as opposed to other possible environments such as smart-phones or future platforms, and <code>history</code> which complements the router by letting it manipulate the browser history and respond to the back and forward buttons (I don't know why the highlighter put that one in a different color, sorry).</p>
<p>We can then use those packages into our script:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L1-L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">import React from 'react';
import { render } from 'react-dom';
import { Router, browserHistory  } from 'react-router';</code></pre></div>
<p>The magic of Babel transpiling allows us to use both the new ES2015 <code>import</code> statement and the CommonJS <code>require</code> function.  The new <code>import</code> statement allows us to import whole packages such as <code>React</code> or just one or more named exports within a package such as <code>render</code> from <code>react-dom</code> or <code>Router</code> and <code>browserHistory</code> from <code>react-router</code> (actually, it is ES6 <em>destructuring</em> that lets us pick the pieces we want, more on that later).</p>
<p>With all these pieces, we must put this <code>routeConfig</code> to work:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L20-L29"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 20</div>
    <div class="to">To: 29</div>
  </div>
  <pre><code class="language-js">render(
  React.createElement(
    Router,
    {
      routes: routeConfig,
      history: browserHistory
    }
  ),
  document.getElementById('contents')
);</code></pre></div>
<p>We are asking React to <code>render</code> a new React element provided by <code>Router</code> into the <code>&lt;div id=&quot;contents&quot;&gt;</code> we have on our <code>index.html</code> page <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/public/index.html#L8">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  The router will not be a visible DOM element itself, it is the components selected according to <code>routeConfig</code> that will produce the DOM elements we will eventually see in the web page. We provide this <code>Router</code> element with two configuration elements, the <code>routes</code> property points to the <code>routeConfig</code> we have defined and <code>history</code> pointing to <code>browserHistory</code> which is one of several history managers the router can use.</p>
<p>History managers handle the locations the browser visits.  They listen to changes in the locations (i.e.: <code>window.location</code>), such as those seen in the address bar of the browser, and handle them on the client-side, without sending any actual request to the server. The <code>browserHistory</code> manager is the only one that is worth serious consideration in production.  It is not the default because it requires some support from the server.</p>
<p>Instead of the complex route we had to support our earlier primitive version of router <a href="https://github.com/Satyam/book-react-redux/blob/chapter-11-04/server/index.js#L20-L23">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> we now have a simpler, catch-all route in our Express server:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/server/index.js#L18-L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-01</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-js">app.use(express.static(path.join(__dirname, '../public')));

app.get('*', function (request, response) {
  response.sendFile(path.join(__dirname, '../public', 'index.html'));
});</code></pre></div>
<p>Thanks to our client-side router, our application will be able to respond to several <em>virtual</em> URLs which don't actually exist on the server side.  At any time, the user might save one of those URLs or copy and paste them into an e-mail to pass them on to someone else.  What happens when any of those URLs are requested?  If the user had started the application from the home page, all routing would be handled by the client but if, out of the blue, the user requests one of those virtual URLs, the request will go straight to the server, but there is no actual file there to be sent back to the user. That is why we have to add this route, we are letting the client app to handle those virtual routes.  As a rule, wildcard, catch-all routes should go at the end, after all other routes have been dealt with.</p>
<p>So far, if the URL requested was for any of the known paths such as <code>/data/v1/projects</code> there was a piece of script to handle it, otherwise it felt through and got to that <code>express.static</code> middleware which tried to find a file that mapped to the requested path.  Then, if no file was found, it would let the request fall through by calling the <code>next()</code> callback.  If that was the end of the list of routes  and route patterns (which it was) Express, having nowhere else to look for, sends a <code>404 Not Found</code> reply. If there had been any further routes or patterns, Express would try them as well before quiting.</p>
<p>The wildcard <code>'*'</code> route we add means that for absolutely any leftover route the file <code>/public/index.html</code> will be sent.  That will load and run our application and then the client-side router will deal with that route.</p>
<p>This also means that our client-side App must deal with the 404 Not found condition on its own because the server will never send that error on its own. We may do this by adding a wildcard route at the end of the child routes:</p>
<pre><code class="language-js">childRoutes: [
  { path: 'index', component: Index },
  { path: 'project/:pid', component: Project },
  { path: '*', component: NotFound }
]
</code></pre>
<p>Since the routes are matched in sequence, the last wildcard catches any route that failed to match and it shows the <code>NotFound</code> component, which is simply declared like this:</p>
<pre><code class="language-js">const NotFound = () =&gt; (&lt;h1&gt;Not found&lt;/h1&gt;);
</code></pre>
<p>That line of JavaScript doesn't look right, does it? The <code>&lt;h1&gt;Not found&lt;/h1&gt;</code> part should be quoted or something since it is not JavaScript but HTML. Any linter would signal it as an error and Babel would not be able to transpile it as we have configured it so far.   Actually, that is JSX and we will use it more extensively.</p>
<h2><a class="self-ref" id="chapter12-jsx" href="#chapter12-jsx"># </a>JSX</h2>
<p><a href="https://facebook.github.io/jsx/">JSX</a> is an extension to JavaScript designed by Facebook to embed HTML into plain JavaScript.  It is not a proposal for future JavaScript versions nor it is meant to be included in any browser but to be transpiled.</p>
<blockquote>
<p>If I may take a moment to brag about it, back towards the end of 2008 I made a proposal to embed HTML into PHP. I called it <a href="http://www.satyam.com.ar/pht/">PHT</a> which resulted from a merger of the letters in PHp and HTml.  It was an extension to the <a href="http://phpcompiler.org/">PHP Compiler</a> which could generate native code but could also serve as a transpiler.  I used is as a transpiler to create regular PHP out of PHT code.  Mechanisms to publish and make open source contributions back then were not widely available, no GitHub or any such popular sharing mechanisms, so the idea faded away.</p>
</blockquote>
<p>JSX is based on the fact that the less-than sign <code>&lt;</code> is a binary operator in JavaScript so it should be found in between expressions to be compared and it could not possibly be found at the start of an expression.  The JSX transpiler catches those unary <code>&lt;</code> and takes care of dealing with what follows. If we are not sure whether the transpiler would consider a <code>&lt;</code> to be a <em>less than</em> operator or JSX, we just open a parenthesis right before it, like in <code>(&lt;h1&gt; ...)</code> because that ensures the start of a new expression.</p>
<p>None of our code lints or compiles as it is.  We need some extras to deal with JSX:</p>
<pre><code class="language-bash">npm i --save-dev babel-preset-react eslint-config-airbnb eslint-plugin-react
</code></pre>
<p>We are installing a whole bunch of Babel extensions which are encompassed into a preset collection called <code>babel-preset-react</code>.  We need to tell Babel to use that preset by modifying our <code>.babelrc</code> file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/.babelrc"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: .babelrc</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-">{
  "presets": ["es2015", "react"]
}</code></pre></div>
<p>Babel assumes the <code>babel-preset-</code> prefix to the names listed in the <code>presets</code> entry.</p>
<p>We are also loading a new ESLint plugin to handle React, which uses JSX extensively and a rules configuration file <code>eslint-config-airbnb</code>, which is the standard set of routes used by the <a href="https://www.airbnb.com/">Airbnb</a> development team.   We are making use of a nice feature of ESLint which is that we can use different preset configurations in different folders.  We will be still using the <code>eslint-config-standard</code> presets for the server-side code, as we've been doing so far, but will use the Airbnb ones for our client side code.  To do that we simply add a <code>.eslintrc.json</code> file in the <code>/client</code> folder:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/.eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "extends": "airbnb",
  "env": {
    "browser": true
  }
}</code></pre></div>
<p>The rules are extensively explained and, when not purely stylistic, thoroughly justified in their <a href="https://github.com/airbnb/javascript">GitHub repository</a>.  For the purpose of this book, it is just interesting to note that two teams, working in different environments, one in the server using native NodeJS with no transpiling, the other on the client with Babel, can use different styles and rules suited to their environment.</p>
<p>We can use JSX far more extensively.  All our routes can be expressed in JSX:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/router.js#L11-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">render((
  &lt;Router history={browserHistory}&gt;
    &lt;Route path="/" component={App}&gt;
      &lt;IndexRoute component={Index} /&gt;
      &lt;Route path="index" component={Index} /&gt;
      &lt;Route path="project/:pid" component={Project} /&gt;
      &lt;Route path="*" component={NotFound} /&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), document.getElementById('contents'));</code></pre></div>
<p>We have already seen that to embed JSX we just need to start an expression with a <code>&lt;</code>.  We can also embed plain JavaScript into JSX by enclosing any expression in curly brackets.  We do that with <code>{App}</code>, <code>{Index}</code>, <code>{Project}</code>, <code>{NotFound}</code> or <code>{browserHistory}</code>, which are either <code>const</code>ants declared in JavaScript or imported modules.  Any sort of expression can thus be embedded, very much like we do in ES6 template strings by enclosing variable parts in <code>${ }</code>.</p>
<p>The React plugin for Babel creates plain JavaScript for all that JSX, it turns them into calls to <code>React.createElement</code>, in other words, it would transpile it into something pretty much like the code we had before <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-01/client/router.js#L10-L29">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Some of these elements are plain HTML others are React components.  To tell them apart, HTML elements should be all lowercase, <code>&lt;h1&gt;</code> or <code>&lt;div&gt;</code> while React components should start with uppercase <code>&lt;Router&gt;</code> or <code>&lt;IndexRoute&gt;</code>.  That is why we changed our <code>index</code> and <code>project</code> references into <code>Index</code> and <code>Project</code>.</p>
<p>This is how our previous <code>index.js</code> might look using JSX for React:</p>
<pre><code class="language-js">import React from 'react';
import { Link } from 'react-router';
const data = require('./data.js');

export default () =&gt; (
  &lt;div className=&quot;project-list&quot;&gt;
    &lt;h1&gt;Projects:&lt;/h1&gt;
    &lt;ul&gt;{
      Object.keys(data).map(pid =&gt;
        (&lt;li key={pid}&gt;
          &lt;Link to={`project/${pid}`}&gt;
            {data[pid].name}
          &lt;/Link&gt;
        &lt;/li&gt;)
      )
    }&lt;/ul&gt;
  &lt;/div&gt;
);
</code></pre>
<p>This is called a <em>stateless</em> component in React.  It is simply a <em>fat arrow</em> function that returns whatever needs to be displayed. That function is our default export. Our earlier <code>App</code> and <code>NotFound</code> components were simple stateless components.  There are <em>stateful</em> components as well, which we will see later.</p>
<p>We are importing <code>data.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/data.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which is the same <code>data.json</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-06-01/server/data.json">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> turned into a module, so that we don't need to interact with the server. We will do that in later chapters.  Note how we can mix ES6 <code>import</code> statement with CommonJS <code>require</code> in the same module. It is safe to use <code>import</code> with those modules that were exported using ES6 <code>export</code> statement and <code>require</code> with those exported by assigning to the <code>module.exports</code> property, the other combinations are not straightforward.</p>
<p>Besides plain HTML elements, we are using the <code>&lt;Link&gt;</code> component from <code>react-router</code>.  This component renders as a plain <code>&lt;a&gt;</code> element but it is tied internally to the router so the link will not be actually followed but caught by the router and processed so as to activate the corresponding component.</p>
<p>There is also a <code>key</code> attribute added to each <code>&lt;li&gt;</code> element.  This is an optimization for React.  Whenever there is a repeated element such as the list elements within a <code>&lt;ul&gt;</code> it helps if we provide React with a unique id to tell them apart.  It helps it optimize the screen refresh specially when items are added or removed.</p>
<p>We can improve on this component by separating it into the list and the items:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import React from 'react';
import { Link } from 'react-router';
const data = require('./data.js');

const ProjectItem = ({ pid, name }) =&gt; (
  &lt;li className="project-item"&gt;
    &lt;Link to={`project/${pid}`}&gt;
      {name}
    &lt;/Link&gt;
  &lt;/li&gt;
);

ProjectItem.propTypes = {
  pid: React.PropTypes.string.isRequired,
  name: React.PropTypes.string.isRequired,
};

const ProjectList = () =&gt; (
  &lt;div className="project-list"&gt;
    &lt;h1&gt;Projects:&lt;/h1&gt;
    &lt;ul&gt;{
      Object.keys(data).map(pid =&gt;
        (&lt;ProjectItem key={pid} pid={pid} name={data[pid].name} /&gt;)
      )
    }&lt;/ul&gt;
  &lt;/div&gt;
);

export default ProjectList;</code></pre></div>
<p>The <code>ProjectItem</code> component displays a single project item in the list.  We use it within the loop in the project list by using it as a JSX component <code>&lt;ProjectItem&gt;</code> and providing it with what look like HTML attributes, <code>pid</code> and <code>name</code>.</p>
<p>The <code>ProjectItem</code> component receives a <em>properties</em> argument, usually referred to as <code>props</code>, which is an object containing all pseudo-HTML-attributes used when invoked.  Here we are using ES6 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destructuring</a> to explicitly assign the relevant properties within the <code>props</code> object into variables that might well be considered function arguments.  The following segments of code are equivalent:</p>
<pre><code class="language-js">const ProjectItem = ({ pid, name }) =&gt; (
// --------------------
const ProjectItem = props =&gt; {
  let {pid, name} = props;
}
// -----------------
const ProjectItem = props =&gt; {
  let pid = props.pid;
  let name = props.name;
}
</code></pre>
<p>Destructuring is new to JavaScript in ES6, it is not JSX nor React. We have already used <em>destructuring</em> in the <code>import</code> statements.</p>
<p>As a general rule, it is customary to add a <code>className</code> attribute to the outermost element in each component, derived from the name of the component itself. Thus, for <code>ProjectItem</code> we have <code>project-item</code>, for <code>Task</code>, <code>task</code>, each following the standard naming conventions of the language. However, there is nothing but custom preventing us from using <code>ProjectItem</code> as a class name and we might as well have done so. Since <code>class</code> is a reserved word in JavaScript and JSX allows us to mix JavaScript and HTML, it is not good to use <code>class</code> as the HTML attribute name, thus, we must use <code>className</code> instead.  Likewise, in <code>&lt;label&gt;</code> elements, instead of <code>for</code> as we must use <code>htmlFor</code>.</p>
<p>The Router component uses properties to send information to the components.  We use that in <code>project.js</code> which should read the <code>pid</code> from the route. Just as Express does on the server-side, Router also provides a <code>params</code> object with the decoded parameters which we can then retrieve from the <code>props</code> argument using, once again, <em>destructuring</em>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/project.js#L27-L34"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 27</div>
    <div class="to">To: 34</div>
  </div>
  <pre><code class="language-js">const Project = ({ params: { pid } }) =&gt; {
  const prj = data[pid];
  return (&lt;div className="project"&gt;
    &lt;h1&gt;{prj.name}&lt;/h1&gt;
    &lt;p&gt;{prj.descr}&lt;/p&gt;
    &lt;TaskList tasks={prj.tasks} /&gt;
  &lt;/div&gt;);
};</code></pre></div>
<h3><a class="self-ref" id="chapter12-proptypes" href="#chapter12-proptypes"># </a>PropTypes</h3>
<p>React provides us with a mechanism to validate the nature of properties passed to components.  We can declare the data types of those properties by adding a  <code>propTypes</code> static object to our components.  React has two modes of operation, production and development.  In development mode, the default, it will check a good number of things and issue warnings to help us pinpoint any problems ahead of time.  It will skip on this checks when running in production mode. Thus, we can add property validation at no performance cost to us.</p>
<p>For the above <code>ProjectItem</code> component we can add the following property validation:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/client/index.js#L13-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">ProjectItem.propTypes = {
  pid: React.PropTypes.string.isRequired,
  name: React.PropTypes.string.isRequired,
};</code></pre></div>
<p>React provides a good number of <a href="https://facebook.github.io/react/docs/reusable-components.html#prop-validation">PropTypes</a> to check the properties of any component.  We have used <code>string</code> as the data type for <code>pid</code> because object property names are always converted to strings even when they originally were numbers.  The optional <code>isRequired</code> can be added to any other data type to make it mandatory.</p>
<h3><a class="self-ref" id="chapter12-production-version" href="#chapter12-production-version"># </a>Production version</h3>
<p>To create the <em>production</em> version to be deployed in a real life installation we need to create a new configuration file <code>webpack.production.config.js</code> for WebPack.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/webpack.production.config.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: webpack.production.config.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const webpack = require('webpack');

module.exports = Object.assign(require('./webpack.config.js'), {
  plugins: [
    new webpack.DefinePlugin({
      'process.env': {
        'NODE_ENV': JSON.stringify('production')
      }
    })
  ]
});</code></pre></div>
<p>We are using the original configuration file <code>webpack.config.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/webpack.config.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> as the basis and adding one of WebPack's built-in plugins that allows us to add environment variables to the task.  To run it we add another command to our <code>package.json</code> file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/package.json#L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 13</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-json">"production": "webpack -p --config webpack.production.config.js"</code></pre></div>
<p>So, if we do <code>npm run production</code> we will run WebPack with the new configuration file and also with the <code>-p</code> or <em>production</em> option which produces a minimized version with all comments and formatting stripped off.</p>
<p>When we run this NPM script, we will get hundreds of warning messages mostly produced by <a href="https://www.npmjs.com/package/uglify-js">Uglify</a> saying <code>Condition always false</code> or <code>Dropping unreachable code</code> in many locations.  This is because React has plenty of pieces of code to validate and verify the workings of the components we write while in development, each enclosed in a conditional such as:</p>
<pre><code class="language-js">if (process.env.NODE_ENV !== 'production') {
</code></pre>
<p>Since we have set <code>NODE_ENV</code> to <code>production</code> all those pieces of code will not be included in the output, which is good. We will drop those warnings later on but it is good to see them once to appreciate how much code React has to keep us safe.</p>
<p>Our code not only runs faster but after being minified and stripped of all unnecessary code, our <code>bundle.js</code> file has gone down from about 930kB to less than 200kB, almost a fifth in size.</p>
<p>WebPack also has a <code>-d</code> option for development, which produces a <em>SourceMap</em> which cross-references the output code in the bundle to the original code and helps in debugging.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/package.json#L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 11</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-json">"build": "webpack -d",</code></pre></div>
<h3><a class="self-ref" id="chapter12-watch-for-changes" href="#chapter12-watch-for-changes"># </a>Watch for changes</h3>
<p>While doing all these changes, we start getting bored of typing the <code>npm run build</code> command after every single change.  We can simplify this by using WebPack's <em>watch</em> feature with the following extra NPM script command:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/package.json#L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-02</div>
    <div class="filename">File: package.json</div>
    <div class="from">From: 12</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-json">"watch": "webpack -d --watch &amp;",</code></pre></div>
<p>Running WebPack with the <code>--watch</code> option tells it to keep an eye on all the dependencies that make up the bundle.  If any of them change, WebPack will automatically rebuild the bundle.  By adding the <code>&amp;</code> at the end, we leave it to run in the background, freeing us to do <code>npm start</code> to start the web server. We do this only for the development version since that is the one we will be changing continuously.</p>
<h3><a class="self-ref" id="chapter12-final-touches" href="#chapter12-final-touches"># </a>Final touches</h3>
<p>The <code>import</code> statement allows us to import both the whole module at once and specific named exports within it:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/client/index.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-03</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">import React, { PropTypes } from 'react';</code></pre></div>
<p>Here we are importing <code>React</code> wholesale as we've been doing so far but also importing <code>PropTypes</code> as a separate named import.  This makes it shorter for us when declaring the property types:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/client/index.js#L13-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-03</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">ProjectItem.propTypes = {
  pid: PropTypes.string.isRequired,
  name: PropTypes.string.isRequired,
};</code></pre></div>
<p>We are also exporting <code>ProjectItem</code> as a separate named export (in contrast to the default export which is <code>ProjectList</code>).</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/client/index.js#L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-12-03</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-js">export const ProjectItem = ({ pid, name }) =&gt; (</code></pre></div>
<p>Adding that named export doesn't affect our use of the main component, which is the default export, while it allows us to run separate tests on <code>PrjItem</code>.  It is a good practice to provide direct access via named exports to the subcomponents within a module for testing.</p>
<p>Finally, we have added a configuration option to our <code>webpack.production.config.js</code>  <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/webpack.production.config.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> so it will not print those hundreds of warning messages when generating the production version.</p>
<h2><a class="self-ref" id="chapter12-summary" href="#chapter12-summary"># </a>Summary</h2>
<p>We have modified our basic application to run on React, JSX and React Router.</p>
</section><section id="chapter13"><h1><a class="self-ref" id="chapter13-events" href="#chapter13-events"># </a>Events</h1>
<p>Our simple App shows existing information but does not allow us to change it in any way.  To do that we first have to respond to events from the UI.</p>
<p>Regular DOM events provide us with information about the DOM element involved and additional information such as which mouse button was used in a click, which key was pressed with which modifiers, the cursor coordinates and much more.  However, when we develop our own components we should define what information might be of interest to the developer who is using that component and satisfy those expectations.</p>
<p>Take our Task component <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-03/client/project.js#L4-L8">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Could anyone possibly care the precise [x,y] coordinates of the cursor within that component when the item is clicked? Or weather the element was clicked, touched, stared at or thought about?  It would be far more important to provide the <code>tid</code> of the task and its new completion status.  Thus, we might define our <code>onCompletedChange</code> custom event object having just a couple of properties, the <code>tid</code> and the new value for <code>completed</code>. In this way we translate a DOM event closely related to the browser environment into an abstract application-oriented event with information suitable to higher level components.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/client/project.js#L4-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-01</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">export const Task = ({ descr, completed, tid, onCompletedChange }) =&gt; {
  const onClickHandler = ev =&gt; {
    if (ev.button || ev.shiftKey || ev.altKey || ev.metaKey || ev.ctrlKey) return;
    ev.preventDefault();
    onCompletedChange({
      tid,
      completed: !completed,
    });
  };
  return (&lt;li onClick={onClickHandler} className={`task ${completed ? 'completed' : 'pending'}`}&gt;
    {descr}
  &lt;/li&gt;);
};</code></pre></div>
<p>We change the argument list of our <code>Task</code> component to receive extra properties, <code>tid</code> and <code>onCompletedChange</code>.  Actually, <code>Task</code> is still receiving a single argument, an object usually called <code>props</code>, short for <em>properties</em>. We are adding a couple of names of the properties we are destructuring out of that single object.</p>
<p>First, we define an <code>onClickHandler</code> for the DOM <code>onClick</code> event. The <code>onClickHandler</code> function will receive the <code>ev</code> DOM Event object. We check if the event was triggered with any mouse button except the primary one, or modified with the shift, alt, meta or control keys.  If any of those conditions is true, we simply return and do nothing.  Otherwise, we call <code>ev.preventDefault()</code> to signal the DOM that we are taking care of that event and that the default action, whatever that might have been, does not need to be invoked. So far, all these operations are closely related to the DOM and the browser environment. Finally, we call the <code>onCompletedChange</code> callback we received as an argument providing it with an object with the <code>tid</code> of the task clicked and the new value for <code>completed</code>.  This object is the application-oriented event object, it contains no browser information.</p>
<p>As before, the <code>Task</code> component returns the actual elements to be rendered much as we did before, except that we are adding an <code>onClick</code> DOM event handler to the <code>&lt;li&gt;</code> element.  We have also dropped the checkbox we used before to represent the completion status in favor of changing the <code>className</code> of the list item.  This is, in fact, a far more flexible alternative as it gives the graphic designer more options, even simulating a checkbox, via CSS. Consequently, we have added a CSS file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/public/index.css">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which we included in <code>index.html</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/public/index.html#L6">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>To make it work, we have to modify the <code>TaskList</code> component to provide <code>Task</code> with the new arguments.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/client/project.js#L25-L39"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-01</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 25</div>
    <div class="to">To: 39</div>
  </div>
  <pre><code class="language-js">export const TaskList = ({ pid, tasks }) =&gt; {
  const onCompletedChangeHandler = ev =&gt; console.log('Completed Changed', Object.assign(ev, { pid }));
  return (&lt;ul className="task-list"&gt;{
    Object.keys(tasks).map(tid =&gt; {
      const task = tasks[tid];
      return (&lt;Task
        key={tid}
        descr={task.descr}
        completed={task.completed}
        tid={tid}
        onCompletedChange={onCompletedChangeHandler}
      /&gt;);
    })
  }&lt;/ul&gt;);
};</code></pre></div>
<p>We define a trivial handler that simply sends to the console the event object it receives, augmented with the <code>pid</code>.  No browser-related information is handled at this point.  The <code>Task</code> component provides the <code>tid</code> because that is what it deals with, one simple task.  Components higher up may augment this with more information, such as the <code>pid</code>.</p>
<p>Now, we must provide the <code>&lt;Task&gt;</code> component with the new <code>tid</code> and <code>onCompletedChange</code> properties. The list of pseudo-HTML-attributes has grown so large that we had to spread it into multiple lines.  The <code>propTypes</code> for <code>Task</code> has also grown:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/client/project.js#L18-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-01</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">Task.propTypes = {
  completed: PropTypes.bool,
  descr: PropTypes.string,
  tid: PropTypes.string,
  onCompletedChange: PropTypes.func,
};</code></pre></div>
<p>It is important to notice that the way we use the <code>onCompletedChange</code> attribute of the <code>&lt;Task&gt;</code> component looks very much like a DOM event such as the regular <code>onClick</code> attribute on the  <code>&lt;li&gt;</code> element, we just assign a callback function that will be called when the expected event happens. Both callbacks will receive an object which will contain suitable properties.</p>
<p>As we click on the tasks within the project, we will be able to see in the browser console the messages from our handler.  They won't show if we press any of the modifier keys or use any button but the primary one.</p>
<p>We have responded to the UI event signaling the intent of the user to change the completion status of the task but we haven't done that yet.  It should be pretty easy just by changing the event handler in <code>TaskList</code>:</p>
<pre><code class="language-js">const onCompletedChangeHandler = ({ tid, completed }) =&gt; {
  tasks[tid].completed = completed;
};
</code></pre>
<p>We are once again using destructuring to take the <code>tid</code> property out of the event object.  It is easy to set the completion status since <code>TaskList</code> has a reference to all the tasks in the project. Of course, we are reading and changing all this data from an in-memory copy of <code>data.js</code> so all changes are purely local and volatile, but we will get to that in a moment. Now, the problem is to refresh this new state in the UI.</p>
<p>One way to do it would be to call <code>render</code> again as we did in <code>router.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/client/router.js#L11">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  It will work but it is a little too extreme!  It would be fast for a small application such as ours but it makes no sense for anything larger.</p>
<p>React uses a <em>virtual DOM</em>. It keeps a very succinct version of the DOM in memory as it was rendered the last time. Lets call this the <em>existing</em> copy.  When it does a refresh, React produces a new version, the <em>expected</em>.  It then compares the <em>expected</em> against the <em>existing</em> version.   When it finds a difference, it only sends the minimum of commands to change the DOM to reflect the expectations.</p>
<p>Changes to the DOM are expensive, specially if they involve a re-flow of the whole page.  Producing the <em>expected</em> version and comparing it against the <em>existing</em> is relatively cheap, however, it is not free, it does take some effort, less than re-rendering the full DOM but it still takes time.</p>
<p>If we can tell React what has actually been changed, React can do much less work.  To do that, we need our components to remember their previous state and know when that state has changed.  So far, we have used <em>stateless</em> components, we need to go to <em>stateful</em> ones.</p>
<h2><a class="self-ref" id="chapter13-stateful-components" href="#chapter13-stateful-components"># </a>Stateful components</h2>
<p>Stateless components are simple functions that receive a series of properties and return whatever should be rendered.   Stateful components are classes derived from <code>React.Component</code>.  Lets convert our <code>Task</code>  stateless component into a stateful one. Just as we did with <code>PropTypes</code> we extract <code>Component</code> as a separate import from <code>React</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-js">import React, { PropTypes, Component } from 'react';</code></pre></div>
<p>Instead of a simple function, our <code>Task</code> component is now a class:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L4-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">export class Task extends Component {
  constructor(props) {
    super(props);
    this.state = {
      completed: props.completed,
      descr: props.descr,
    };
    this.onClickHandler = this.onClickHandler.bind(this);
  }</code></pre></div>
<p>As all classes, it has a <code>constructor</code> which receives the <code>props</code> argument.  Before doing anything else, it is important to call the constructor of the parent class, in this case, <code>React.Component</code>.  We do this by calling <code>super(props)</code>. React.Component needs to receive those properties for its internal workings.</p>
<p>React knows when to render a component based on its internal state.  It the state has changed, it assumes it needs re-rendering.  This doesn't mean it will completely regenerate the DOM for this component, what it will do is to create that <em>expected</em> in-memory image which, at some point, it will compare to the <em>existing</em> image and, wherever they differ, it will issue the appropriate DOM commands.</p>
<p>One of the tasks of the constructor is to set the initial state of the component.  We do this by setting <code>this.state</code> to an object containing the relevant properties.  We only use <code>descr</code> and <code>completed</code> for the state.  The <code>tid</code> is the primary key for the task so it should not change and doesn't need to be part of the possibly changing state.  The <code>onCompletedChange</code> property shouldn't change either.</p>
<p>Finally, we <code>bind</code> the event handler to <code>this</code>.  As with all event handlers, whether DOM or custom ones, when the handler is called, it is called in the context of the caller or with no context at all.  This means that the handler would not have access to the <code>this</code> of its own class.  We use that handler in the <code>render</code> function and we might bind it there, when it gets used but, as the <code>render</code> function may be called lots of times, it is better to bind it just once in the constructor. Repeatedly calling <code>bind</code> does not only waste time but it leaves behind a small piece of memory allocated for each bound function and those bits end up trashing the memory space and forcing more work on the garbage collector.</p>
<p>The <code>render</code> function is very much like our earlier stateless component:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L22-L31"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 31</div>
  </div>
  <pre><code class="language-js">render() {
  return (
    &lt;li
      onClick={this.onClickHandler}
      className={`task ${this.state.completed ? 'completed' : 'pending'}`}
    &gt;
      {this.state.descr}
    &lt;/li&gt;
  );
}</code></pre></div>
<p>The main difference is that instead of reading <code>descr</code> and <code>completed</code> from the argument list, it reads them from <code>this.state.descr</code> and <code>this.state.completed</code>.  Also, it uses <code>this.onClickHandler</code> instead of accessing <code>onClickHandler</code> via closure as it did before.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L13-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">onClickHandler(ev) {
  if (ev.button || ev.shiftKey || ev.altKey || ev.metaKey || ev.ctrlKey) return;
  ev.preventDefault();
  this.props.onCompletedChange({
    tid: this.props.tid,
    completed: !this.state.completed,
  });
  this.setState({ completed: !this.state.completed });</code></pre></div>
<p>The handler itself does the same.  Instead of accessing the <code>onCompletedChange</code> callback via closure, it reads it from <code>this.props.onCompletedChange</code>.  It does the same with <code>this.props.tid</code>.  That is one of the visible effects of calling <code>super(props)</code> in the constructor, React will copy all the properties received into <code>this.props</code>.  We read <code>completed</code> from <code>this.state.completed</code> instead.  There is a copy of it in <code>this.props.completed</code> just as there are for <code>tid</code> or <code>descr</code> but these copies do not reflect possible changes in the state of the component, they will always retain their original values and won't be affected by whatever the user does.</p>
<p>Thus, as a general rule, those properties that the user might change via some interaction with the UI, be it clicking, touching, typing or whatever, must go into <code>this.state</code> in the constructor and read from there.  The ones that don't change over the lifetime of the component, can be accessed from <code>this.props</code>.</p>
<p>How do we change the state of the component?  Via <code>this.setState</code>.  Except in the constructor, where the state is initialized, we must never set <code>this.state</code> or anything within it directly.  We should always do it via <code>this.setState</code>. This function actually merges the values given to the existing ones.  In our case, we only set <code>completed</code> but that doesn't mean we are wiping out <code>descr</code>, we are merging the new value of <code>completed</code> into the object which also contains the value of <code>descr</code>.</p>
<p>When React detects changes in its state, it triggers the re-rendering process. If we now run this version, we will see the task items switch color as we click on them.  However, though we have changed the state of the component, we have not changed the underlying data itself.  That is why we are still firing the <code>onCompletedChange</code> custom event to notify to whomever it might concern, that the change has been requested.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L41-L43"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 41</div>
    <div class="to">To: 43</div>
  </div>
  <pre><code class="language-js">export const TaskList = ({ pid, tasks, onTaskCompletedChange }) =&gt; {
  const onCompletedChangeHandler = ev =&gt; onTaskCompletedChange(Object.assign(ev, { pid }));
  return (&lt;ul className="task-list"&gt;{</code></pre></div>
<p>The <code>TaskList</code> component itself listens to that event and its handler, adds the <code>pid</code> and fires its own <code>onTaskCompletedChange</code> event.   The <code>Project</code> component listens to this event and finally changes the actual data.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-02/client/project.js#L64-L66"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-02</div>
    <div class="filename">File: client/project.js</div>
    <div class="from">From: 64</div>
    <div class="to">To: 66</div>
  </div>
  <pre><code class="language-js">const onTaskCompletedChangeHandler = ev =&gt; {
  data[ev.pid].tasks[ev.tid].completed = ev.completed;
};</code></pre></div>
<p>Of course, it only changes the local client-side copy of <code>data.js</code>, not the shared one on the server, which we will do later on. It is easy to tell the changes have been preserved by clicking on some of the tasks to change its completion status, selecting another project and then, when going back to the original one, the changes are still there.</p>
<h3><a class="self-ref" id="chapter13-stateless-or-stateful" href="#chapter13-stateless-or-stateful"># </a>Stateless or Stateful</h3>
<p>Stateless components are to be preferred over stateful because, besides being cheap in resources taken, state machines are harder to test and debug.  Calling a stateless component with the same properties will always produce the same output.  In a stateful component, it all depends on the previous state, thus the chances for bugs increases and so does then need for tests.</p>
<p>However, to let React know when a component has changed and, if so, to trigger a re-render, said component needs to know what its previous state was so it can compare it with the new one.  That is why we had to go to a stateful component, that is, a JavaScript class instead of a plain function.</p>
<p><code>React.Component</code> also provides a whole series of methods for particular needs and what they call <a href="https://facebook.github.io/react/docs/component-specs.html">lifecycle events</a> such as <code>shouldComponentUpdate</code> which allows for a finer control on when the component might need re-rendering.</p>
<h2><a class="self-ref" id="chapter13-putting-some-order-into-our-files" href="#chapter13-putting-some-order-into-our-files"># </a>Putting some order into our files</h2>
<p>Our project has grown a little wild, some components are not where they should.  It is customary that components should be each in its own file, except for stateless components when they are totally subordinate to the main component in the file, like <code>ProjectItem</code> is to <code>ProjectList</code>.</p>
<p>The <code>App</code> and <code>NotFound</code> stateless components which were within <code>router.js</code> now have their own separate files <code>app.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/app.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and <code>notFound.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/notFound.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>The <code>NotFound</code> component now informs which path is the one that has not been found.  It gets this information from the Router which provides the component with plenty of information about how it got there.</p>
<p>The <code>App</code> component is now a true frame providing some real options, well... at the moment, just one, listing the available projects.  At this point we are using a plain <code>&lt;Link&gt;</code> component which renders as an HTML anchor <code>&lt;a&gt;</code>.  In a real project, it might be a menu or a tabbed interface.  What it still has from before is a placeholder for the children it will contain: <code>{props.children}</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/app.js#L7">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  This is important.  Whenever there is a <code>&lt;Route&gt;</code> which contains nested <code>&lt;Route&gt;</code> elements, the parent component should have a <code>{props.children}</code> placeholder to put the contents of the components in the nested routes.  Failing to provide such a placeholder will not issue an error nor warning, the children will simply not be rendered.</p>
<p>Our earlier <code>index.js</code> file is now <code>projectList.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/projectList.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> because it actually contains a component called <code>ProjectList</code> which lists the available projects. Likewise, the component imported as <code>Index</code> in <code>router.js</code> is now <code>ProjectList</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/router.js#L5">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. Early on, <code>index.js</code> was the entry point of our pre-React application and that is why it received the default name for an entry-point. That is no longer the case.</p>
<p>The <code>project.js</code> file contained too many components, even a stateful one, which should have been on its own.  Now it is much smaller containing a simple stateless component <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/project.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> with the <code>TaskList</code> and <code>Task</code> components moved into their own files <code>taskList.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/taskList.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and <code>task.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/task.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>We have also changed the routes:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-03/client/router.js#L11-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-03</div>
    <div class="filename">File: client/router.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">render((
  &lt;Router history={browserHistory}&gt;
    &lt;Route path="/" component={App}&gt;
      &lt;Route path="project" component={ProjectList}&gt;
        &lt;Route path=":pid" component={Project} /&gt;
      &lt;/Route&gt;
      &lt;Route path="*" component={NotFound} /&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), document.getElementById('contents'));</code></pre></div>
<p>We have <code>App</code> as an overall container.  It has the main menu, though at this point it has only one option, listing the projects.  This <code>App</code> menu will show if its own path or any of the subordinated paths are matched.  Since one of those paths is <code>'*'</code> which shows the <code>NotFound</code> component, <code>App</code> will always have a match, even if it is <code>NotFound</code>.  That is why we are no longer using <code>IndexRoute</code>.</p>
<p>If the route is <code>/project</code> or <code>/project/:pid</code>, the <code>ProjectList</code> will show.  Once again, it will show with either its own path <code>/project</code> or upon matching any subordinate route <code>/project/:pid</code>.  Notice how the nested paths get concatenated in the actual URL.</p>
<p>In our earlier version, we either had the projects list or the information about a single project.   In this version we have a hierarchy of information starting at the main menu, followed by the projects list and then, if a project is selected, information about it. The nesting of the routes reflects this.</p>
<h2><a class="self-ref" id="chapter13-conditional-rendering" href="#chapter13-conditional-rendering"># </a>Conditional rendering</h2>
<p>We have something that doesn't look nice.  Once a project is selected and its details shown in the bottom panel, the projects list still shows as a link, even though that project has already been selected.  It would be good to highlight the selected project and drop the link around it.</p>
<p>We can easily do this by using the <code>params</code> property that the Router provides our components.  <code>params.pid</code> will be the actual <code>pid</code> of the selected project or <code>undefined</code> if no project has been selected yet.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-04/client/projectList.js#L21-L36"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-04</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 21</div>
    <div class="to">To: 36</div>
  </div>
  <pre><code class="language-js">const ProjectList = ({ children, params }) =&gt; (
  &lt;div className="project-list"&gt;
    &lt;h1&gt;Projects:&lt;/h1&gt;
    &lt;ul&gt;{
      Object.keys(data).map(pid =&gt;
        (&lt;ProjectItem
          key={pid}
          pid={pid}
          name={data[pid].name}
          active={params.pid === pid}
        /&gt;)
      )
    }&lt;/ul&gt;
    {children}
  &lt;/div&gt;
);</code></pre></div>
<p>We then add an <code>active</code> property to the <code>ProjectItem</code> component.  We set it by comparing the <code>pid</code> parameter in the route to the <code>pid</code> of the project being rendered.  If they are the same, then we are rendering the active project.</p>
<p>We use that extra <code>active</code> property in two conditional expressions within <code>ProjectItem</code>.  One of them adds a <code>className</code> to the list item and the other decides whether to show the plain name for the active project or a link to navigate to it.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-04/client/projectList.js#L5-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-04</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">export const ProjectItem = ({ pid, name, active }) =&gt; (
  &lt;li className={`project-item ${active ? 'selected' : ''}`}&gt;
    {
     active
     ? name
     : (&lt;Link to={`/project/${pid}`}&gt;{name}&lt;/Link&gt;)
   }
  &lt;/li&gt;
);</code></pre></div>
<p>We do something very similar in <code>App</code> since, once we have clicked on our single menu item, there is no point in keeping it as a link <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-04/client/app.js#L4-L13">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>Lets go a little further.  Why don't we add a count of pending tasks along the list of projects?  We will provide an extra numeric <code>pending</code> property to <code>ProjectItem</code> so we can show it along each of the project names. We calculate it in <code>ProjectList</code> like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-05/client/projectList.js#L32-L36"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-05</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 32</div>
    <div class="to">To: 36</div>
  </div>
  <pre><code class="language-js">pending={
  Object.keys(data[pid].tasks).filter(
    tid =&gt; !data[pid].tasks[tid].completed
  ).length
}</code></pre></div>
<p>We use <code>Array.filter</code> over each of the tasks in each project to select those which are not yet completed.  Then, we count how many they ended up being.  It might not a good piece of code but it won't last long.  It is there just to show one issue.</p>
<p>We just show that count for each of the items:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-05/client/projectList.js#L5-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-05</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">export const ProjectItem = ({ pid, name, active, pending }) =&gt; (
  &lt;li className={`project-item ${active ? 'selected' : ''}`}&gt;
    {
     active
     ? name
     : (&lt;Link to={`/project/${pid}`}&gt;{name}&lt;/Link&gt;)
   } [Pending: {pending}]
  &lt;/li&gt;
);</code></pre></div>
<p>As we click on the tasks for a particular project, though the marks on the checkboxes change indicating their completion status, the counts of <em>pendings</em> on the projects list don't change at all.  However, if we click on a different project, then the pending counts suddenly get updated to their correct values.</p>
<p>The problem is that though we are updating the data and we are telling <code>TaskList</code> to re-render itself by changing its state, this does not apply to components higher in the hierarchy.  Clicking on any of the project links re-renders them and then the counts are updated.</p>
<p>This was meant to be a simple example of a deeper issue which we will fix this in the next chapter, namely, that it is difficult to keep in sync different views of the same data.</p>
<h2><a class="self-ref" id="chapter13-lodash" href="#chapter13-lodash"># </a>Lodash</h2>
<p>After seeing all those calls to <code>Object.keys</code>, it is time to wonder if there is anything better.  The problem is that though Arrays have <code>.map</code>, <code>.reduce</code> and <code>.filter</code> methods, Objects don't so it is harder to loop over its items. Fortunately there are libraries of utilities to solve this.  One of the best is <a href="https://lodash.com/">Lodash</a> an improved version of <a href="http://underscorejs.org/">Underscore</a> which was named like that because it was usually named with the underscore <code>_</code> symbol.</p>
<p>To use Lodash, we first need to download the package:</p>
<pre><code class="language-bash">npm i --save lodash
</code></pre>
<p>We may load the whole package like this:</p>
<pre><code class="language-js">const _ = require('lodash');
</code></pre>
<p>The examples shown in the documentation of Lodash assume we've loaded it in this way, which makes all of the dozens of functions available at once.  However, this would make WebPack include the whole library in the bundle. A better option for us is to include only the parts we need:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-06/client/projectList.js#L4-L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-13-06</div>
    <div class="filename">File: client/projectList.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-js">const map = require('lodash/map');
const filter = require('lodash/filter');</code></pre></div>
<p>We can clearly see the benefits of Lodash looking at this same segment in both versions side to side (just the width of the cells is quite telling):</p>
<table><tr><th>Before  <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-05/client/projectList.js#L26-L38"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a> </th><th>After <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-06/client/projectList.js#L28-L40"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></th></tr>
<tr><td><pre><code class="lang-js">
Object.keys(data).map(pid =>
   (&lt;ProjectItem
     key={pid}
     pid={pid}
     name={data[pid].name}
     active={params.pid === pid}
     pending={
       Object.keys(data[pid].tasks).filter(
         tid => !data[pid].tasks[tid].completed
       ).length
     }
   /&gt;)
 )
</code></pre></td>
<td><pre><code class="lang-js">
map(data, (prj, pid) =>
  (&lt;ProjectItem
    key={pid}
    pid={pid}
    name={prj.name}
    active={params.pid === pid}
    pending={
      filter(prj.tasks,
        task => !task.completed
      ).length
    }
  /&gt;)
)</code></pre></td></tr></table>
<p>It is worth noting that <a href="https://lodash.com/docs#map"><code>map</code></a> and <a href="https://lodash.com/docs#filter"><code>filter</code></a> work indistinctly in both Array and Objects or, as they are called in Lodash, <em>Collections</em>.</p>
</section><section id="chapter14"><h1><a class="self-ref" id="chapter14-actions-stores-flux-and-redux" href="#chapter14-actions-stores-flux-and-redux"># </a>Actions, Stores, Flux and Redux</h1>
<p>Allowing each React component to deal directly with its own data turns out to be impractical except in the simplest cases.  As we have seen in the previous chapter, when two different components show the same data, there is the problem of how they can notify each other of changes.  If the data resides in a remote server, as is often the case, sharing responsibility on those remote operations further complicates the matter.</p>
<p>A possible solution to these issues comes in the form of <em>actions</em>, <em>stores</em> and a consistent direction in the flow of information.  These ideas were presented by Facebook as the <a href="https://facebook.github.io/flux/">Flux</a> architecture.</p>
<p>Basically, the idea is that all data should reside in a <em>store</em>. Components will always show information from this store. Any external event that might affect the data should trigger an <em>action</em>, a sort of custom event, which broadcasts the request for any change along with the new data and enough context information to figure out where that new data should go. Stores receive these actions and change the data accordingly and then notify the components that subscribed to these notifications.</p>
<p>Lets go back to our example of projects and tasks lists.  In the <code>Task</code> component, when we got a click on the list item we fired our own custom <code>onCompletedChange</code> event. The parent <code>TaskList</code> component subscribed to this custom event and when it received the event, it added its bit of information and fired <code>onTaskCompletedChange</code> which finally reached <code>Project</code> that changed the data. All this passing of information one way and events back up is long and tedious.  If <code>Project</code> had propagated it even further up to <code>ProjectList</code> and made it aware that the pending count had changed it might have updated itself.  However, this would have implied propagating the event through very many components, making them all too dependent on one another. There is not really a single good answer to that way of doing things.</p>
<p>In the Flux architecture, the mechanism is for <code>Task</code>, on receiving the <code>onClick</code> DOM event, to <em>dispath</em> an <em>action</em> indicating the <code>type</code> of action (usually a constant equated to a descriptive string) the <code>tid</code> and <code>pid</code> of the task affected and the new value for <code>completed</code>.</p>
<p>All actions are received and acted upon by the store or stores which hold the data.  Components will subscribe to receive notification of changes in the data they are interested in.  When they get such notification, they refresh themselves reading the newly updated information from the store.</p>
<p>The DOM might not be the only source of <em>actions</em>. Receiving new data from the server is also a valid source of actions, be it in response to an earlier HTTP request or through a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a> <code>message</code> event.</p>
<p>Whichever way it might be triggered, the mechanism is simple and predictable, any sort of external event dispatches an action that goes to the store which then updates the data and notifies the interested components that there have been changes so they can refresh themselves.</p>
<p>All this also makes it easier to test since a test suite is as good a source of actions as any other.</p>
<p>Though Facebook has implemented a <a href="https://www.npmjs.com/package/flux">Flux library</a>, Flux is basically a concept, an architecture, and as such, there are many implementations.  Probably the most popular of them is <a href="http://redux.js.org/">Redux</a> which is what we will use.</p>
<h2><a class="self-ref" id="chapter14-redux" href="#chapter14-redux"># </a>Redux</h2>
<p>To use it we first have to load it:</p>
<pre><code>npm i --save redux
</code></pre>
<p>We need to define the constants that represent the action types.  We add an <code>actions.js</code> file which will just contain action constants which should be unique. We might use the new ES6  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a> object which will always produce unique symbols, but the problem with those is that they are completely local to each client. If we ever plan to send actions from remote sources via WebSockets or any other mechanism, Symbols cannot be serialized into a message.</p>
<p>We only have one action to deal with, toggling the completion state of a task.  We define a constant to represent that action type, which we export.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/actions.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-01</div>
    <div class="filename">File: client/actions.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">export const TASK_COMPLETED_CHANGE = 'Task completed changed';</code></pre></div>
<p>Next we create our store.  We will do it from the <code>data.js</code> using Redux's <a href="http://redux.js.org/docs/api/createStore.html"><code>createStore</code></a> method.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/store.js#L30-L39"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-01</div>
    <div class="filename">File: client/store.js</div>
    <div class="from">From: 30</div>
    <div class="to">To: 39</div>
  </div>
  <pre><code class="language-js">import { createStore } from 'redux';
import data from './data.js';

forEach(data, prj =&gt; {
  prj.pending = filter(prj.tasks, // eslint-disable-line no-param-reassign
    task =&gt; !task.completed
  ).length;
});

export default createStore(reducer, data);</code></pre></div>
<p>We immediately export the store that <code>createStore</code> returns.  That will be our single store for all the application.  We initialize the store with <code>data</code> which we read from <code>data.js</code>. Our store will have a computed <code>pending</code> property which is not present in the raw data so we have to initialize that computed property from the data before creating the store.</p>
<p>The first argument to <code>createStore</code> is a <em>reducer</em>.  In Redux parlance, a <em>reducer</em> is a function that receives the current state of the store and an action and returns the new state of the store.</p>
<p>Our store handles just two cases, one is the <code>TASK_COMPLETED_CHANGE</code> action, the other is <em>anything else</em>.  Redux requires that when a reducer does not recognize an action, it should return the state unmodified.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/store.js#L6-L28"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-01</div>
    <div class="filename">File: client/store.js</div>
    <div class="from">From: 6</div>
    <div class="to">To: 28</div>
  </div>
  <pre><code class="language-js">const reducer = (state, action) =&gt; {
  switch (action.type) {
    case TASK_COMPLETED_CHANGE: {
      return update(
        state,
        {
          [action.pid]: {
            pending: {
              $apply: pending =&gt; (action.completed ? pending - 1 : pending + 1),
            },
            tasks: {
              [action.tid]: {
                completed: { $set: action.completed },
              },
            },
          },
        }
      );
    }
    default:
      return state;
  }
};</code></pre></div>
<p>Our simple reducer switches on <code>action.type</code>.  As mentioned, on the <code>default</code>, we simply return the state, unmodified.  That is the boilerplate code for any reducer, a <code>switch</code> statement branching off based on <code>action.type</code> with the default returning the state as received.</p>
<p>An important design consideration in Redux is that the state object should never be modified, the reducer should always return a new state object, based on a clone of the original one suitably modified. It might seem that all this cloning of potentially large stores might slow things down but, as it turns out, it allows for some optimizations elsewhere that somehow compensate for this. To start with, we read from the store far often than we change it thus a single expensive update pays off if it simplifies very many reads.  It also allows for certain features either impossible or hard to manage in other ways such as <a href="http://redux.js.org/docs/recipes/ImplementingUndoHistory.html">infinite undo/redo</a> since, after all, it is just a matter of keeping track of all those immutable states.</p>
<p>One way to do that would be to do a deep clone of the whole store and then apply the changes. This is terribly expensive so we won't event see how to do it because it is completely out of the question.  Instead we will use the <a href="https://facebook.github.io/react/docs/update.html"><code>update</code></a> add-on by the React team.  There are several other alternatives to this add-on such as  <a href="https://facebook.github.io/immutable-js/">Immutable.Js</a>.</p>
<p>We install the add-on as any other package:</p>
<pre><code class="language-bash">npm i --save react-addons-update
</code></pre>
<p>And <code>require</code> it just as another module, dropping the<code>react-update-</code> prefix and calling it simply <code>update</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/store.js#L2"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-01</div>
    <div class="filename">File: client/store.js</div>
    <div class="from">From: 2</div>
    <div class="to">To: 2</div>
  </div>
  <pre><code class="language-js">const update = require('react-addons-update');</code></pre></div>
<p>Update takes an object and returns a new object made out of parts of the original and parts changed.  Imagine we are changing the completion status of a task in the branch with <code>pid: 34</code>.  Nothing changes in the branch for <code>pid: 25</code> so, what <code>update</code> does is to copy the reference to the whole of the branch for <code>pid: 25</code> without traversing it at all. It will make a clone of the branch for <code>pid: 34</code> but only partially. When it gets to the <code>tasks</code> collection, it will copy over the references to those tasks that are not affected and only clone the one we mean to change.  Finally, it performs the changes.</p>
<p>For <code>TASK_COMPLETED_CHANGE</code>, we do something apparently quite complex:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/store.js#L9-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-01</div>
    <div class="filename">File: client/store.js</div>
    <div class="from">From: 9</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">return update(
  state,
  {
    [action.pid]: {
      pending: {
        $apply: pending =&gt; (action.completed ? pending - 1 : pending + 1),
      },
      tasks: {
        [action.tid]: {
          completed: { $set: action.completed },
        },
      },
    },
  }
);</code></pre></div>
<p>The second argument to <code>update</code> is an object which describes where the changes should go.  The object is not very different from what <code>Object.assign</code> would take as a second argument when doing a merge.  Notice that when we write <code>[action.pid]:</code>, we are using a new ES6 feature called <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names">computed property name</a>, it is not specific to <code>update</code>.</p>
<p>What is specific to <code>update</code> are the property names starting with <code>$</code>.  They are <a href="https://facebook.github.io/react/docs/update.html#available-commands">commands</a> telling <code>update</code> what to do.  For <code>pending</code> we are using a function to return the new value based on the previous value, which <code>$apply</code> provides as an argument.  For <code>completed</code> we are simply setting its new value with <code>$set</code>. The way we updated <code>pending</code> is not foolproof and is not mean to go into production, it was just a means to show how to use <code>$apply</code>.</p>
<p>Consider that if we didn't have <code>update</code>, we might have been forced to write something like this:</p>
<pre><code class="language-js">return mapValues(state, (project, pid) =&gt;
  (
    pid !== action.pid
    ? project
    : {
      name: project.name,
      descr: project.descr,
      pending: project.pending + (action.completed ? - 1 : 1),
      tasks: mapValues(project.tasks, (task, tid) =&gt;
        tid !== action.tid
        ? task
        : {
          descr: task.descr,
          completed: action.completed,
        }
      ),
    }
  )
);
</code></pre>
<p>Using Lodash <a href="http://devdocs.io/lodash~4/index#mapValues">mapValues</a> method we loop over the projects in the store. For all projects with a <code>pid</code> different from the one we are looking for, we simply copy the reference to the current <code>project</code>, not a clone of it (no <code>Object.assign</code>) but the very same one.  When the <code>pid</code> matches the one we mean to change, then we return a new object made of parts of the previous object and a recalculated <code>pending</code>. Then we loop over the tasks and repeat the same logic. We copy over the references to all the tasks we won't change and create a new object for the one we will, with the same <code>descr</code> as it had before but with the new value for <code>completed</code>.</p>
<h2><a class="self-ref" id="chapter14-dispatching-an-action" href="#chapter14-dispatching-an-action"># </a>Dispatching an action.</h2>
<p>To get everything started, the component needs to dispatch the action:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/task.js#L20-L25"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-01</div>
    <div class="filename">File: client/task.js</div>
    <div class="from">From: 20</div>
    <div class="to">To: 25</div>
  </div>
  <pre><code class="language-js">store.dispatch({
  type: TASK_COMPLETED_CHANGE,
  pid: this.props.pid,
  tid: this.props.tid,
  completed,
});</code></pre></div>
<p>The new <code>handler</code> no longer changes the data directly, nor it fires an event for the benefit of the parent component, it simply dispatches the action to the store with all the necessary information.</p>
<p>Any component that needs to be aware of changes in the store needs to subscribe to it.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/task.js#L10-L15"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-01</div>
    <div class="filename">File: client/task.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 15</div>
  </div>
  <pre><code class="language-js">componentDidMount() {
  this.unsubscriber = store.subscribe(() =&gt; this.forceUpdate());
}
componentWillUnmount() {
  this.unsubscriber();
}</code></pre></div>
<p>The <code>componentDidMount</code> and <code>componentWillUnmount</code> methods of <code>React.Component</code> are a good place to subscribe/unsusbscribe since they are complementary to one another. The first happens when the component initializes, the second before it is destroyed. These methods, amongst others, are called <a href="https://facebook.github.io/react/docs/component-specs.html#lifecycle-methods">lifecycle methods</a>.</p>
<p>The <code>store.subscribe</code> method returns a function that, when called, unsubscribes the listener so we save it into a property for later use.  The callback simply calls <code>forceUpdate</code> to get the component re-rendered. This is a bad strategy, as we will see in a moment and should never be done in a real application but, for the time being, it shows how Redux works.</p>
<p>Finally, while initially the component got the list of tasks to enumerate from <code>this.props.tasks</code> now it takes them straight from the store via <code>getState</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/task.js#L27-L29"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-01</div>
    <div class="filename">File: client/task.js</div>
    <div class="from">From: 27</div>
    <div class="to">To: 29</div>
  </div>
  <pre><code class="language-js">render() {
  const task = store.getState()[this.props.pid].tasks[this.props.tid];
  return (</code></pre></div>
<p>We also have to change <code>ProjectItem</code> so it can subscribe to the changes in the count of pending tasks.  Our original <code>ProjectItem</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-06/client/projectList.js#L7-L15">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> was a stateless component declared in <code>projectList.js</code> so we first have to change it to a stateful component so it gets all the extra methods inherited from <code>React.Component</code> such as <code>forceUpdate</code>, <code>componentDidMount</code> and <code>componentWillUnmount</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/projectItem.js#L5-L25">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and put it in its own file.</p>
<p>Subscribing and unsubscribing is just the same as in <code>Task</code> and now instead of reading the data from <code>data.js</code> it reads it from the store via <code>store.getState()</code>. <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/projectItem.js#L12-L14">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></p>
<h2><a class="self-ref" id="chapter14-using-shouldcomponentupdate" href="#chapter14-using-shouldcomponentupdate"># </a>Using shouldComponentUpdate</h2>
<p>As it is, this example is extremely inefficient.  Redux notifies all its subscribers of any change anywhere in the store.  Components cannot tell the store which changes they are interested in.  Forcing an update on any change as we have done so far <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-01/client/task.js#L11">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> is basically the same as re-rendering the whole application on every single change.</p>
<p>We will use another of React's component lifecycle methods called <a href="https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate"><code>shouldComponentUpdate</code></a> that should return a Boolean signaling whether the component should be refreshed or left alone.  The default version always returns true.  We have to override it:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-02/client/task.js#L14-L17"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-02</div>
    <div class="filename">File: client/task.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 17</div>
  </div>
  <pre><code class="language-js">shouldComponentUpdate(nextProps, nextState) {
  const s = this.state;
  return s.descr !== nextState.descr || s.completed !== nextState.completed;
}</code></pre></div>
<p>The method is called just before any changes to either the received properties or the internal state are actually saved. It receives the future, presumably changed, values as arguments and can access the existing ones as <code>this.props</code> and <code>this.state</code>.  We compare the new and existing values of <code>descr</code> and <code>completed</code> and if they have changed, we return true, allowing the refresh to go on.</p>
<p>To have something to compare with, we first store the initial values into <code>this.state</code> in the constructor:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-02/client/task.js#L6-L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-02</div>
    <div class="filename">File: client/task.js</div>
    <div class="from">From: 6</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-js">constructor(props) {
  super(props);
  this.state = this.getTask();
  this.onClickHandler = this.onClickHandler.bind(this);</code></pre></div>
<p>We obtain the values of the task from <code>getTask</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-02/client/task.js#L31-L33"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-02</div>
    <div class="filename">File: client/task.js</div>
    <div class="from">From: 31</div>
    <div class="to">To: 33</div>
  </div>
  <pre><code class="language-js">getTask() {
  return store.getState()[this.props.pid].tasks[this.props.tid];
}</code></pre></div>
<p>And, when there is a change in the store, we update them:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-02/client/task.js#L11-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-02</div>
    <div class="filename">File: client/task.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">componentDidMount() {
  this.unsubscriber = store.subscribe(() =&gt; this.setState(this.getTask()));
}</code></pre></div>
<p>This is one of the reasons why we should never set the <code>state</code> directly, except in the constructor.  The <code>setState</code> method does a number of things before actually changing <code>this.state</code>, one of them being to call <code>shouldComponentUpdate</code> and, if it returns true, it queues the refresh. That is also why we should never access <code>this.state</code> right after calling <code>this.setState</code>.  All changes are asynchronous as they are batched to be done all at once which is more efficient than applying one little change after another.</p>
<p>We apply the same strategy to <code>ProjectItem</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-02/client/projectItem.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<h2><a class="self-ref" id="chapter14-redux-principles" href="#chapter14-redux-principles"># </a>Redux principles</h2>
<p>Redux is based on a few very basic principles.</p>
<h4>Single source of truth</h4>
<p>All data and state information is stored in just one place, the <em>store</em>.  No more wondering where should this or that be stored, who is responsible for changing it or how to notify the interested parties.  All data goes into the store and the reducers change it as requested via actions.</p>
<p>Our store only contains information about projects.  Should we need to store other information, we simply nest the project information under some property within the single store.  For example, instead of creating our store via</p>
<pre><code class="language-js">const store = createStore(reducer, data);
</code></pre>
<p>We might do:</p>
<pre><code class="language-js">const store = createStore(reducer, { projects: data, otherInfo: otherData });
</code></pre>
<h4>Components don't modify the store</h4>
<p>As far as components are concerned, the store is read-only.  Components don't write into the store, they just read from it via <code>getState</code>.  Whenever a change is needed, they <code>dispatch</code> an action with all the required information.</p>
<h4>All actions are handled by <em>reducers</em></h4>
<p>Reducers are functions that receive the current state and an action and return the new state. Though we have just one reducer in our example which receives the whole of the store as its state, in practice, we will write reducers to handle each a little part of the store, and then combine them via the aptly named <code>combineReducers</code> method.  Each set of reducers would receive only the part of the store it is prepared to handle.  For example, if we nested the store as shown earlier, we might have:</p>
<pre><code class="language-js">const reducer = combineReducers({
  projects: projectReducers,
  otherInfo: otherInfoReducers,
});
</code></pre>
<p>Redux will use the property names to extract that part of the hierarchy of data within the store and call the corresponding reducer with only that part.</p>
<h4>Reducers return a new state object</h4>
<p>Reducers should never modify the state received.  They should always return a new state object with the relevant information changed. (Copying references to unmodified branches is Ok)</p>
<h4>Reducers must return the unmodified state on unknown actions.</h4>
<p>All reducers receive all the actions whether they matter to them or not.  Thus, if a reducer doesn't know about a certain action type, it should return the same state it has received instead of <code>null</code> or <code>undefined</code> because some other reducer might deal with that action.</p>
<h4>Reducers must return the default initial state if state is undefined.</h4>
<p>This is usually handled via the new ES6 default argument value feature.</p>
<pre><code class="language-js">const reducer = function(state = someInitialState, action) {/*...*/};
</code></pre>
<h4>All reducers are pure functions</h4>
<p>Reducers should only depend on the arguments it receives, the <code>state</code> and the <code>action</code>.  They should never rely on other possible sources of state information.  These are called <em>pure</em> functions.  They are extremely easy to test since they don't have any memory of previous states which can affect their outcome.</p>
<h2><a class="self-ref" id="chapter14-summary" href="#chapter14-summary"># </a>Summary</h2>
<p>The examples in this chapter have been mainly focused on the basics of Redux, however, Redux is rarely used like this, and we will improve on this shortly. It
was meant as an introduction to the principles behind Redux.</p>
<p>The code in version 14-02 has a minor problem that pops up occasionally: in a certain sequence of clicks, none of the names of the projects becomes clickable. We will come to that shortly.</p>
</section><section id="chapter14a"><h1><a class="self-ref" id="chapter14a-rearranging-the-files" href="#chapter14a-rearranging-the-files"># </a>Rearranging the files</h1>
<p>Our <code>/client</code> folder <a href="https://github.com/Satyam/book-react-redux/tree/chapter-14-02/client">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> is in a quite sorry state.  It has been handy so far to have everything under the same roof, but it has no future.</p>
<p>How to arrange the various source files in an application is always a matter of much discussion.  This is not helped by the fact that the otherwise excellent <a href="http://redux.js.org/index.html">Redux</a> documentation uses an arrangement that is clear for learning Redux but is not useful for a production environment.  Developers start with that structure and soon get stuck, even though the Redux FAQ <a href="http://redux.js.org/docs/FAQ.html#structure-file-structure">clearly states</a> that Redux &quot;... has no direct opinion on how your project should be structured&quot; and refers to several such discussions. The following is just one of those alternatives.</p>
<h2><a class="self-ref" id="chapter14a-the-components-folder" href="#chapter14a-the-components-folder"># </a>The components folder</h2>
<p>We will create a <code>components</code> folder to put all React components together <a href="https://github.com/Satyam/book-react-redux/tree/chapter-14-03/client/components">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> separate from those dealing with the store.</p>
<p>We have two groups of components, those generic ones like <code>app.js</code> and <code>notFound.js</code> that apply to the whole application, and the rest that are specific to handling projects.  The later we put in a folder <code>client/components/projects</code> <a href="https://github.com/Satyam/book-react-redux/tree/chapter-14-03/client/components/projects">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>Besides this <code>/projects</code> folder we would eventually have other folders for other branches of our application and we would surely have a folder with common or shared components that show up here and there around the whole application.</p>
<p>When moving things around like this, import statements with relative references from one file to another become messed around. Suddenly, the <code>../whatever</code> doesn't work any longer and it should become <code>../../whatever</code>. It all becomes very hard to manage.</p>
<p>WebPack uses a <em>resolver</em> to figure out how to solve the path given in an <code>import</code> statement or <code>require</code> call. By default it uses the same rules as NodeJS.  For locations that don't start with <code>./</code>, <code>../</code> or <code>/</code> it assumes they refer to packages in <code>node_modules</code>.  We cannot use references starting with <code>/</code> since we don't know where our developers would download or clone our package.</p>
<p>We can set up aliases for the resolver.  That lets us put our own application files on an equal footing as those from external modules.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/webpack.config.js#L20-L25"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: webpack.config.js</div>
    <div class="from">From: 20</div>
    <div class="to">To: 25</div>
  </div>
  <pre><code class="language-js">resolve: {
  alias: {
    store: join(root, 'client/store'),
    components: join(root, 'client/components')
  }
}</code></pre></div>
<p>With these aliases, WebPack will no longer try to locate <code>components/app.js</code> in <code>node_modules/components</code> but will apply the alias and resolve it to <code>client/components/app.js</code>.</p>
<p>By the way, we have added some constants to help us define those paths:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/webpack.config.js#L1-L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: webpack.config.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">const path = require('path');
const join = path.join;
const root = __dirname;</code></pre></div>
<p>ESLint, though, will complain.  We set our local <code>eslintrc.json</code> configuration file to follow the <code>airbnb</code> rules. Those rules include checking out that the files mentioned in <code>import</code> statements do exist. On its own, that rule-checker does not know about WebPack resolver aliases. To fix that, we need to add another package:</p>
<pre><code class="language-bash">npm i --save-dev eslint-import-resolver-webpack
</code></pre>
<p>And add a setting to our ESLint configuration file to tell it to use that import resolver:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/.eslintrc.json"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/.eslintrc.json</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-json">{
  "extends": "airbnb",
  "env": {
    "browser": true
  },
  "settings": {
    "import/resolver": "webpack"
  }
}</code></pre></div>
<p>Now, we don't have a single relative reference to an imported file starting with <code>../</code>.</p>
<h3><a class="self-ref" id="chapter14a-dropping-the-file-extension" href="#chapter14a-dropping-the-file-extension"># </a>Dropping the file extension</h3>
<p>We have dropped all the <code>.js</code> extensions in our imported files.  Both NodeJS and thus WebPack already assume a <code>.js</code> extension. However, the reason is not to spare us typing time.</p>
<p>Lets imagine we have a <code>components/bigstuff</code> branch in our application and that one of the components, <code>components/bigstuff/bigComponent.js</code> has become very big and we want to break that source file into several pieces.  Or, shall we say that the component needs some other asset and we don't want it to lay around mixed up with other components.</p>
<p>If we import the component as:</p>
<pre><code class="language-js">import Biggie from 'components/bigstuff/bigComponent'
</code></pre>
<p>by omitting the <code>.js</code> extension on the <code>import</code>, we are free to move things around.  We move <code>components/bigstuff/bigComponent.js</code> to <code>components/bigstuff/bigComponent/bigComponent.js</code> and then rename it to <code>components/bigstuff/bigComponent/index.js</code>.  Suddenly we have a whole folder to put our extra assets in, or break our bigComponent into as many pieces as we want.  All our <code>imports</code>, such as the one above, will still work just the same.  WebPack will go from loading <code>bigComponent.js</code> to loading the <code>index.js</code> file under the <code>bigComponent</code> folder and the rest of the application won't notice the switch.</p>
<h3><a class="self-ref" id="chapter14a-delegating-routes" href="#chapter14a-delegating-routes"># </a>Delegating routes</h3>
<p>We don't need to state all our routes in just one place, we may delegate them, specially if they are more-or-less self-contained branches of the application:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/routes.js#L7-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/routes.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-js">import projects from 'components/projects/routes';

export default (
  &lt;Route path="/" component={App}&gt;
    {projects}
    &lt;Route path="*" component={NotFound} /&gt;
  &lt;/Route&gt;
);</code></pre></div>
<p>Instead of getting the main route configuration file involved in the inner workings of that branch, we delegate it to that branch:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/components/projects/routes.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/components/projects/routes.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import React from 'react';
import { Route } from 'react-router';

import ProjectList from './projectList';
import Project from './project';

export default (
  &lt;Route path="projects" component={ProjectList}&gt;
    &lt;Route path=":pid" component={Project} /&gt;
  &lt;/Route&gt;
);</code></pre></div>
<p>Should we later add features to this branch or re-order the existing options, we don't need to go to the top level to fix it.</p>
<h2><a class="self-ref" id="chapter14a-the-store-folder" href="#chapter14a-the-store-folder"># </a>The store folder</h2>
<p>We also create a <code>store</code> folder to put all the Redux-related code. As seen earlier, we have already created an alias for WebPack's resolver to reference this folder <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/webpack.config.js#L22">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  We will create a further <code>store/projects</code> folder for the actions and reducers related to our projects which, for the time being, are the only ones we have.  We will call these <em>sub-stores</em>.</p>
<h3><a class="self-ref" id="chapter14a-actions" href="#chapter14a-actions"># </a>Actions</h3>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/store/projects/actions.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">export const TASK_COMPLETED_CHANGE = 'projects/Task completed changed';

export const completedChanged = (pid, tid, completed) =&gt; ({
  type: TASK_COMPLETED_CHANGE,
  pid,
  tid,
  completed,
});</code></pre></div>
<p>The <code>actions.js</code> file has changed a little bit.  First of all, in order to ensure unique action-type strings, we prefix the string with the name of the folder it is under.  We don't need to add a prefix to the identifier for that action because actions end up all collected together and the name collision would be detected when building the package.</p>
<p>We have also added an <em>action creator</em>.  The <code>completedChanged</code> function makes it easier to assemble the data into the action object.  It doesn't seem a big gain at this point but some actions are a little more complex so it is better to use action creators <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/components/projects/task.js#L24">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> instead of simply use the action type and assemble the action object in the component itself as we had before <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-02/client/task.js#L24-L29">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<h3><a class="self-ref" id="chapter14a-reducer" href="#chapter14a-reducer"># </a>Reducer</h3>
<p>Most of our earlier <code>store.js</code> file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-02/client/store.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> is now in <code>reducer.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/store/projects/reducer.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>In Redux, there is a single store which can be made out of many sub-stores, each with its own reducer. Reducers can be defined for specific parts of the application, but there can only be one store.  That is why we are separating the reducer for the projects, which goes into <code>projects/reducer.js</code> and the creation of the store, which goes elsewhere, as we will see shortly.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/store/projects/reducer.js#L6-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/store/projects/reducer.js</div>
    <div class="from">From: 6</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-js">import data from './data';

forEach(data, prj =&gt; {
  prj.pending = filter(prj.tasks, // eslint-disable-line no-param-reassign
    task =&gt; !task.completed
  ).length;
});

export default (state = data, action) =&gt; {</code></pre></div>
<p>The <code>data.js</code> file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/store/projects/data.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> only contains data for projects so it should go into the <code>projects</code> folder as well.  Instead of initializing the whole store with its data, we initialize it via the reducer. If a reducer is called with an <code>undefined</code> state, it should return the initial state. We use ES6's <em>default parameter value</em> feature to set the value for <code>state</code> if it is <code>undefined</code>.  When Redux initializes, it goes through all its reducers with an empty state to ensure they are all initialized.</p>
<h3><a class="self-ref" id="chapter14a-the-indexjs-file" href="#chapter14a-the-indexjs-file"># </a>The index.js file</h3>
<p>We create a <code>projects/index.js</code> file to consolidate this sub-store into a single export:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/store/projects/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/store/projects/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">export * from './actions';

import reducer from './reducer';
export default reducer;</code></pre></div>
<p>On the one hand we re-export all our named action-type constants and action creator functions and export the reducer as our default export.</p>
<p>In a small sub-store such as this, we might put everything in a single <code>index.js</code> instead of re-exporting the bits and pieces from other files. Either way, the rule should always be:</p>
<ul>
<li>Each folder should have an <code>index.js</code> file which may either contain the code itself or re-export the contents of other files in the folder.</li>
<li>The <em>reducer</em> should be the default export.</li>
<li>Action type constants and action creator functions should be exported as named exports.</li>
</ul>
<h2><a class="self-ref" id="chapter14a-consolidating-the-store" href="#chapter14a-consolidating-the-store"># </a>Consolidating the store.</h2>
<h3><a class="self-ref" id="chapter14a-actions" href="#chapter14a-actions"># </a>Actions</h3>
<p>The <code>store/actions.js</code> file consolidates the actions of all the sub-stores:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/store/actions.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/store/actions.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">export * from './projects';</code></pre></div>
<p>Since we have a single sub-store, it simply re-exports all it finds there. We would keep adding lines like this one for each sub-store we add.</p>
<h3><a class="self-ref" id="chapter14a-creating-the-store" href="#chapter14a-creating-the-store"># </a>Creating the store</h3>
<p>As we can only have one single store, we first need to combine the reducers for each sub-store:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/store/createStore.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/store/createStore.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import { combineReducers, createStore } from 'redux';

import projects from './projects';

const reducers = combineReducers({
  projects,
});

export default () =&gt; createStore(
  reducers
);</code></pre></div>
<p>We do that with the aptly named <code>combineReducers</code> function.  We may import any number of sub-stores just as we did with <code>./projects</code> and combine them all together into a single big reducer.  The reducer for each sub-store will deal only with its branch of data within the single overall store.</p>
<p>When combining the reducers, we are using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Property_definitions">shorthand property name</a> feature of ES6.  In ES5 we would have written:</p>
<pre><code class="language-js">const reducers = combineReducers({
  projects: projects,
});
</code></pre>
<p>The argument to <code>combineReducers</code> is an object and since the property name matches the name of the variable holding the reference to the reducer, we can use the shorthand, however, this also allows us to rename the branch the <code>projects</code> sub-store would be in:</p>
<pre><code class="language-js">const reducers = combineReducers({
  prjs: projects,
});
</code></pre>
<p>Finally we export as a default a function that creates the store via <code>createStore</code> using the reducers we have just combined.</p>
<p>Since now the data for the projects is in a sub-store, we have to change the components to access them from within the correct branch:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/components/projects/projectItem.js#L20-L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/components/projects/projectItem.js</div>
    <div class="from">From: 20</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-js">getProject() {
  return store.getState().projects[this.props.pid];
}</code></pre></div>
<p>Earlier on we had:</p>
<pre><code class="language-js">return store.getState()[this.props.pid];
</code></pre>
<p>If we had renamed the branch when combining the reducers, we should have used that name instead.  We do the same for all components using the store.</p>
<h3><a class="self-ref" id="chapter14a-some-left-over" href="#chapter14a-some-left-over"># </a>Some left-over</h3>
<p>The <code>store/index.js</code> file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/store/index.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> is a temporary patch for this particular version. It allows the components to reach the store quite easily, however, it will be gone shortly.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/components/projects/task.js#L3"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 3</div>
    <div class="to">To: 3</div>
  </div>
  <pre><code class="language-js">import { store } from 'store';</code></pre></div>
<h2><a class="self-ref" id="chapter14a-whats-left-at-the-top" href="#chapter14a-whats-left-at-the-top"># </a>What's left at the top</h2>
<p>We should expect that as our application grows, the possible routes to reach the different parts of it will also grow. That is why it deserves to have a separate file for itself:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/routes.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/routes.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import React from 'react';
import { Route } from 'react-router';

import App from 'components/app';
import NotFound from 'components/notFound';

import projects from 'components/projects/routes';

export default (
  &lt;Route path="/" component={App}&gt;
    {projects}
    &lt;Route path="*" component={NotFound} /&gt;
  &lt;/Route&gt;
);</code></pre></div>
<p>We import the various components from wherever they are and set the routes to reach each of them.  Notice this includes only the definition of the routes, not the initialization of the router itself. We do that, along with doing the initial render and, in the future, any other initialization in <code>index.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-14-03</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import React from 'react';
import { render } from 'react-dom';
import { Router, browserHistory } from 'react-router';

import routes from './routes';

const dest = document.getElementById('contents');

export default render((
  &lt;Router history={browserHistory}&gt;
    {routes}
  &lt;/Router&gt;
), dest);</code></pre></div>
<p>Since now that is our initial entry point, we have to change it in <code>webpack.config.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/webpack.config.js#L6">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></p>
<h2><a class="self-ref" id="chapter14a-why-separate-components-and-store" href="#chapter14a-why-separate-components-and-store"># </a>Why separate components and store</h2>
<p>Looking at the <code>components/projects</code> and <code>store/projects</code> folders, it is fair to ask whether it wouldn't make sense to put the components, actions and stores for <code>projects</code> together in a single folder as a <em>sub-system</em>.</p>
<p>The reason is that there is often not a one-to-one relation in between components and sub-stores.  Different pages within the application may combine different components to provide various views of the data in different sub-stores, for example:</p>
<ul>
<li>A component, directly or through sub-components, might show bits and pieces of data from different sub-stores.</li>
<li>An action generated by a component might affect more than one sub-store.</li>
<li>A sub-store might contain data shown by several components in different parts of the application in various ways.</li>
</ul>
<h2><a class="self-ref" id="chapter14a-summary" href="#chapter14a-summary"># </a>Summary</h2>
<p>We have restructured our files in a way that allows for growth.  We have separated our components per branch (at the moment only one, <code>projects</code>) with space for other branches elsewhere.</p>
<p>We have broken down our single store into sub-stores and combined the reducers to make a single overall store, even though at the moment we have only one sub-store.  It is easy to add other sub-stores under this mechanism.</p>
<p>We have learned to configure WebPack resolver to accept aliases to make it easy to refer to our source files in various locations and told ESLint to recognize those aliases as well.</p>
<p>By dropping the <code>.js</code> extensions in the <code>import</code> statements we gain some liberty in moving our files into separate folders should they grow large or require other assets.</p>
</section><section id="chapter15"><h1><a class="self-ref" id="chapter15-react-and-redux" href="#chapter15-react-and-redux"># </a>React and Redux</h1>
<p>We have used Redux in our React application but in a very basic way.  Actually, Redux is not a part of React at all and it might very well be used with other application frameworks.  It would be good if we could integrate them in a better way.</p>
<p>From our small application, we can see that there are certain parts that are repeated over and over.  We've seen that both <code>ProjectItem</code> and <code>Task</code> which were originally simple stateless components had to be turned into stateful ones ato be able to override three lifecyle methods provided by <code>React.Component</code>, namely <code>componentDidMount</code>, <code>componentWillUnmount</code> and <code>shouldComponentUpdate</code> and use the internal <code>state</code> and in both cases in very much the same way:</p>
<pre><code class="language-js">componentDidMount() {
  this.unsubscriber = store.subscribe(() =&gt; this.setState(this.getXxxx()));;
}
shouldComponentUpdate(nextProps, nextState) {
  const s = this.state;
  return s.x !== nextState.x || s.y !== nextState.y;
}
componentWillUnmount() {
  this.unsubscriber();
}
</code></pre>
<p>In both of them we read the state from the store via <code>store.getStatus()</code>.</p>
<p>It would be great if we could go back to our original stateless components and let some other <em>something</em> deal with the data.  Enter <a href="https://github.com/reactjs/react-redux#react-redux">React-Redux</a></p>
<h2><a class="self-ref" id="chapter15-react-redux" href="#chapter15-react-redux"># </a>React-Redux</h2>
<p>What if we could split those stateful components we had to write into a simple stateless component as we had before, which deals with showing the data and another one that feeds it with the properties we need, taken from the store.</p>
<p>In Redux parlance, these two types of components are called <em>presentational</em> components or simply <em>components</em> and <em>container</em> components.</p>
<p>Presentational components are usually simple functions, not classes, that do the rendering from the data they receive in their <code>props</code>, as our earlier components did. They don't even know Redux exists.</p>
<p>Container components extract the data from the store and provide the contained presentational component with the props it needs.  They don't display anything. Since they are relatively predictable in what they do they just need little configuration.</p>
<p>Conversely, presentational components (since they don't know about Redux) do not dispatch actions.  They fire custom events, as our initial <code>Task</code> component did <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-06/client/task.js#L16-L19">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  The container components are the ones that provide the presentational components with the listeners to those events and then dispatch the actions to the store.</p>
<p>To make it easier for us to write the data containers, we will use <a href="https://github.com/reactjs/react-redux#react-redux">React-Redux</a> so we first have to load it.</p>
<pre><code class="language-bash">npm i --save react-redux
</code></pre>
<p>So far, all our components that needed any data from the store had to import the store instance from the <code>store/index.js</code> file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/store/index.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which we added just as a temporary solution.  We may delete it now.</p>
<p>To make the store available to all data containers, we use the <code>&lt;Provider&gt;</code> component from React-Redux.  We import it as well as the method to create the store:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/index.js#L4-L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-js">import { Provider } from 'react-redux';

import createStore from './store/createStore';

export const store = createStore();</code></pre></div>
<p>We export the created store to make it available for our test suite.  There is no need for the production code to have <code>store</code> exported, but it doesn't hurt performance in any way so, we might as well. We will do the same with several other elements within the application, just for testing purposes.</p>
<p>We wrap all our application in this <code>&lt;Provider&gt;</code> component which takes the <code>store</code> as its single property.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/index.js#L14-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">export default render((
  &lt;Provider store={store}&gt;
    &lt;Router history={browserHistory}&gt;
      {routes}
    &lt;/Router&gt;
  &lt;/Provider&gt;
), dest);</code></pre></div>
<p>In this case, we are wrapping the <code>&lt;Router&gt;</code> component which was our outermost component for the whole application.  If we didn't use Router or used some other router, we would have done the same with whichever React component that happened to be the outermost one. To be precise, we have to wrap anything that might want to use the store, but we assume most of our application will.</p>
<p>Just like <code>&lt;Router&gt;</code>, <code>&lt;Provider&gt;</code> produces no visible output, it will simply provide all our <em>container</em> components with access to the <code>store</code> in a way that does not require us to explicitly import the store instance in each and every source file.</p>
<p>Though components communicate with each other via the properties that they pass down through the hierarchy, sometimes it is good to have some information shared all across the application. That is when React's <a href="https://facebook.github.io/react/docs/context.html">context</a> feature comes handy. Information set as <em>context</em> by one component will be available under <code>this.context</code> to all its children.  This is what <code>&lt;Provider&gt;</code> does, it makes the <code>store</code> available to any possible data container component anywhere in the hierarchy as <code>this.context.store</code>.</p>
<h3><a class="self-ref" id="chapter15-data-containers" href="#chapter15-data-containers"># </a>Data containers</h3>
<p>A quick search for <code>store</code> through the files in the <code>components</code> folder gives us a list of files that need data containers, namely  <code>projectList.js</code>, <code>projectItem.js</code>, <code>project.js</code> and <code>task.js</code>.  Presentational components should not even be aware of Redux or its store so those that currently do import <code>store</code> in the <code>components</code> folder must be changed.</p>
<p>We will use React-Redux <code>connect</code> method to wrap our presentational components with the Redux-aware data-container. It will help us with extracting the information the component needs and turning them into properties.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/components/projects/project.js#L23-L37"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/components/projects/project.js</div>
    <div class="from">From: 23</div>
    <div class="to">To: 37</div>
  </div>
  <pre><code class="language-js">import { connect } from 'react-redux';

export const mapStateToProps = (state, props) =&gt; {
  const pid = props.params.pid;
  const project = state.projects[pid];
  return {
    pid,
    name: project &amp;&amp; project.name,
    descr: project &amp;&amp; project.descr,
  };
};

export default connect(
  mapStateToProps
)(Project);</code></pre></div>
<p>The <code>mapStateToProps</code> function extracts the values we need from the store. It receives the current <code>state</code> of the store and the <code>props</code> just like any other React component.</p>
<p>The function should return an object that will be merged with the properties received from the parent component.  Here, we read the <code>pid</code> property from the Router as <code>props.params.pid</code> and use it to read the <code>project</code> property from <code>state.projects[pid]</code>.  Then we return all the properties <code>Project</code> needs, <code>pid</code>, <code>name</code> and <code>descr</code>.</p>
<p>The <code>connect</code> method uses <code>mapStateToProps</code> to produce a wrapper function which we immediately apply to the presentational <code>Project</code> component.</p>
<p>It might seem strange to go through this two-step process, why not a much simpler:</p>
<pre><code class="language-js">export default connect(Project, mapStateToProps);
</code></pre>
<p>The reason is that <code>connect</code> is ready to be used as a <a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.xwbj3lp0c">decorator</a>, a proposal that didn't get into ES6 though it is planned for ES7, whenever that comes out.  At that time, when declaring <code>Project</code> we would <em>decorate</em> it with <code>connect</code>:</p>
<pre><code class="language-js">@connect(mapStateToProps)
export default Project = ({ pid, name, descr }) =&gt; (
  //....
);
</code></pre>
<p>The new purely presentational <code>Project</code> component is now much simpler:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/components/projects/project.js#L4-L15"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/components/projects/project.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 15</div>
  </div>
  <pre><code class="language-js">export const Project = ({ pid, name, descr }) =&gt; (
  name
  ? (
    &lt;div className="project"&gt;
      &lt;h1&gt;{name}&lt;/h1&gt;
      &lt;p&gt;{descr}&lt;/p&gt;
      &lt;TaskList
        pid={pid}
      /&gt;
    &lt;/div&gt;)
  : (&lt;p&gt;Project {pid} not found&lt;/p&gt;)
);</code></pre></div>
<p>It does no longer care at all about the <code>store</code>, it gets the <code>pid</code>, <code>name</code> and <code>descr</code> as properties from the wrapper and returns the JSX for it. It first checks if there is a <code>name</code> as a signal that a project was found. A user might save the URL for a particular project as a bookmark or send it via email to someone else.  The project might be deleted so it might not be found when that saved URL is used later on.</p>
<p>We no longer export <code>Project</code> as a default.  We still export the component as a named export, along with <code>mapStateToProps</code> for testing purposes but now the default export is now the component wrapped by <code>connect</code>. However, components using <code>&lt;Project&gt;</code> won't notice the difference, whether <code>Project</code> reads the state from the store or uses <code>connect</code>, it really doesn't matter.</p>
<p>It is worth mentioning that the <code>connect</code> function does actually return a React component.  If we install a tool such as <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React Developer Tools</a> in Chrome and look at the component hierarchy, we would see:</p>
<pre><code class="language-html">&lt;Component(Project) .... properties .... &gt;
   &lt;Project .... properties .... &gt;
</code></pre>
<p>The component wrapper that <code>connect</code> produces merges the object that <code>mapStateToProps</code> creates with all the properties it receives, such as the properties set by the Router.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/components/projects/projectItem.js#L18-L34"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/components/projects/projectItem.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 34</div>
  </div>
  <pre><code class="language-js">ProjectItem.propTypes = {
  pid: PropTypes.string.isRequired,
  name: PropTypes.string.isRequired,
  active: PropTypes.bool.isRequired,
  pending: PropTypes.number.isRequired,
};

import { connect } from 'react-redux';

export const mapStateToProps = (state, props) =&gt; {
  const pid = props.pid;
  const project = state.projects[pid];
  return {
    name: project.name,
    pending: project.pending,
  };
};</code></pre></div>
<p>Here, <code>ProjectItem.propTypes</code> lists four properties, however, <code>mapStateToProps</code> returns only two.  The other two, <code>pid</code> and <code>active</code> come from the parent component.  As a matter of fact, <code>mapStateToProps</code> itself reads <code>props.pid</code> and uses it to fetch the <code>project</code>, however, it doesn't need to return the <code>pid</code> as it is already there.</p>
<p>Naming the function <code>mapStateToProps</code> is purely conventional, it doesn't even need to be a separate named function, the mapper could have been provided to <code>connect</code> as an anonymous function defined on the spot.  However, giving it a separate name and, specially, exporting it as a named export makes it accessible for unit testing.</p>
<p>We have placed the data container wrapper within the same file because it is very tightly related to it, some separate the presentational component from the data container. This seems quite pointless as one doesn't make sense without the other.  The only possible reason to do that is to enable unit testing of the presentational component without the need to provide a working store but we already export the presentational component as a named export so it is accessible to testing software.</p>
<p>In the documentation for Redux, the author creates two folders, <code>components</code> that contains components that don't have access to the store and <code>containers</code> for those that use <code>connect</code>.  Though that separation is handy for the reader of those samples to easily find the <em>connected</em> files, there is no reason to do that in a production environment.  A <em>connected</em> component is used no differently than an <em>unconnected</em> one.  As long as its properties are well documented and are satisfied by the parent component, they just behave pretty much the same.</p>
<h3><a class="self-ref" id="chapter15-dispatching-actions" href="#chapter15-dispatching-actions"># </a>Dispatching actions</h3>
<p><code>connect</code> also allow us to dispatch actions.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/components/projects/task.js#L43-L52"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 43</div>
    <div class="to">To: 52</div>
  </div>
  <pre><code class="language-js">import { completedChanged } from 'store/actions';

export const mapDispatchToProps = (dispatch) =&gt; ({
  onCompletedChange: ({ pid, tid, completed }) =&gt; dispatch(completedChanged(pid, tid, completed)),
});

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Task);</code></pre></div>
<p>Besides <code>mapStateToProps</code>, connect may take an optional second argument, usually called <code>mapDispatchToProps</code> that returns an object containing a series of custom event handlers that will also be merged into the properties of the contained component.</p>
<p>In this case we declare <code>onCompletedChange</code> which will receive a custom event object made of the <code>pid</code>, <code>tid</code> and <code>completed</code>.  Unsurprisingly, this custom event looks pretty much as the one we had several chapters back <a href="https://github.com/Satyam/book-react-redux/blob/chapter-13-01/client/project.js#L4">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, and it is used by the <code>Task</code> component in the same way:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/components/projects/task.js#L4-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">const onClickHandler = ev =&gt; {
  if (ev.button || ev.shiftKey || ev.altKey || ev.metaKey || ev.ctrlKey) return;
  ev.preventDefault();
  onCompletedChange({
    pid,
    tid,
    completed: !completed,
  });
};</code></pre></div>
<p>The <code>mapDispatchToProps</code> receives a reference to the <code>dispatch</code> method already bound to the store so it can be easily accessed via closure by the custom event handlers.  The handler simply has to dispatch the action produced by the <code>completedChanged</code> action creator function which it previously imported from <code>store/actions</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/components/projects/task.js#L46"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 46</div>
    <div class="to">To: 46</div>
  </div>
  <pre><code class="language-js">onCompletedChange: ({ pid, tid, completed }) =&gt; dispatch(completedChanged(pid, tid, completed)),</code></pre></div>
<p>The <code>Task</code> component passed from being a sub-class of <code>React.Component</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-14-03/client/components/projects/task.js#L5-L40">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> being a simply stateless component <a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/components/projects/task.js#L3-L21">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<h2><a class="self-ref" id="chapter15-refreshing" href="#chapter15-refreshing"># </a>Refreshing</h2>
<p>We have seen earlier how to use the <code>shouldComponentUpdate</code> method of <code>React.Component</code> to tell React whether to bother to redraw the component or not.  Being able to do that offers a great performance boost.</p>
<p>React-Redux already does that for us. It does a shallow compare of the object returned from <code>mapStateToProps</code> with the previous version which it kept from before.  It also compares the properties it receives with their previous version.  It will redraw the contained component only if there has been any changes.</p>
<p>There are two important points to make here.  First is that the compare is a shallow compare.  <code>connect</code> will not detect changes in values deep in an object hierarchy and so the screen will fail to refresh.  That is why it is better to have <code>mapStateToProps</code> return an object containing simple values and not full objects with values nested deep inside them, as <code>connect</code> does not do an expensive deep compare.</p>
<p>Second, the first stage of that shallow compare is to see whether the objects are the same, that is, their references are the same.  Here is where the immutability of the store can be of great benefit.  If we manage to make <code>connect</code> compare object references, instead of the values contained within those objects, we can improve performance.</p>
<p>For example, in <code>Task</code>, we may switch from doing this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/components/projects/task.js#L33-L41"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 33</div>
    <div class="to">To: 41</div>
  </div>
  <pre><code class="language-js">export const mapStateToProps = (state, props) =&gt; {
  const pid = props.pid;
  const tid = props.tid;
  const task = state.projects[pid].tasks[tid];
  return {
    descr: task.descr,
    completed: task.completed,
  };
};</code></pre></div>
<p>To this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-02/client/components/projects/task.js#L33-L37"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-02</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 33</div>
    <div class="to">To: 37</div>
  </div>
  <pre><code class="language-js">export const mapStateToProps = (state, props) =&gt; {
  const pid = props.pid;
  const tid = props.tid;
  return state.projects[pid].tasks[tid];
};</code></pre></div>
<p>In the first case we are returning a new object made of the same properties as the original. This new object fails the first check of the shallow compare since the references are obviously not the same, thus forcing the comparer to check the values.  In the new version, if we return the reference to the object in the store if the object references are the same, being immutable, the contents have to be the same.</p>
<p>It is not so easy to decide what to do with <code>TaskList</code>. Before we had:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-01/client/components/projects/taskList.js#L24-L26"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-01</div>
    <div class="filename">File: client/components/projects/taskList.js</div>
    <div class="from">From: 24</div>
    <div class="to">To: 26</div>
  </div>
  <pre><code class="language-js">export const mapStateToProps = (state, props) =&gt; ({
  tasks: state.projects[props.pid].tasks,
});</code></pre></div>
<p>and now:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-02/client/components/projects/taskList.js#L24"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-02</div>
    <div class="filename">File: client/components/projects/taskList.js</div>
    <div class="from">From: 24</div>
    <div class="to">To: 24</div>
  </div>
  <pre><code class="language-js">export const mapStateToProps = (state, props) =&gt; state.projects[props.pid];</code></pre></div>
<p>In the new version we are returning a reference to the project data in the store itself.  We only need the <code>tid</code>s  of the tasks in it for <code>TaskList</code> to iterate on them.  We are also returning the other properties of the project, such as the <code>name</code>, <code>descr</code> and <code>pending</code> count.  Should any of those change, the component would be redrawn as well.  The <code>name</code> and <code>descr</code> are unlike to change very often, but the <code>pending</code> count might.  Would this have a significant impact in the performance of the application?  The only way to know is to gather performance data with both versions, there is no way to know in advance.</p>
<p>We must definitely not do it in <code>ProjectList</code>.  We still have:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-02/client/components/projects/projectList.js#L31-L33"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-02</div>
    <div class="filename">File: client/components/projects/projectList.js</div>
    <div class="from">From: 31</div>
    <div class="to">To: 33</div>
  </div>
  <pre><code class="language-js">export const mapStateToProps = state =&gt; ({
  projects: state.projects,
});</code></pre></div>
<p>We might be tempted to simplify it to:</p>
<pre><code class="language-js">export const mapStateToProps = state =&gt; state;
</code></pre>
<p>The application would still work, however, right now our store only contains data about projects but that may not be so in the future.  <code>state.projects</code> is just one sub-store within the store, but there is a good chance we will have more and, if any of those stores change, <code>ProjectList</code> would be re-rendered even if nothing within our sub-store changed.  In this case, we must avoid trying to play the shallow compare in our favor because it will hurt us in the long run.</p>
<h2><a class="self-ref" id="chapter15-summary" href="#chapter15-summary"># </a>Summary</h2>
<p>We have used React-Redux to simplify access to the data in our store. By letting the <code>connect</code> method to deal with the store, we have greatly simplified our components which are, once again, stateless functions.</p>
<p>Though the main, default export for each of the source files is now the wrapped component which, for any parent component using it should be indistinguishable from the original one, we have also provided plenty of named exports to many elements within such as the original, unwrapped stateless component, <code>mapStateToProps</code> and <code>mapDispatchToProps</code>.</p>
<p>These exports should allow us to test those parts of the separately from the whole wrapped component, which would require us to actually have a store.  To test the mappers, we only need simple stubs to stand in for the store.  If we test the unwrapped component and the mappers, we can be very certain the whole would work as the <code>connect</code> method is already thoroughly tested elsewhere.</p>
</section><section id="chapter16"><h1><a class="self-ref" id="chapter16-tools-and-helpers" href="#chapter16-tools-and-helpers"># </a>Tools and helpers</h1>
<p>With abstractions such as React and Redux, it gets hard to figure out what is actually happening when something goes wrong using a regular JavaSript debugger.  That is when we most need debugging tools.  There are developer tools available for both.</p>
<h2><a class="self-ref" id="chapter16-react-developer-tools" href="#chapter16-react-developer-tools"># </a>React Developer Tools</h2>
<p>Available for <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">Google Chrome</a> and <a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/">Firefox</a> it adds a <code>React</code> tab to the debugging pane which allows us to see the rendered components, their properties and the state of stateful components. If a component has references to DOM elements, the <a href="https://facebook.github.io/react/docs/more-about-refs.html">ref</a> pseudo-attribute, it will also list those.</p>
<p>For the components that have declared their intent to access the context it will show it. Redux data containers access the store via the context so it will show it, however, it will not show the state, since it is not public, only the public methods, which are not helpful at all.  For that, we need the following:</p>
<h2><a class="self-ref" id="chapter16-redux-dev-tools" href="#chapter16-redux-dev-tools"># </a>Redux Dev Tools</h2>
<p>We can install <a href="https://www.npmjs.com/package/redux-devtools">redux-devtools</a> as usual:</p>
<pre><code class="language-bash">npm i -save-dev redux-devtools
</code></pre>
<p>We then have a couple of options.  There is a set of NPM modules that we can install to create our own interface on any browser.  However, life is much simpler if we use the add-on for <a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">Google Chrome</a> which will simply add another tab to our debugging pane and requires just a very small change to our code.  When creating the store, instead of</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-02/client/store/createStore.js#L9-L11"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-02</div>
    <div class="filename">File: client/store/createStore.js</div>
    <div class="from">From: 9</div>
    <div class="to">To: 11</div>
  </div>
  <pre><code class="language-js">export default () =&gt; createStore(
  reducers
);</code></pre></div>
<p>we must do:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-01/client/store/createStore.js#L9-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-16-01</div>
    <div class="filename">File: client/store/createStore.js</div>
    <div class="from">From: 9</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-js">export default () =&gt; createStore(
  reducers,
  process.env.NODE_ENV !== 'production' &amp;&amp; window.devToolsExtension
  ? window.devToolsExtension()
  : undefined
);</code></pre>:</div>
<p>Back in <a href="#chapter12-production-version">chapter 12</a> we defined a production configuration for WebPack, <code>webpack.production.config.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-12-02/webpack.production.config.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  In it, we defined a global <code>process.env.NODE_ENV</code> variable set to <code>'production'</code>.  React uses that variable to drop large pieces of its code that are great for development but only hurt performance when in production.  We are using the same trick here. By checking we are not in production mode, we only load the extension when needed and if it is available.</p>
<p>The Redux tab will show each action as it happens along its payload and the state of the store as it changes.  It also lets us reset the store to its initial state or step back.</p>
<p>The NPM versions requires a more involved setup but it has various loggers that offer several alternatives, such as logging just actions of a certain type or dispatching actions at will.  Here we have further reasons <strong>not</strong> to use <code>Symbol()</code> for action types.  Though Redux allows it and we would be able to see them logged, we wouldn't be able to set a filter on them or dispatch such types.</p>
<h2><a class="self-ref" id="chapter16-react-performance-tools" href="#chapter16-react-performance-tools"># </a>React Performance tools</h2>
<p>It is never a good idea to start thinking about performance until we have a solid application up and running, however, since we are listing debugging tools, we should mention React's own performance tool  <a href="https://facebook.github.io/react/docs/perf.html">react-addons-perf</a>.</p>
<p>As with all packages, it has to be loaded:</p>
<pre><code>npm i --save-dev react-addons-perf
</code></pre>
<p>React add-ons are still distributed along the main React package thus all the <code>react-addon-xxxx</code> modules are just stubs to reach the already existing module and it still possible to do so, plenty of articles out there still describe this, however this is discouraged since it will not be so in the future. We will do it the now standard way:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-01/client/index.js#L6-L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-16-01</div>
    <div class="filename">File: client/index.js</div>
    <div class="from">From: 6</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-js">if (process.env.NODE_ENV !== 'production') {
  window.Perf = require('react-addons-perf'); // eslint-disable-line global-require
}</code></pre></div>
<p>Once again we check the <em>environment</em> to ensure the performance add-on will never be added in the production version.</p>
<p>We had to add a comment for ESLint to allow the use of <code>require</code> within a conditional.  ESLint is giving us good advise. Since WebPack does a static analysis of the source code looking for <code>import</code> and <code>require</code> statements it packages everything into the bundle. WebPack cannot evaluate conditionals thus it includes everything, just in case. That is why ESLint warns us, we might believe we are doing some conditional loading but, in reality, we are bloating the bundle with all the external modules from the start. However, the above conditional compares two constants and doesn't depend on execution.  <a href="https://www.npmjs.com/package/uglify-js">Uglify-JS</a>, the JavaScript minifier, does analyze these static conditionals and will drop the code above. The loaded module, not being referenced from anywhere, will also be dropped, even after WebPack has placed it in the bundle. Thus, we can tell ESLint that it is fine to do that here.</p>
<p>We save the <code>Perf</code> object globally in order to make it available everywhere in the application, even right from the browser's debugging console.</p>
<p>When we want to check the performance of a part of our application, we call <code>Perf.start()</code>. We can type that command right into the debugger console.  When we reach the end of the section we wanted to test, we call <code>Perf.end()</code>.</p>
<p>At that point, we have several commands available, all of which print right into the browser console.  The most useful of those is <a href="https://facebook.github.io/react/docs/perf.html#perf.printwastedmeasurements"><code>Perf.printWasted()</code></a>.  With luck, it will print an empty Array, otherwise, it will show a listing of those components that were called to render, but produced no changes in the DOM so they were a waste of time.</p>
<p>All times shown in all the print commands are relative values. When in development mode, React is much slower than in production mode.  If a generic performance measurement tool is used, we would see that validating the component's <code>props</code> via the <code>propTypes</code> object takes an inordinate amount of time.  This nor the collection of performance information happens in production mode where the times are much lower.</p>
<h2><a class="self-ref" id="chapter16-webpack-warnings" href="#chapter16-webpack-warnings"># </a>WebPack warnings</h2>
<p>When generating the production version via <code>npm run production</code>, WebPack will produce pages and pages of warnings.  This might be interesting so we can actually see how much of React validation code is dropped in the production version. We can also see how our own load of <code>react-addons-perf</code> gets dropped in production mode.  However, it really isn't very helpful so we might want to drop it.  To do that, we need to turn warnings off by adding the following to the configuration file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-01/webpack.production.config.js#L10-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-16-01</div>
    <div class="filename">File: webpack.production.config.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-js">new webpack.optimize.UglifyJsPlugin({
  compressor: {
    warnings: false
  }
})</code></pre></div>
<p>The Uglify plugin is automatically added when WebPack is run with the <code>-p</code> option but to change the default options for the uglifier (that is, the minifier, which produces a small but <em>ugly</em> version of our script), we need to declare it explicitly.</p>
<h2><a class="self-ref" id="chapter16-ui-components" href="#chapter16-ui-components"># </a>UI components</h2>
<p>We don't really need to start the graphic design of our pages from scratch, there are a good number of UI components available. Some libraries offer single individual components, but others offer comprehensive sets of the most often used components with a consistent look and feel derived from well known UI libraries, such as Twitter's <a href="http://react-bootstrap.github.io/">Bootstrap</a>, Google's <a href="http://www.material-ui.com/#/">Material Design</a> or Thinkmill's <a href="http://elemental-ui.com/">Elemental</a>, all ported to React.</p>
<p>All these libraries contain not only simple stateless components to produce nicely styled UI elements (though that makes a large part of it) but also complex stateful components such as dropdown menus.  We will not use any of those libraries in the example in this book to avoid confusion in between what our code does and what the imported style library does.</p>
<h2><a class="self-ref" id="chapter16-flux-standard-actions" href="#chapter16-flux-standard-actions"># </a>Flux Standard Actions</h2>
<p>Actions must have a <code>type</code> property but the rest is left for us to determine. We have created our actions much like standard DOM event objects, where all the information is flat at the top of the object.  However, the action object is clearly split in between the mandatory <code>type</code> and a payload, which is what the resolver acts upon.</p>
<p>It makes sense to formalize this split and also standardize some other possible contents. That is what the <a href="https://github.com/acdlite/flux-standard-action">Flux Standard Action</a> does.  The FSA action object will always contain the mandatory <code>type</code> property and usually will contain a <code>payload</code> property which is an object with the associated data.  It may also contain <code>error</code> and <code>meta</code> properties. There are several <a href="https://github.com/acdlite/flux-standard-action#libraries">libraries</a> that help in handling FSA actions.</p>
<p>This is particularly useful when dealing with remote servers.  It is often the case that the data associated with the action must be sent to the server. It is easier if all this data is under a single property <code>payload</code> that can be passed on verbatim rather than having to filter <code>type</code> out of the action object.  Also, by having all our data under <code>payload</code> we are free to have a piece of data called <code>type</code> without conflicting with the action <code>type</code>.</p>
<p>Since remote operations are also subject to all sorts of potential exceptional conditions, it is also good to have a standard place to put any error information within the action object, hence the optional <code>error</code> property.</p>
<h2><a class="self-ref" id="chapter16-navigating" href="#chapter16-navigating"># </a>Navigating</h2>
<p>We have used the <code>&lt;Link&gt;</code> component from React-Router to let the user navigate, but what happens when we want to navigate from our code?</p>
<p>Components which are direct descendants of a <code>&lt;Route&gt;</code> already receive as properties the <code>router</code> object which provides several <a href="https://github.com/reactjs/react-router/blob/master/docs/API.md#pushpathorloc">navigation methods</a>.  We could simply navigate to the root by doing:</p>
<pre><code class="language-js">this.props.router.push('/')
</code></pre>
<p>However, those components that are further down away from <code>&lt;Route&gt;</code> have no access to these methods unless the intermediate components trouble themselves passing <code>router</code> down.   To make them available to any component, React-Router provides a Higher-order Component or <em>HoC</em> in React parlance.  We have already used a HoC, the <code>connect</code> method of React-Redux is, in fact, a HoC.</p>
<p>We will make a contrived example to show how to use it by modifying the <code>NotFound</code> component. We won't be committing this version to GitHub.  Since <code>NotFound</code> is a direct child of a <code>&lt;Route&gt;</code>, it already has access to <code>router</code> but lets imagine it doesn't.  We will add a simple link to let the user go back to wherever it was before getting there.</p>
<pre><code class="language-js">import React, { PropTypes } from 'react';
import { withRouter, routerShape } from 'react-router';

const NotFound = props =&gt; {
  const onClickHandler = ev =&gt; {
    ev.preventDefault();
    props.router.goBack();
  };
  return (
    &lt;div&gt;
      &lt;h1&gt;Not found&lt;/h1&gt;
      &lt;p&gt;Path: &lt;code&gt;{props.location.pathname}&lt;/code&gt;&lt;/p&gt;
      &lt;a href=&quot;#&quot; onClick={onClickHandler}&gt;Go Back&lt;/a&gt;
    &lt;/div&gt;
  );
};

NotFound.propTypes = {
  location: PropTypes.shape({
    pathname: PropTypes.string,
  }),
  router: routerShape,
};

export default withRouter(NotFound);
</code></pre>
<p>In the code line right above we are wrapping the <code>NotFound</code> component with <code>withRouter</code> right before exporting it.  We imported <code>withRouter</code> from <code>react-router</code>.  Once wrapped, <code>NotFound</code> will receive an extra property <code>router</code>.  To get it validated we must declare it in <code>NotFound.propTypes</code> using <code>routerShape</code> as its descriptor which React-Router also provides. We could have validated it as a simple <code>React.PropTypes.object</code> but it wouldn't validate its contents.</p>
<p>We changed the stateless component to respond to an <code>onClick</code> event on an <code>&lt;a&gt;</code> element we've added.  The <code>onClickHandler</code> first prevents the default action and, instead, uses <code>props.router.goBack()</code> to navigate back.</p>
<h2><a class="self-ref" id="chapter16-class-names" href="#chapter16-class-names"># </a>Class Names</h2>
<p>Creating class names dynamically leads to some ugly and complicated code:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-02/client/components/projects/task.js#L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-02</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 16</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">className={`task ${completed ? 'completed' : 'pending'}`}</code></pre></div>
<p>The <a href="https://www.npmjs.com/package/classnames"><code>classnames</code></a> package greatly simplifies those expressions by allowing us to combine any number of class names, some of them conditional, and produce a single string.  We then could have written:</p>
<pre><code class="language-js">className={ classnames('task', { completed, pending: !completed })) }
</code></pre>
<p><code>classnames</code> takes any number of arguments. If an argument is a string, it concatenates into the output string. If it is an object, it loops through it and adds the property names of those whose values evaluate to true.  Thus, in the case above, it will always include <code>'task'</code> and will add <code>'completed'</code> if <code>completed</code> is true and <code>'pending'</code> if not.</p>
<p>React-Router also lets us play with some class names.  The <code>&lt;Link&gt;</code> component has an <code>activeClassName</code> property that can be set to any string. If the current URL of the page either starts with or matches (when <code>onlyActiveOnIndex</code> is true) the location this link is pointing to, <code>&lt;Link&gt;</code> will add the value of the <code>activeClassName</code> value to its <code>className</code> attribute.  This is meant to highlight the link when the location it points to is active, for example, in menus, to highlight the chosen option, or the active tab on a tabbed interface.  We can use it in <code>ProjectItem</code> to show the active project.  We can reduce the code from this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-15-02/client/components/projects/projectItem.js#L4-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-15-02</div>
    <div class="filename">File: client/components/projects/projectItem.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">export const ProjectItem = ({ pid, name, active, pending }) =&gt; (
  &lt;li className={active ? 'selected' : ''}&gt;
    {
      active
      ? name
      : (
        &lt;Link to={`/projects/${pid}`}&gt;
          {name}
        &lt;/Link&gt;
      )
    } [Pending: {pending}]
  &lt;/li&gt;
);</code></pre></div>
<p>To this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-01/client/components/projects/projectItem.js#L4-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-16-01</div>
    <div class="filename">File: client/components/projects/projectItem.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">export const ProjectItem = ({ pid, name, pending }) =&gt; (
  &lt;li className="project-item"&gt;
    &lt;Link
      to={`/projects/${pid}`}
      activeClassName="disguise-link"
    &gt;
      {name}
    &lt;/Link&gt; [Pending: {pending}]
  &lt;/li&gt;
);</code></pre></div>
<p>The <code>disguise-link</code> className simply hides the visual clues of the link so it doesn't show as such <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-01/public/index.css#L17-L22">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  The link would still work, though it would produce no visible effect since it is already there, but with the link disguised there is little reason for the user to click on it.</p>
<p>We can prevent the navigation by listening to the <code>onClick</code> event and checking whether the route this link points to is the one active right now and preventing the default action if it is.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-02/client/components/projects/projectItem.js#L9-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-16-02</div>
    <div class="filename">File: client/components/projects/projectItem.js</div>
    <div class="from">From: 9</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">onClick={ev =&gt; {
  if (router.isActive(`/projects/${pid}`, true)) {
    ev.preventDefault();
  }
}}</code></pre></div>
<p>To use <code>router.isActive</code> we have to use the <code>withRouter</code> HoC as described in the previous section.</p>
<p>Since the <code>active</code> property is no longer needed, we dropped both in <code>ProjectItem</code> and also in <code>ProjectList</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-02/client/components/projects/projectList.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> where it was being generated.</p>
<p>Now comes the bad news.  Our application no longer works right.  If we run the application at this point and click on the projects to switch from one another, something funny happens.  The pane below changes to reflect the project just selected, but the link we've just clicked remains as a link.  The problem is that in the previous version, by passing the <code>pending</code> property from <code>ProjectList</code>, which changed with each route, React detected that change in properties and re-rendered <code>ProjectItem</code>.  Now, with no change in the properties, React is not aware that anything has changed.</p>
<p>If we check on any of the tasks, suddenly, the links in the list of projects get updated.  That is because the <code>pending</code> count has changed and <code>connect</code> has detected that change and ordered a refresh.</p>
<p>Part of the problem is that most of our components use <code>connect</code> to subscribe to changes in the store and change accordingly but the location information is not saved in the store so, when the location changes, components are not notified.</p>
<p>There is a further problem with not saving the location information in the store, the snapshots that the <em>undo</em> and <em>redo</em> operations require would be incomplete. We would be able to update the screen to reflect the state of the store at any point, but the URL displayed in the address bar of the browser would remain unchanged, not reflecting what is being shown.</p>
<h2><a class="self-ref" id="chapter16-react-router-redux" href="#chapter16-react-router-redux"># </a>react-router-redux</h2>
<p>This package allows us to store the location information in the store so it can be restored from any snapshot.</p>
<p>Setting up 'react-router-redux' is just a matter of following a series of recipes which are of little interest to us.  They would make sense if we got deep down into the technical details of it, but it is beyond the scope of this book.</p>
<p>We can see those changes in the following comparison in between versions <a href="https://github.com/Satyam/book-react-redux/compare/chapter-16-02...chapter-16-03">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  As usual, the lines on a light green background are additions, the ones in red are deletions.</p>
<p>Using the Redux Developer Tools we installed earlier, we can see the effect of changing location on the store.  Our store now has two sub-stores, <code>projects</code> and <code>routing</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/createStore.js#L6-L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-16-03</div>
    <div class="filename">File: client/store/createStore.js</div>
    <div class="from">From: 6</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-js">const reducers = combineReducers({
  projects,
  routing: routerReducer,
});</code></pre></div>
<p>When creating the store we are combining our reducer with the <code>routerReducer</code> that <code>react-router-redux</code>, which handles the <code>routing</code> sub-store.  That is what the developer tools show.</p>
<p>They also show something else, there is a <code>@@router/LOCATION_CHANGE</code> action with is the one that produces the changes in the store.  We can dispatch those same actions from our code or, even easier, we can use the <a href="https://github.com/reactjs/react-router-redux#pushlocation-replacelocation-gonumber-goback-goforward">action creators</a> that <code>react-router-redux</code> provides.  Anywhere in our code we can include and use all or any of them:</p>
<pre><code class="language-js">import { push, replace, go, goBack, goForward } from 'react-router-redux';
</code></pre>
<p>As with any action creator, we may use them with <code>store.dispatch</code> or, in a connected component within <code>mapDispatchToProps</code>.  For example, in response to a <em>Cancel</em> button, we might want to go back to the previous page:</p>
<pre><code class="language-js">import { goBack } from 'react-router-redux';

export const mapDispatchToProps = dispatch =&gt; ({
  cancelButtonHandler: () =&gt; dispatch(goBack())
});
</code></pre>
<p>To have those action creators available along the rest, we might re-export them in <code>client/store/actions.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/actions.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> along our own action creators.</p>
<pre><code class="language-js">export * from './projects';
export { push, replace, go, goBack, goForward } from 'react-router-redux';
</code></pre>
<p>We will use some of these action creators further on.</p>
<h2><a class="self-ref" id="chapter16-memoizing-caching" href="#chapter16-memoizing-caching"># </a>Memoizing (caching)</h2>
<p>In a component wrapped by the <code>connect</code> HoC from <code>react-redux</code>, some of the properties that <code>mapStateToProps</code> calculates might be expensive to produce.  If the values they are based upon have not changed, it is not worth repeating the process.</p>
<p>The <a href="https://www.npmjs.com/package/reselect">reselect</a> package allows us to compare the new values the calculation depends on with their previous values and if they match, <code>reselect</code> returns the previous values, not bothering to perform the calculation.</p>
<p>For example, we could produce the <code>pending</code> count not in the store but in <code>ProjectItem</code> itself <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/components/projects/projectItem.js#L29">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Our current version simply returns the pre-calculated value from the store <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/projects/reducer.js#L21-L22">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. It is less expensive to do it in the reducer because it will only be re-calculated when an action triggers the change.</p>
<p>If we did it in <code>mapStateToProps</code>, the value would be re-calculated more frequently, for example, whenever we switch from one project to the other, the issue we fixed a few sections earlier (when the <code>&lt;Link&gt;</code> and its <code>activeClassName</code> wasn't working).  Moreover, we would have to do the full computation as we did in the initialization:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/projects/reducer.js#L8-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-16-03</div>
    <div class="filename">File: client/store/projects/reducer.js</div>
    <div class="from">From: 8</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">forEach(data, prj =&gt; {
  prj.pending = filter(prj.tasks, // eslint-disable-line no-param-reassign
    task =&gt; !task.completed
  ).length;
});</code></pre></div>
<p>This would be expensive and pointless.  In the end, <code>connect</code> might figure out that the value of <code>pending</code> hadn't changed and skip the refresh.</p>
<p>The <code>reselect</code> package would have allowed us to check whether the tasks had changed and re-calculate only if they did.  We must remember that if we use an immutable store, as we should and did, checking whether the <code>tasks</code> object has changed means comparing the new and previous references to the <code>tasks</code> object, which is fast, not looping through its contents which would be just as bad as doing the calculation itself.</p>
<p>However, using <code>reselect</code> with multiple instances of the same component is somewhat complicated as explained <a href="https://www.npmjs.com/package/reselect#accessing-react-props-in-selectors">in the docs</a> so we won't do it.</p>
<p>Each selector that <code>createSelector</code> creates stores a copy of the values to be checked for changes.  If we use <code>createSelector</code> in <code>ProjectItem</code> to create one selector, that selector would store the values for the first project in the list.  When the second project is shown, the selector would correctly find out that it is not the same and redo the calculation instead of using its cached value and it would keep doing so for each project.  If the list of projects is refreshed again, the selector would re-calculate each and everyone since the values it has stored are those for the last project in the list.  To solve this we would need to create a selector for each project, possibly a hash of selectors indexed by <code>pid</code>.</p>
<h2><a class="self-ref" id="chapter16-reducing-boilerplate" href="#chapter16-reducing-boilerplate"># </a>Reducing Boilerplate</h2>
<p>The Redux documentation contains a section on <a href="http://redux.js.org/docs/recipes/ReducingBoilerplate.html">Reducing Boilerplate</a>.</p>
<p>So far we only have only one action creator:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/projects/actions.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-16-03</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">export const TASK_COMPLETED_CHANGE = 'projects/Task completed changed';

export const completedChanged = (pid, tid, completed) =&gt; ({
  type: TASK_COMPLETED_CHANGE,
  pid,
  tid,
  completed,
});</code></pre></div>
<p>As we go ahead with our application the number of such action creators will grow.  To avoid the repetition, we might use a function such as that shown in the documentation for Redux:</p>
<pre><code class="language-js">function makeActionCreator(type, ...argNames) {
  return function(...args) {
    let action = { type }
    argNames.forEach((arg, index) =&gt; {
      action[argNames[index]] = args[index]
    })
    return action
  }
}
</code></pre>
<p>If we did so, our previous action creator would be reduced to:</p>
<pre><code class="language-js">export const TASK_COMPLETED_CHANGE = 'projects/Task completed changed';

export const completedChanged = makeActionCreator(TASK_COMPLETED_CHANGE, pid, tid, completed);
</code></pre>
<p>Redux does not provide such a function natively because should we decide to use the <a href="https://github.com/acdlite/flux-standard-action">Flux Standard Action</a> format or any other, our <code>makeActionCreator</code> function would have to change.  Just as with all of Redux excellent documentation, that is a chapter worth reading.</p>
<h2><a class="self-ref" id="chapter16-summary" href="#chapter16-summary"># </a>Summary</h2>
<p>We have checked on various tools, utilities and tricks that can help us in developing an application:</p>
<ul>
<li>React Development Tools</li>
<li>Redux Development Tools</li>
<li>React Performance Tools</li>
<li>Disabling WebPack warnings when generating the production version</li>
<li>UI Component libraries we might use</li>
<li>Alternative formats for Redux actions, such as FSA</li>
<li>How to handle navigation with <code>redux-router</code> using <code>withRouter</code></li>
<li>How to simplify assembling classNames with <code>classnames</code></li>
<li>How to save the location into the store with <code>react-router-redux</code></li>
<li>How to cache calculated values with <code>reselect</code></li>
<li>Tips on reducing boilerplate</li>
</ul>
</section><section id="chapter17"><h1><a class="self-ref" id="chapter17-data-normalization" href="#chapter17-data-normalization"># </a>Data Normalization</h1>
<p>Our data is structured as a hierarchy of <em>projects</em> containing <em>tasks</em>.  This kind of structure has become more frequent with the popularity of No-SQL databases.  Deep hierarchical collections of data are found all too frequently.  The data stored in such databases is often not normalized.  Data normalization is an important concept in data management, we can even learn from <a href="https://en.wikipedia.org/wiki/Database_normalization">Wikipedia</a>.</p>
<p>The problem with databases which are not normalized can be seen, for example, in our projects reducer <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/projects/reducer.js#L16-L32">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  It's complexity is, to a certain point, the consequence of it being too deep.  Instead of having just one collection of data as we had up to now <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/projects/data.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> with a collection of projects each containing a collection of tasks, we may have two separate tables, one for projects and another for tasks <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/data.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<h2><a class="self-ref" id="chapter17-data" href="#chapter17-data"># </a>Data</h2>
<p>Our new <code>data.js</code> contains a collection of <code>projects</code> whose first entry is this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/data.js#L1-L7"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-01</div>
    <div class="filename">File: client/store/projects/data.js</div>
    <div class="from">From: 1</div>
    <div class="to">To: 7</div>
  </div>
  <pre><code class="language-js">module.exports = {
  projects: {
    25: {
      name: 'Writing a Book on Web Dev Tools',
      descr: 'Tasks required to write a book on the tools required to develop a web application',
      tids: ['1', '2', '3'],
    },</code></pre></div>
<p>Here, project <code>25</code> does not contain any task data.  What it has instead is an array of <code>tids</code>, references to task-ids.  Then we have the collection of <code>tasks</code> such as these first two entries:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/data.js#L14-L22"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-01</div>
    <div class="filename">File: client/store/projects/data.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 22</div>
  </div>
  <pre><code class="language-js">tasks: {
  1: {
    descr: 'Figure out what kind of application to develop',
    completed: true,
  },
  2: {
    descr: 'Decide what tools to use',
    completed: false,
  },</code></pre></div>
<p>This allows us to access one set of data independently of the other.  When we have to deal with tasks, we just go for them, we don't need to reach them via the project they belong to, we don't need to traverse a deep hierarchy.  Obviously here the depth was just two, but in the real world, this kind of hierarchical data can go many layers deep, making matters really tough.</p>
<p>There is another advantage to normalization.  Lets imagine we cannot write a book while hungry.  Thus, if we mean to have a Spanish tortilla for lunch, its tasks become a pre-requisite for writing a book.  In our nested hierarchy, task 4: <code>Peel and dice the potatoes</code> could not become a task for project 25: <code>Write a Book on Web Dev Tools</code> unless it is repeated in each branch. Updating it then becomes troublesome because when we get the potatoes peeled, we would need to search for occurrences in all of the branches to check it as completed.</p>
<p>With a normalized database, since projects only keep references to tasks via their <code>tid</code>s, we may add the <code>tid</code> of any task to any number of projects. Peeling potatoes can be a task in both projets at the same time.</p>
<h2><a class="self-ref" id="chapter17-reducers" href="#chapter17-reducers"># </a>Reducers</h2>
<p>A Redux store is mostly defined by its reducers so, once our <code>data.js</code> file is fixed <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/data.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> we have to fix our old reducer <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/projects/reducer.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> splitting it in two, <code>tasksReducer</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/tasksReducer.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and <code>projectsReducer</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/projectsReducer.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>Unlike the previous single reducer, this one is initialized with just part of the data in <code>data.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/tasksReducer.js#L4-L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-01</div>
    <div class="filename">File: client/store/projects/tasksReducer.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-js">import data from './data';

export default (state = data.tasks, action) =&gt; {
  switch (action.type) {
    case TASK_COMPLETED_CHANGE: {</code></pre></div>
<p>The <code>state</code> argument is set to default to <code>data.tasks</code> instead of the whole <code>data</code> file.  The reducer still has the same structure as all reducers, with a switch statement branching off depending on <code>action.type</code>.  For the <code>TASK_COMPLETED_CHANGE</code>, our <code>update</code> call is much simpler:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/tasksReducer.js#L9-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-01</div>
    <div class="filename">File: client/store/projects/tasksReducer.js</div>
    <div class="from">From: 9</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">return update(
  state,
  {
    [action.tid]: {
      completed: { $set: action.completed },
    },
  }
);</code></pre></div>
<p>Now it doesn't need to use the <code>action.pid</code> property since it can access the task directly by its <code>tid</code>.</p>
<p>The change in the completion status of a task also affects the pending count for the project so the <code>projectsReducer</code> also has to deal with that:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/projectsReducer.js#L15-L32"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-01</div>
    <div class="filename">File: client/store/projects/projectsReducer.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 32</div>
  </div>
  <pre><code class="language-js">export default (state = data.projects, action) =&gt; {
  switch (action.type) {
    case TASK_COMPLETED_CHANGE: {
      return update(
        state,
        {
          [action.pid]: {
            pending: {
              $apply: pending =&gt; (action.completed ? pending - 1 : pending + 1),
            },
          },
        }
      );
    }
    default:
      return state;
  }
};</code></pre></div>
<p>As with the <code>tasksReducer</code>, the <code>projectsReducer</code> is initialized out of one branch of the data: <code>data.projects</code>.</p>
<p>This shows us an important feature of Redux.  An action is broadcast to all reducers and each might decide to handle it or not.  If we didn't keep a <code>pending</code> count, the <code>switch</code> statement in <code>projectsReducer</code> would only have the <code>default:</code> label with no <em>cases:</em>.</p>
<p>The <code>projects</code> folder now has two reducers, thus we cannot just export it as the <em>default</em> as we did before <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/projects/index.js#L3-L4">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, instead, we make two separate named exports:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-01</div>
    <div class="filename">File: client/store/projects/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">export * from './actions';

export { default as projects } from './projectsReducer';
export { default as tasks } from './tasksReducer';</code></pre></div>
<p>We export the <code>default</code> from <code>projectsReducer</code> as <code>projects</code> and the <code>default</code> from <code>tasksReducer</code> as <code>tasks</code>.</p>
<p>We then import those two named exports from <code>./projects</code> and combine it into our single Redux store:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/createStore.js#L4-L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-01</div>
    <div class="filename">File: client/store/createStore.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-js">import { projects, tasks } from './projects';

const reducers = combineReducers({
  projects,
  tasks,
  routing: routerReducer,
});</code></pre></div>
<p>We might have done it in different ways.  We might have combined them earlier in <code>store/projects/index.js</code>  <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/projects/index.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> by doing:</p>
<pre><code class="language-js">import { combineReducers } from 'redux';

import projects from './projectsReducer';
import tasks  from './tasksReducer';

export default combineReducers({
  projects,
  tasks,
});
</code></pre>
<p>And then combining that with the rest of the reducers for the other (future) sub-stores in <code>store/createStore.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/client/store/createStore.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.   The problem with this alternative is that each use of <code>combineReducers</code> adds one level to the store.  Thus, with the first alternative a project name could be read from the store as <code>state.projects[pid].name</code> while by this alternative, it would have been <code>state.projects.projects[pid].name</code>, an extra <code>projects</code> level added by the second <code>combineReducers</code>.</p>
<p>We might have also take the <code>tasks</code> part out of the <code>store/projects</code> folder and create a separate <code>store/tasks</code> folder.</p>
<p>The point is Redux gives us quite some freedom in the ways to structure our store and sub-stores by combining the reducers in several ways.</p>
<h2><a class="self-ref" id="chapter17-components" href="#chapter17-components"># </a>Components</h2>
<p>The <code>Task</code> component has much easier access to its data, instead of having:</p>
<pre><code class="language-js">export const mapStateToProps = (state, props) =&gt; state.projects[props.pid].tasks[props.tid];
</code></pre>
<p>It becomes:</p>
<pre><code class="language-js">+export const mapStateToProps = (state, props) =&gt; state.tasks[props.tid];
</code></pre>
<p>And in <code>TaskList</code>, instead of looping through the keys in the <code>tasks</code> object:</p>
<pre><code class="language-js">Object.keys(tasks).map(tid =&gt; (
</code></pre>
<p>We loop through the array of <code>tids</code> that each project contains:</p>
<pre><code class="language-js">tids.map(tid =&gt; (

</code></pre>
<p>Incidentally, we get an extra advantage.  An array always preserves the order of the elements in it, an object doesn't.  So, having the <code>tid</code>s in an array means that we can make certain that we don't <em>fry the potatoes</em> before having them <em>peeled and diced</em>.</p>
<h2><a class="self-ref" id="chapter17-server-side" href="#chapter17-server-side"># </a>Server side</h2>
<p>Though we haven't been using it in the last few chapters, our server still responds to the REST API requests as it did before.  Since we used an SQL database, the tables themselves are already normalized since that is standard practice with SQL.  We still have to change the API because our API returns a deep hierarchy of tasks within projects instead of just returning the <code>tid</code>s of the tasks in that project.</p>
<p>One design consideration in SQL databases is the <em>cardinality</em> of the relation in between the tables, that is, how many elements may be on each side.  We currently have a <em>one-to-many</em> relation, that is, one project may have many tasks.  There is also a <em>one-to-one</em> relation which is trivial and, if found, it means the two related pieces of data can actually be merged into a single table.</p>
<p>If the same task can appear in more than one project, then we would have a <em>many-to-many</em> relation.  One project can have many tasks and a task can show up in many projects.</p>
<p>A simple rule of thumb says that for a <em>one-to-one</em> relation, we don't actually need two tables, one is enough.  For a <em>one-to-many</em> relation, we need two tables, which is exactly what we have.  For a <em>many-to-many</em> relation, we need three tables, one for the projects, one for the tasks and a third one matching <code>pid</code>s with <code>tid</code>s.</p>
<p>Of course, there could be other combinations.  A project might contain other projects as sub-projects, not just share its tasks.  That would require extra information to signal whether the reference is a <code>tid</code> pointing to another task or a <code>pid</code> pointing to a sub-project.</p>
<p>For the purpose of this book, we will stick with the <em>one-to-many</em> relation and keep our two tables.  We must change one of the APIs, the one for the <code>/:pid</code> route <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/server/projects/routes.js#L23-L25">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which uses <code>getProjectById</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-01/server/projects/transactions.js#L49-L65">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  Currently, it returns the project requested along with its tasks, in a hierachy very much like we had in our earlier <code>data.js</code>.  Now, we must change it so that it returns the project properties plus an array of <code>tid</code>s.</p>
<p>Since we are changing the API interface, we change the version number from <code>v1</code> to <code>v2</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-02/server/index.js#L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-02</div>
    <div class="filename">File: server/index.js</div>
    <div class="from">From: 16</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">app.use('/data/v2', dataRouter);</code></pre></div>
<p>In a real-life situation, if the application had been already made public, we would have the management issue of keeping both versions 1 and 2 active at once so we would have to add a route for <code>v2</code> instead of replacing that for <code>v1</code>.   That is a management issue we will ignore at the moment.</p>
<p>The major change is the <code>getProjectById</code> which instead of returning a <code>tasks</code> object returns a <code>tids</code> array:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-02/server/projects/transactions.js#L49-L59"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-02</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 49</div>
    <div class="to">To: 59</div>
  </div>
  <pre><code class="language-js">getProjectById: (keys, data, options, done) =&gt; {
  prepared.selectProjectByPid.get({$pid: keys.pid}, (err, prj) =&gt; {
    if (err) return done(err);
    if (!prj) return done(null, null);
    prepared.selectTasksByPid.all({$pid: keys.pid}, (err, tids) =&gt; {
      if (err) return done(err);
      prj.tids = tids.map(entry =&gt; String(entry.tid));
      done(null, prj);
    });
  });
},</code></pre></div>
<p>We also change the <code>selectTasksByPid</code> prepared SQL statement which instead of returning the <code>tid</code>, <code>descr</code> and <code>completed</code> fields, just needs to return the <code>tid</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-02/server/projects/transactions.js#L11-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-02</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 11</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">prepared.selectTasksByPid = db.prepare('select tid from tasks where pid = $pid', (err) =&gt; {
  if (err) return done(err);
});</code></pre></div>
<p>Finally, we also change the tests.  Besides changing the URL to point to the <code>v2</code> API <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-02/test/server.js#L56-L60">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we change the test for the result of a <code>GET</code> on <code>/25</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-02/test/server.js#L164-L167"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-17-02</div>
    <div class="filename">File: test/server.js</div>
    <div class="from">From: 164</div>
    <div class="to">To: 167</div>
  </div>
  <pre><code class="language-js">expect(data.name).to.equal('Writing a Book on Web Dev Tools');
expect(data.descr).to.equal('Tasks required to write a book on the tools required to develop a web application');
expect(data.tids).to.be.an.array;
expect(data.tids).to.eql(['1', '2', '3']);</code></pre></div>
<p>Besides checking the <code>name</code> and <code>descr</code> values, we now check that the <code>tids</code> field is an array and that it contains the <code>tid</code>s of its tasks, instead of the whole description and completion status for each.</p>
<h3><a class="self-ref" id="chapter17-reducing-the-number-of-requests" href="#chapter17-reducing-the-number-of-requests"># </a>Reducing the number of requests</h3>
<p>We have a problem with this mechanism. Any request for a project would only get the references to the tasks in that project, just the <code>tid</code>s.  It would require many follow up requests to get the task data itself. This would generate unnecessary traffic and significantly slow down the application as the user would see the list of tasks growing slowly.</p>
<p>With a limited number of tasks per project, as is our case, it makes more sense to return the tasks all at once, as we were doing so far.</p>
<p>If the number of tasks (or any other subordinated set of data) is very large it might be better to send the tasks separately and reduce the number of requests by batching the requests into separate sets.   Once the response for the project arrives, we might break the array of <code>tid</code>s into chunks of 10, 50 or some reasonable number of tasks on each batch and request each set separately.  As the responses for each of the sets arrive, we may refresh the screen so the user sees the data as it comes.</p>
<p>React along Redux makes this a very easy mechanism to implement. Each arrival of data would trigger an action which would update the store with the newly arrived data (via the corresponding reducer).  The store would notify all subscribers of the change and the components would update the screen to include the updated data.</p>
<p>Finally, if we had a <em>many-to-many</em> relation in between projects and tasks, we would need to keep the requests separate since, before requesting a particular task, we would have to check whether that task has already been loaded due to some other project that also contains it.  The missing ones might be batched, as described above.</p>
<p>As it stands right now, we are in the first situation, a <em>one-to-not-so-many</em> relation so our <code>v1</code> REST API would be better for us.  We will do only one minor change.</p>
<p>We will return the <code>tasks</code> but as an array, not an indexed object <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-03/server/projects/transactions.js#L49-L63">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. We will deal with indexes later on.  We also changed the tests to reflect this <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-03/test/server.js#L166-L181">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<h2><a class="self-ref" id="chapter17-summary" href="#chapter17-summary"># </a>Summary</h2>
<p>We have taken the data for the tasks as a separate collection within our <code>data.js</code> file.  This is called database normalization and is common practice.  Our application has been simplified as a result.  Though it might not be immediately obvious right now, this simplification will make our lives easier as the application grows.</p>
<p>We have seen how a reducer can be split and later combined in a couple of ways.</p>
<p>We have also applied the same normalization principles to our REST API.  We have discussed a few alternatives on how to respond to requests for hierarchical data.  For our particular set of data, with a <em>one-to-many</em> relation and not so many on the <em>many</em> side, we decided to send all the tasks along the project they belong two.  We simply changed the format of the returned data.</p>
</section><section id="chapter18"><h1><a class="self-ref" id="chapter18-asynchronous-operations" href="#chapter18-asynchronous-operations"># </a>Asynchronous operations</h1>
<p>Though we started this book developing the server-side part of the application and even as recently as in the last chapter we reviewed the REST API, since we started with React, we reverted to our <code>data.js</code> file loaded in memory on the client side for all our operations.  This was done to decouple the issues of handling the UI from handling the communication with the server, but it is high time we connected both sides.</p>
<p>While we were dealing with data loaded on the client-side, all our operations have been synchronous, whenever we did something, it happened everywhere all at once, <em>everywhere</em> here meaning all within the client.  This is hardly the case in real life.  The client will deal with information that is stored in a remote server and reaching it will always require asynchronous operations.</p>
<p>Currently, our client-side application loads the two collections within <code>data.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-03/client/store/projects/data.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> as the default state in our two reducers, <code>projectsReducer</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-03/client/store/projects/projectsReducer.js#L15">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and <code>tasksReducer</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-03/client/store/projects/tasksReducer.js#L6">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. From then on, all the information is permanently available in the client.</p>
<p>We need to move away from this mechanism and make the client request the data from the server via the REST API on demand instead. Our first step will be to remove <code>data.js</code> and drop the references to it from both reducers <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-01/client/store/projects/projectsReducer.js#L4">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-01/client/store/projects/tasksReducer.js#L4">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  A reducer should never return <code>undefined</code> so, if the state is <code>undefined</code> they should return an empty object instead:</p>
<pre><code class="language-js">export default (state = {}, action) =&gt; {
</code></pre>
<p>If we run the application in this state, it will show no project listing nor will it show a specific project if its URL, such as <code>http://localhost:8080/projects/25</code>, is given.  It will show no application errors, since the lack of projects is a real possibility and the application handles it nicely.</p>
<h2><a class="self-ref" id="chapter18-phases-of-a-remote-request" href="#chapter18-phases-of-a-remote-request"># </a>Phases of a remote request</h2>
<p>Remote requests have two phases, the request itself and the response which might be successful or not.  These events must be reflected in our application, for example, by showing a spinner while the data is being fetched, an error message if it failed or, hopefully, the requested data when it succeeds. For the components to show any of that, those events must change the store somehow and the only way to modify the store is via actions.</p>
<p>That is why for every remote operation we will define three actions with three different suffixes, <code>_REQUEST</code>, <code>_SUCCESS</code> and <code>_FAILURE</code>.  Thus, to produce our projects list, we will have <code>PROJECT_LIST_REQUEST</code> which will initiate the request for data, and <code>PROJECT_LIST_SUCCESS</code> when the reply arrives.  Occasionally we might receive a <code>PROJECT_LIST_FAILURE</code> so we must plan for it as well.</p>
<p>It is easy to envision where to dispatch the request action, the data container component could do that as with any other action.  However, where can we dispatch the rest of the actions?  Most HTTP request packages will either expect a callback to be called when the reply arrives, or will return a Promise to be resolved with the reply.  The problem is, how can we provide these callbacks with a reference to the store and its <code>dispatch</code> function?</p>
<p>It would be great to have some means to tell Redux when an action will be resolved in the future and tell it what to do at that point.  Redux on its own has no ability to do this, whenever it receives an action, it acts upon it straight away.  But we can expand Redux's abilities via middleware.</p>
<h2><a class="self-ref" id="chapter18-redux-middleware" href="#chapter18-redux-middleware"># </a>Redux Middleware</h2>
<p>We have already used middleware in the server-side code.  Generically, middleware is a piece of code that stands in the middle. In Express, the middleware is able to intercept requests, possibly do something about them, and then let them pass on to its final destination or not.  We even wrote some middleware ourselves <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-03/server/projects/validators.js#L12-L69">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> to validate the request parameters before they get into the function that actually processes the request.</p>
<p>In Redux, middleware stands in between the actions dispatched and the reducers that process them.  Just as Express middleware receives the HTTP request, Redux middleware receives the dispatched action and can do something with it before it gets processed by the reducers.</p>
<p>We have already used a bit of middleware in the client, the <code>routerMiddleware</code> from <code>react-router-redux</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-03/client/store/createStore.js#L13">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> as part of the recipe to store location information in the store.</p>
<p>In this case, we need middleware that is able to process asynchronous actions, that is, actions that will have effects in the future.</p>
<p>There is a package <a href="https://www.npmjs.com/package/redux-thunk">redux-thunk</a> by the same author of Redux that helps us deal with this.  We install it just like a regular dependency:</p>
<pre><code>npm i --save redux-thunk
</code></pre>
<p>As with all middleware, we somehow need to register the middleware.  In Express, we used <code>app.use</code>, like with <code>bodyParser</code>, <code>express.static</code> and some others.  With Redux we use <code>applyMiddleware</code></p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/createStore.js#L13-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/store/createStore.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">export default (history) =&gt; {
  const mw = applyMiddleware(reduxThunk, routerMiddleware(history));
  return createStore(
    reducers,
    process.env.NODE_ENV !== 'production' &amp;&amp; window.devToolsExtension
    ? compose(mw, window.devToolsExtension())
    : mw
  );</code></pre></div>
<p>The <code>createStore</code> method requires the combined <code>reducers</code> as its first argument, then an optional initial state for the store, usually an object and then an <em>enhancer</em>, a function that adds capabilities.  If the second argument is not an object but a function, <code>createStore</code> assumes it to be the <em>enhancer</em>.  We were already using one such enhancer, the Redux developer tools <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-01/client/store/createStore.js#L11-L13">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and later we added <code>routerMiddleware</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/createStore.js#L12">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> via another enhancer, <code>applyMiddleware</code> that is part of Redux.  The <code>compose</code> function, also part of Redux is simply a generic utility function that when called, calls each of the functions passed as its arguments in sequence.  Since we have a single slot for enhancers and we have two of them we need to call both of them in sequence, that is all <code>compose</code> does.  We simply add <code>redux-thunk</code> to the list of middleware to apply <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/createStore.js#L14">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>A normal action is a simple object with at least a <code>type</code> property <a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/projects/actions.js#L3-L8">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  To tell Redux that an action will have secondary effects in the future, instead of a simple object we dispatch a function. Just as any other middleware, <code>redux-thunk</code> gets all the actions and, if it is an object, it lets it through to be handled in the normal way.  However, if any of them is a function, it will call it with a reference to the <code>dispatch</code> function  bound to the store.</p>
<p>So, from the developer point of view, it is quite simple.</p>
<ul>
<li>If we dispatch an object, it is a regular synchronous action that will be taken care of immediately.</li>
<li>If we dispatch a function, it is an asynchronous action, <code>redux-thunk</code> will intercept it and call it with a reference to the <code>dispatch</code> method.  The function is then responsible to dispatch further actions at its convenience.</li>
</ul>
<p>To dispatch actions, we usually use <em>action creators</em>. For example, we have a simple synchronous action creator to set the task completion status:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-16-03/client/store/projects/actions.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-16-03</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">export const TASK_COMPLETED_CHANGE = 'projects/Task completed changed';

export const completedChanged = (pid, tid, completed) =&gt; ({
  type: TASK_COMPLETED_CHANGE,
  pid,
  tid,
  completed,
});</code></pre></div>
<p>An asynchronous action creator looks like this</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/projects/actions.js#L26-L40"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: 26</div>
    <div class="to">To: 40</div>
  </div>
  <pre><code class="language-js">export function getAllProjects() {
  return dispatch =&gt; {
    dispatch({
      type: ALL_PROJECTS_REQUEST,
    });
    return api.read('?fields=pid,name,pending')
      .then(
        response =&gt; dispatch({
          type: ALL_PROJECTS_SUCCESS,
          data: response.data,
        }),
        fail(dispatch, ALL_PROJECTS_FAILURE)
      );
  };
}</code></pre> :</div>
<p>We already have defined our three action type constants following our convention of a common base name plus the suffixes <code>_REQUEST</code>, <code>_SUCCESS</code> and <code>_FAILURE</code>.</p>
<p>The <code>getAllProjects</code> action creator returns a function, a <em>fat arrow</em> function, that expects <code>dispatch</code> as its argument. This is the key for <code>redux-thunk</code> to know this is an asynchronous action. The first thing it does is call <code>dispatch</code> to dispatch the REQUEST action to notify all interested parties that a request is going out.  Then it sends the actual HTTP request using Axios as we already did in our server tests <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/test/server.js#L105-L129">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a></p>
<p>Axios returns a Promise so, when it is resolved, we dispatch either a SUCCESS action or a FAILURE action, each with its associated data.  These two actions will happen some time after the original request is sent.  All actions dispatched from the asynchronous action are synchronous themselves, they are all plain objects but they might have been further asynchronous actions, Redux doesn't mind at all.</p>
<p>For the FAILURE action, we use the <code>fail</code> function defined at the top:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/projects/actions.js#L14-L21"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 21</div>
  </div>
  <pre><code class="language-js">const fail = (dispatch, type) =&gt; response =&gt; {
  dispatch({
    type,
    status: response.status,
    msg: response.statusText,
    url: response.config.url.replace(response.config.baseURL, ''),
  });
};</code></pre></div>
<p>The function is actually a function returning a function, that is a <em>curried function</em>.  When called with the reference to the <code>dispatch</code> method and the action type, it returns a function that might eventually be called when a failure occurs.  At that point it will receive the failed response.   Though each successful response will require processing it in different ways, all failures are processed just the same because all contain the same information.</p>
<p>We are using a pre-configured instance of Axios.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/projects/actions.js#L10-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">import restAPI from 'utils/restAPI.js';

const api = restAPI('data/v2/projects');</code></pre></div>
<p>Since we might use Axios elsewhere, we created a utility function <code>restAPI</code> that returns the pre-configured instance based on the base address for all the requests, in this case <code>'data/v2/projects'</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/utils/restAPI.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/utils/restAPI.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import axios from 'axios';

const PORT = process.env.npm_package_myServerApp_port || 8080;
const HOST = process.env.npm_package_myServerApp_host || 'http://localhost';

export default base =&gt; {
  const restClient = axios.create({
    baseURL: `${typeof window !== 'undefined'
      ? window.location.origin
      : `${HOST}:${PORT}`}/${base}`,
    responseType: 'json',
  });
  return Object.assign(restClient, {
    read: restClient.get,
    create: restClient.post,
    update: restClient.put,
  });
};</code></pre></div>
<p>The instance is set to handle data in JSON format and as a convenience, we have added aliases to the normal REST operations so that <code>read</code> becomes an alias for <code>get</code> but, most important, <code>create</code> is an alias for <code>post</code> and <code>update</code> for <code>put</code>.  After all, since we are doing CRUD operations on the database, it makes sense that we use those operations in the API as well, besides, <code>post</code> and <code>put</code> are often confused with one another.</p>
<p>Since we expect to have several utility functions, we have added an alias to our <code>webpack.config.js</code> file to make it easy to import them <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/webpack.config.js#L24">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>In the <code>getAllProjects</code> action creator we return the Promise that Axios returns <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/projects/actions.js#L31">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  This is not mandatory, <code>redux-thunk</code> doesn't care about the return value, it will simply pass it on as the return of the action creator function, just in case it cares about it.  In our case, we don't, but it is good to know it is available to us.  We will use it in the future.</p>
<p>Now we need the reducers to process these actions.  Originally, we simply had our store initialized from <code>data.js</code> and we handled a single action, <code>TASK_COMPLETED_CHANGE</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-17-03/client/store/projects/tasksReducer.js#L8-L17">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>Now we have to handle one more action type, a successful response for our request:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/projects/projectsReducer.js#L22-L29"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/store/projects/projectsReducer.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 29</div>
  </div>
  <pre><code class="language-js">case ALL_PROJECTS_SUCCESS:
  return action.data.reduce(
    (projects, project) =&gt; (projects[project.pid]
      ? projects
      : update(projects, { $merge: { [project.pid]: project } })
    ),
    state
  );</code></pre></div>
<p>Upon receiving the <code>ALL_PROJECTS_SUCCESS</code> action, since the data in the response is an array, we use Array <code>reduce</code> method to return the new state using the current state as the initial state for <code>reduce</code>.  For each item, we use <code>update</code> to merge the new values into the original state, or keep the ones if we already have them. The resulting state will not have all the project information because we explicitly asked for just a few fields, <code>pid</code>,  <code>name</code> and <code>pending</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/projects/actions.js#L31"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: 31</div>
    <div class="to">To: 31</div>
  </div>
  <pre><code class="language-js">return api.read('?fields=pid,name,pending')</code></pre></div>
<p>Since we don't have access to all the data on the client-side, we can no longer calculate the <code>pending</code> count for all projects by looping through the tasks, as we did before. We do not have and do not want to have all the tasks loaded because, in a real application, they might be too many.  Thus, we have moved the calculation of the <code>pending</code> count to the server side by using a nested SQL query to produce it on the database side:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/server/projects/transactions.js#L5"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: server/projects/transactions.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 5</div>
  </div>
  <pre><code class="language-js">prepared.selectAllProjects = db.prepare('select projects.*, count(tasks.completed) as pending from projects inner join tasks using (pid) where completed = 0 group by pid', (err) =&gt; {</code></pre></div>
<p>The <code>getAllProjects</code> action creator provides information for the <code>ProjectList</code> component.   When we go into the detail of any of those projects, we need to request some extra information from the server via <code>getProjectById</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/projects/actions.js#L42-L61"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: 42</div>
    <div class="to">To: 61</div>
  </div>
  <pre><code class="language-js">export const PROJECT_BY_ID_REQUEST = 'projects/Project info request';
export const PROJECT_BY_ID_SUCCESS = 'projects/Project info received';
export const PROJECT_BY_ID_FAILURE = 'projects/Project info failed';

export function getProjectById(pid) {
  return dispatch =&gt; {
    dispatch({
      type: PROJECT_BY_ID_REQUEST,
      pid,
    });
    return api.read(pid)
      .then(
        response =&gt; dispatch({
          type: PROJECT_BY_ID_SUCCESS,
          data: response.data,
        }),
        fail(dispatch, PROJECT_BY_ID_FAILURE)
      );
  };
}</code></pre></div>
<p>The action creator follows a similar pattern of initially dispatching the REQUEST action and then using Axios to send the request to the server.  Upon return, it either dispatches the SUCCESS of FAILURE action, the later through the <code>fail</code> curried function.</p>
<p>The <code>projectsReducer</code> handles this action, to fill the information it had not initially requested:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/projects/projectsReducer.js#L30-L54"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/store/projects/projectsReducer.js</div>
    <div class="from">From: 30</div>
    <div class="to">To: 54</div>
  </div>
  <pre><code class="language-js">case PROJECT_BY_ID_SUCCESS: {
  const project = action.data;
  return update(
      state,
      state[project.pid]
        ? {
          [project.pid]: {
            $merge: {
              descr: project.descr,
              tids: project.tasks.map(task =&gt; task.tid),
            },
          },
        }
        : {
          $merge: {
            [project.pid]: {
              pid: project.pid,
              name: project.name,
              descr: project.descr,
              tids: project.tasks.map(task =&gt; task.tid),
            },
          },
        }
    );
}</code></pre></div>
<p>The operation looks somewhat long but it is actually composed of two separate operations.  In the first half is the case where the basic data for the project  is there thanks to <code>getAllProjects</code> and only some extra information needs to be added in. It adds the <code>descr</code> field and collects into <code>tids</code> the <code>tid</code>s of the individual tasks. The second is when no prior information exists and it all has to be merged in. Though the order of the requests might be predicted, the order of the replies can never be so both alternatives need to be handled.</p>
<p>It is up to <code>tasksReducer</code> to load the tasks information into the store:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/store/projects/tasksReducer.js#L19-L27"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/store/projects/tasksReducer.js</div>
    <div class="from">From: 19</div>
    <div class="to">To: 27</div>
  </div>
  <pre><code class="language-js">case PROJECT_BY_ID_SUCCESS: {
  return action.data.tasks.reduce(
    (tasks, task) =&gt; (tasks[task.pid]
      ? tasks
      : update(tasks, { $merge: { [task.tid]: task } })
    ),
    state
  );
}</code></pre></div>
<p>The reason to use the Array <code>reduce</code> method instead of simply merging the received data is that our sub-stores are indexed by <code>pid</code> and <code>tid</code> respectively.  Thus, we need to go through each row and pick the <code>pid</code> or <code>tid</code> to use as index in the hash.</p>
<p>The <code>projectsReducer</code> and <code>tasksReducer</code> reducers do not care about the REQUEST or FAILURE actions, only the SUCCESS one.  Actions, like DOM events, are notifications of things happening, whether any part of the application is interested in doing something about them or not is another matter.</p>
<p>It might seem that after all this amount of code, something should happen if we ran the application, but it doesn't yet.</p>
<h2><a class="self-ref" id="chapter18-dispatching-initial-loading-actions" href="#chapter18-dispatching-initial-loading-actions"># </a>Dispatching initial loading actions</h2>
<p>We have seen how to create asynchronous actions and how to handle them, but we have not dispatched any yet.  Where should we do that?</p>
<p>Stateful React components have <a href="https://facebook.github.io/react/docs/component-specs.html#lifecycle-methods">several methods</a> that we can declare and are called during the lifecycle of a component.  Two of them are of particular interest to us.</p>
<p>The <a href="https://facebook.github.io/react/docs/component-specs.html#mounting-componentdidmount"><code>componentDidMount</code></a> method is called when the component is loaded for the first time. As the React documentation says, this is a perfect place to send AJAX requests. In our case, using Redux, it is the place to dispatch an action to initiate such a request.</p>
<p>The <a href="https://facebook.github.io/react/docs/component-specs.html#updating-componentwillreceiveprops"><code>componentWillReceiveProps</code></a> will be called on any further updates of the component presumably because the properties might have changed. The properties might not have actually changed. Doing a thorough check on all the values, specially on deeply nested objects, is too expensive so React calls this method more often than what is actually required and lets us decide, possibly using the <a href="https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate"><code>shouldComponentUpdate</code></a> method. This later method is not written until after we do some performance analysis and detect too much <a href="https://facebook.github.io/react/docs/perf.html#perf.printwastedmeasurements">time wasted</a> in some specific components.</p>
<p>We could rewrite some of our components and turn them from stateless to stateful to make use of these lifecycle methods, but that would be a pity. Stateless components are smaller, thus cheaper and, since they have less functionality, are faster to process. The are a new addition to React but are expected to benefit from huge performance improvements in the future since they are so lightweight.  It would be a bad idea to weight them down with extra code.</p>
<p>However, each of the stateless components that needs data from the store are wrapped via <code>connect</code> with a stateful component which is the one that actually deals with the store through the <code>mapStateToProps</code> and <code>mapDispatchToProps</code> methods.  Wouldn't it make sense to have the data containers be the ones responsible to dispatch the data loading actions?</p>
<p>The <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options"><code>connect</code></a> method of <code>react-redux</code> actually returns a stateful component.  Though we often call it a <em>wrapper</em> it is, indeed, a fully featured React component, a HoC or High-order Component. Since React components are still regular JavaScript classes, we can extend them and have their methods redefined.  That is what we've done in <code>utils/initialDispatcher.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/utils/initialDispatcher.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/utils/initialDispatcher.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">export default initialDispatch =&gt; Connector =&gt; class extends Connector {
  componentWillMount() {
    if (super.componentDidMount) super.componentDidMount();
    initialDispatch(this.store.dispatch, this.props, null, this.state.storeState);
  }
  componentWillReceiveProps(nextProps) {
    if (super.componentWillReceiveProps) super.componentWillReceiveProps(nextProps);
    initialDispatch(this.store.dispatch, nextProps, this.props, this.state.storeState);
  }
};</code></pre></div>
<p>The single function we export from <code>initialDispatcher.js</code> returns a curried function.  It is written in the same style as <code>connect</code> so that, whenever ES7 decorators become standard, it can be used as a decorator.  It is curried with an <code>initialDispatch</code> function and returns a function that can be applied to the component wrapped with <code>connect</code>.</p>
<p>It returns a new class which <code>extend</code>s the class <code>Connect</code> which it receives as an argument and redefines its <code>componentDidMount</code> and <code>componentWillReceiveProps</code> methods.  In each of them, it first calls the original <code>super</code> version (if there is any) and then calls the <code>initialDispatch</code> method which it also has received as an argument.</p>
<p>It provides that function with a reference to the <code>dispatch</code> method (the same that <code>mapDispatchToProps</code> usually receives), the future properties, the current properties (none on componentDidMount since it is the first time and there are no current values yet) and the state of the store. It is used thus:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/components/projects/projectList.js#L25-L33"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/components/projects/projectList.js</div>
    <div class="from">From: 25</div>
    <div class="to">To: 33</div>
  </div>
  <pre><code class="language-js">import initialDispatcher from 'utils/initialDispatcher.js';
import { getAllProjects } from 'store/actions';
import isEmpty from 'lodash/isEmpty';

export const initialDispatch = (dispatch, nextProps, currentProps, state) =&gt; {
  if (isEmpty(state.projects)) {
    dispatch(getAllProjects());
  }
};</code></pre></div>
<p>In this case, taken from the <code>ProjectList</code>, if <code>state.projects</code> is empty <code>initialDispatch</code> dispatches the action created by <code>getAllProjects</code>.</p>
<p>To apply <code>initialDispatch</code> to our data container we simply call it using the <code>initialDispatcher</code> function and the data container that wraps <code>ProjectList</code>.  We can export the returned class immediately as it is still a valid data container.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/components/projects/projectList.js#L40-L42"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/components/projects/projectList.js</div>
    <div class="from">From: 40</div>
    <div class="to">To: 42</div>
  </div>
  <pre><code class="language-js">export default initialDispatcher(initialDispatch)(connect(
  mapStateToProps
)(ProjectList));</code></pre></div>
<p>So far we have modified <code>ProjectList</code> and the related actions and reducer.  We must do the same with the <code>Project</code> component:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/components/projects/project.js#L35-L48"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-02</div>
    <div class="filename">File: client/components/projects/project.js</div>
    <div class="from">From: 35</div>
    <div class="to">To: 48</div>
  </div>
  <pre><code class="language-js">import initialDispatcher from 'utils/initialDispatcher.js';
import { getProjectById } from 'store/actions';

export const initialDispatch = (dispatch, nextProps, currentProps, state) =&gt; {
  const pid = nextProps.params.pid;
  const prj = pid &amp;&amp; state.projects[pid];
  if (!prj || !prj.tids) {
    dispatch(getProjectById(pid));
  }
};

export default initialDispatcher(initialDispatch)(connect(
  mapStateToProps
)(Project));</code></pre></div>
<p>In this case, we check whether there is a project entry for the given <code>pid</code> and if it has any <code>tids</code> listed.  It there is a project but with no task references, it means the basic information was loaded by <code>ProjectList</code> dispatching <code>getAllProjects</code> but no detail yet.  A project with no tasks would have an empty array as <code>tids</code>, which evaluates as true, against <code>undefined</code> when none were loaded yet.</p>
<p>It is also important to provide the render methods in our components with an alternative when the data is not there yet. Originally, all our data was there from the very start, we were safe to assume that to be so.  With remote data, that is no longer true.  For example, the <code>TaskList</code> component must now check whether <code>tids</code> is not undefined before attempting to render it  <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-02/client/components/projects/taskList.js#L6-L14">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<h2><a class="self-ref" id="chapter18-writing-our-own-middleware" href="#chapter18-writing-our-own-middleware"># </a>Writing our own middleware</h2>
<p>All the asynchronous transactions with the server take some time and all may fail. In between the REQUEST action and either of the SUCCESS or FAILURE actions, we might want to show a loading spinner and, if the outcome is a FAILURE, we would want to show the error message.  As with any status that might affect our application, both the loading status and the error messages will go into our store.</p>
<p>We will add another sub-store to our Redux store by adding a new reducer which will handle these two pieces of information:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/requests/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-03</div>
    <div class="filename">File: client/store/requests/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import update from 'react-addons-update';

import {
  CLEAR_HTTP_ERRORS,
  REQUEST_SENT,
  REPLY_RECEIVED,
  FAILURE_RECEIVED,
} from './actions';

export { CLEAR_HTTP_ERRORS, clearHttpErrors } from './actions';

export default (state = { pending: 0, errors: [] }, action) =&gt; {
  switch (action.type) {
    case CLEAR_HTTP_ERRORS:
      return update(state, { errors: { $set: [] } });
    case REQUEST_SENT:
      return update(state, { pending: { $apply: x =&gt; x + 1 } });
    case REPLY_RECEIVED:
      return update(state, { pending: { $apply: x =&gt; (x &gt; 0 ? x - 1 : 0) } });
    case FAILURE_RECEIVED:
      return update(
        state,
        {
          pending: { $apply: x =&gt; (x &gt; 0 ? x - 1 : 0) },
          errors: { $push: [
            `${action.type.replace('[FAILURE] ', '')}:
            ${action.url}: (${action.status}) - ${action.msg}`,
          ] },
        });
    default:
      return state;
  }
};</code></pre></div>
<p>The sub-store will have a <code>pending</code> property which counts the number of pending HTTP operations and an <code>errors</code> array listing the errors reported by the failed operations.  Both are initialized by using the default parameter value for the <code>state</code> argument.</p>
<p>For every <code>REQUEST_SENT</code> the <code>pending</code> count is incremented and for any reply, successful or not, it is decremented.  On a <code>FAILURE_RECEIVED</code> a formatted error message is also stored in the <code>errors</code> array. Formatting the error information here is not a good idea, it would be better left to the UI designer later on, but for the purpose of this book it will do. The <code>CLEAR_HTTP_ERRORS</code> action clears the <code>errors</code> array.</p>
<p>The action-type constants and the action creators themselves are defined in <code>actions.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/requests/actions.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>To dispatch all those actions, we would need to either add the three of them to each and every action creator that does an HTTP request or we might do something smarter, add a piece of middleware of our own creation.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/requests/middleware.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-03</div>
    <div class="filename">File: client/store/requests/middleware.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">import {
  requestSent,
  replyReceived,
  failureReceived,
} from './actions';

const operationRegExp = /\/([A-Z_]+)$/;

export default ({ dispatch }) =&gt; next =&gt; action =&gt; {
  const match = operationRegExp.exec(action.type);
  switch (match &amp;&amp; match[1]) {
    case 'REQUEST':
      dispatch(requestSent());
      break;
    case 'SUCCESS':
      dispatch(replyReceived());
      break;
    case 'FAILURE':
      dispatch(failureReceived(action));
      break;
    default:
      break;
  }
  return next(action);
};</code></pre></div>
<p>The declaration of Redux middleware seems a little complex, it is a series of functions that return functions that return functions. All are <em>curried</em>, receiving each of the arguments as the chain of function calls progresses.  It first receives a reference to the store object, not the data in it but the store itself. We might read the state of the store by using the <code>getState</code> method but we only pick the <code>dispatch</code> method from it.  It then receives whatever <code>next</code> piece of middleware is there in the chain and finally the <code>action</code> object.</p>
<p>At the bottom, we are calling <code>next(action)</code> to allow processing to continue.  We are not modifying the <code>action</code> object in this case, we are just letting it pass through, but other middleware might modify it or it might take care of the action itself and don't even call <code>next</code> at all.</p>
<p>Our middleware will pick one of three patterns at the end of the action type string.  It will look for strings ending in <code>/REQUEST</code>, <code>/SUCCESS</code> or <code>/FAILURE</code> and it will dispatch the corresponding action for each of them. Since all the failure actions contain the same information <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/projects/actions.js#L14-L21">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we send the action object when dispatching <code>failureReceived</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/requests/middleware.js#L19">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>This means that we only need to add one of these suffixes to our existing action types to make it work:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/projects/actions.js#L22-L24"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-03</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: 22</div>
    <div class="to">To: 24</div>
  </div>
  <pre><code class="language-js">export const ALL_PROJECTS_REQUEST = 'projects/Projects list/REQUEST';
export const ALL_PROJECTS_SUCCESS = 'projects/Projects list/SUCCESS';
export const ALL_PROJECTS_FAILURE = 'projects/Projects list/FAILURE';</code></pre></div>
<p>We have to add the reducer for the new sub-store in the main store:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/createStore.js#L5-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-03</div>
    <div class="filename">File: client/store/createStore.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">import { projects, tasks } from './projects';
import requests from './requests';

const reducers = combineReducers({
  projects,
  tasks,
  requests,
  routing: routerReducer,
});</code></pre></div>
<p>And we must add the imported <code>remoteRequests</code> middleware to our list of middleware as well:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/createStore.js#L15-L19"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-03</div>
    <div class="filename">File: client/store/createStore.js</div>
    <div class="from">From: 15</div>
    <div class="to">To: 19</div>
  </div>
  <pre><code class="language-js">import remoteRequests from './requests/middleware';

export default (history) =&gt; {
  const mw = applyMiddleware(reduxThunk, remoteRequests, routerMiddleware(history));
  return createStore(</code></pre></div>
<p>Of all the action types and action creators we defined <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/requests/actions.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we are only re-exporting <code>CLEAR_HTTP_ERRORS</code>, <code>clearHttpErrors</code> because all the rest are dealt with in between the reducer and the middleware no other element outside of this folder cares about them.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/requests/index.js#L10"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-03</div>
    <div class="filename">File: client/store/requests/index.js</div>
    <div class="from">From: 10</div>
    <div class="to">To: 10</div>
  </div>
  <pre><code class="language-js">export { CLEAR_HTTP_ERRORS, clearHttpErrors } from './actions';</code></pre></div>
<p>We will modify the <code>App</code> component to display the new inforation and also to clear the errors:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/components/app.js#L5-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-03</div>
    <div class="filename">File: client/components/app.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-js">export const App = ({ children, pathname, loading, errors, onCloseErrors }) =&gt; (
  &lt;div className="app"&gt;
    &lt;p className="loading" style={{ display: loading ? 'block' : 'none' }}&gt;loading&lt;/p&gt;
    &lt;pre
      className="errors"
      style={{ display: errors.length ? 'block' : 'none' }}
      onClick={onCloseErrors}
    &gt;
      {errors.join('\n')}
    &lt;/pre&gt;</code></pre></div>
<p>We will provide the <code>App</code> component with the <code>loading</code> status, the <code>errors</code> array and the <code>onCloseErrors</code> function.  We use <code>loading</code> to show and hide a simple sign. The <code>errors</code> are displayed in a pre-formatted box in successive lines that will show if there are any errors.  Finally, we will use the <code>onCloseErrors</code> function as the <code>onClick</code> handler for this error listing.</p>
<p>All those new properties are produced by Redux <code>connect</code> wrapper:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/components/app.js#L32-L49"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-18-03</div>
    <div class="filename">File: client/components/app.js</div>
    <div class="from">From: 32</div>
    <div class="to">To: 49</div>
  </div>
  <pre><code class="language-js">import { connect } from 'react-redux';

export const mapStateToProps = (state, props) =&gt; ({
  pathname: props.location.pathname,
  loading: !!state.requests.pending,
  errors: state.requests.errors,
});

import { clearHttpErrors } from 'store/actions';

export const mapDispatchToProps = dispatch =&gt; ({
  onCloseErrors: ev =&gt; isPlainClick(ev) &amp;&amp; dispatch(clearHttpErrors()),
});

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(App);</code></pre></div>
<p><code>mapStateToProps</code> extracts the data from the store, assuming <code>loading</code> to be true whenever there are any <code>pending</code> operations. Since it receives the properties, it unwraps the <code>pathname</code> from the location.  This is not simply for convenience.  Since the wrapper does a shallow compare of the resulting properties to decide whether to redraw itself, it is always good to bring up to the surface any values nested deep inside.</p>
<p><code>mapDispatchToProps</code> provides the <code>onCloseErrors</code> function. To ensure that the click is with the left button and no modifier keys, we have extracted the function we used earlier into <code>isPlainClick</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/utils/isPlainClick.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  If it is a plain click, we <code>dispatch</code> the <code>clearHttpErrors</code> action <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/components/app.js#L43">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>We export the wrapped function as the default but we also export by name both mapping functions and the unwrapped component, for testing purposes.</p>
<p>To see it all working, the easiest way is to place a breakpoint whenever a reply from the server is received and before the SUCCESS action is dispatched <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/projects/actions.js#L33">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> or <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/projects/actions.js#L54">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and to force an error, the easiest is to force a syntax error on the request, for example, inserting some funny character in between the field names or replacing a comma with a semicolon  <a href="https://github.com/Satyam/book-react-redux/blob/chapter-18-03/client/store/projects/actions.js#L31">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<h2><a class="self-ref" id="chapter18-summary" href="#chapter18-summary"># </a>Summary</h2>
<p>We have learned how to handle asynchronous operations from the client by requesting data from the server via the REST API we had designed earlier.</p>
<p>We have used the <code>redux-thunk</code> middleware to handle those asynchronous actions.</p>
<p>We have also written a simple Redux middleware.</p>
<p>We modified the <code>App</code> component to handle the HTTP status information.</p>
</section><section id="chapter19"><h1><a class="self-ref" id="chapter19-styling" href="#chapter19-styling"># </a>Styling</h1>
<p>Our application is not looking good. As a working example on the technologies behind the screen, it shouldn't matter much, but it is really starting to strain the eyes.</p>
<p>There are many well-known UI libraries and some of them have their active components ported to React, such as Twitter's <a href="http://react-bootstrap.github.io/">Bootstrap</a>, Google's <a href="http://www.material-ui.com/#/">Material Design</a> or Thinkmill's <a href="http://elemental-ui.com/">Elemental</a>.  Using their active React components is quite easy, we would simply have to follow the recipes give in their documentation. There is no general rule as to how active UI components should work, be configured or respond so, we cannot cover it in this book.</p>
<p>We will only use some of their styles and icons. Besides the fancy coloring and shading, the most useful thing we will use is the grid system.  This allows us to distribute our components more efficiently across the page.  In the early days, we would use <code>&lt;table&gt;</code> elements to help us distribute UI elements.  With the ample variety of screen sizes we have to plan for nowadays, tables don't work any longer.  CSS grids, on the other hand, allow for more fluid layouts that can fit both the widest screen of a desktop and a narrow one in a smart phone.</p>
<p>Iconography has also transitioned from small image files in <code>.png</code> or <code>.gif</code> format to fully scalable fonts that represent images instead of characters.  There are plenty to select from here as well, <a href="https://design.google.com/icons/">Material Icons</a>, <a href="http://getbootstrap.com/components/#glyphicons">Bootstrap Glyphicons</a> or the excellent <a href="http://fontawesome.io/icons/">Font Awesome</a>.  Icons are very useful in reducing the clutter of text in our pages by providing easily recognizable elements to interact with, saving on explanatory captions for buttons and such.</p>
<p>We will use the very popular Bootstrap just because it is, indeed, very popular. To have it available to our application, we have to include a couple of CSS files in our single HTML file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-01/public/index.html#L6-L7"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-01</div>
    <div class="filename">File: public/index.html</div>
    <div class="from">From: 6</div>
    <div class="to">To: 7</div>
  </div>
  <pre><code class="language-html">&lt;link rel="stylesheet" href="/css/bootstrap.min.css" /&gt;
&lt;link rel="stylesheet" href="/css/bootstrap-theme.min.css" /&gt;</code></pre></div>
<p>We have opted to download a copy of the distribution files and extract the <code>/css</code> and <code>/fonts</code> folders into our <code>/public</code> folder.  Neither of those folders show up in GitHub because it would be abusive to upload them there so we have excluded them in our <code>.gitignore</code> file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-01/.gitignore#L29-L31">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> thus, from now on, when downloading and running any of the samples for this book, if things look messy, it might be because those two folders are missing.  It is important that the <code>/fonts</code> folder be side-by-side with the <code>/css</code> folder since the CSS files contain relative references to the fonts.  Otherwise, Bootstrap can be loaded from several CDNs as their own site <a href="http://getbootstrap.com/getting-started/#download-cdn">explains</a>.</p>
<p>We have improved on our HTTP errors box in the <code>App</code> component:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-01/client/components/app.js#L8-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-01</div>
    <div class="filename">File: client/components/app.js</div>
    <div class="from">From: 8</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">&lt;pre
  className="alert alert-warning alert-dismissible"
  style={{ display: errors.length ? 'block' : 'none' }}
&gt;
  &lt;button onClick={onCloseErrors} className="close pull-right"&gt;
    &lt;span&gt;&amp;times;&lt;/span&gt;
  &lt;/button&gt;
  {errors.join('\n')}
&lt;/pre&gt;</code></pre></div>
<p>Instead of our own <code>errors</code> className, we have switched to using some of Bootstrap's built-in styles.  We have also added a <code>close</code> button to the box by following one of their simple <a href="http://getbootstrap.com/css/#helper-classes-close">recipes</a>.  We have moved the <code>onClick</code> handler from the whole error box to just this button.</p>
<p>Instead of having a simple <code>Projects</code> link at the top of the screen, we have moved to a tabbed interface:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-01/client/components/app.js#L17-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-01</div>
    <div class="filename">File: client/components/app.js</div>
    <div class="from">From: 17</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">&lt;ul className="nav nav-tabs"&gt;
  {
    /^\/projects/.test(pathname)
    ? (&lt;li className="active"&gt;&lt;a href="#"&gt;Projects&lt;/a&gt;&lt;/li&gt;)
    : (&lt;li&gt;&lt;Link to="/projects"&gt;Projects&lt;/Link&gt;&lt;/li&gt;)
  }
&lt;/ul&gt;</code></pre></div>
<p>By using the <code>nav nav-tabs</code> classNames on an enclosing <code>&lt;ul&gt;</code> element, and turing each entry into a <code>&lt;li&gt;</code> we have now a tab that can grow across the top of the page.</p>
<p>Since we no longer use the <code>errors</code> className, we have deleted it from the <code>index.css</code> file <a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-01/public/index.css">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.   If we hadn't done so, nothing would have happened.  If the styles in it aren't used, they are just wasting space.  This is often a problem, stylesheets getting out of sync with the code that supposedly uses them.  CSS files often grow endlessly because nobody feels comfortable deleting a style that might be in use who-knows-where. It often is less risky to leave the style behind than risk breaking a layout because deleting too much.</p>
<p>We have been careful to fully qualify the styles with a whole hierarchy of classNames, like <code>.app .project .task-list .completed</code> so that it clearly states the component it belongs to.  The <code>.completed</code> className would have worked just as well without so much qualifying, but it would be very easy to lose control.  The best, however, is to keep each component with its own stylesheet. WebPack can help.</p>
<h2><a class="self-ref" id="chapter19-including-css-files" href="#chapter19-including-css-files"># </a>Including CSS files.</h2>
<p>We know that WebPack allows us to pre-process a file before it gets included in the final bundle.  We've been doing that all along since we've told WebPack to use Babel to process the files as they are loaded <a href="https://github.com/Satyam/book-react-redux/blob/master/webpack.config.js#L12-L18">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>. We can do something very much alike with CSS files.</p>
<p>To tell WebPack to handle CSS files we need to add an entry to the list of loaders:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-02/webpack.config.js#L18-L21"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-02</div>
    <div class="filename">File: webpack.config.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 21</div>
  </div>
  <pre><code class="language-js">{
  test: /\.css$/,
  loader: 'style!css'
}</code></pre></div>
<p>Just as we told it to use Babel for those files ending with <code>.js</code> or <code>.jsx</code>, we are now telling it to use <code>style!css</code> for those ending with <code>.css</code>.  Actually, that setting represents two separate but chained loaders, <a href="https://www.npmjs.com/package/style-loader">style-loader</a> and <a href="https://www.npmjs.com/package/css-loader">css-loader</a> which, as usual, we have to install first:</p>
<pre><code class="language-bash">npm i -D css-loader style-loader
</code></pre>
<p>WebPack assumes the <code>-loader</code> ending so that <code>babel</code> actually looks for <code>babel-loader</code> and uses the <code>!</code> sigh to chain loaders together.  If, instead of using plain CSS we used some pre-processor such as <a href="http://lesscss.org/">Less</a> or <a href="http://sass-lang.com/">Sass</a> we might have added an entry like these:</p>
<pre><code class="language-js">{ test: /\.less$/, loader: 'style!css!less' },
{ test: /\.scss$/, loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;] }
</code></pre>
<p>Loaders can be listed in a string, separated by <code>!</code> using the <code>loader</code> property name or listed in an array with <code>loaders</code> (notice the plural).</p>
<p>Now we can take the global style definitions out from <code>index.css</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-01/public/index.css">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and place the along their respective component.  We will do that for <code>App</code>.  We create a file <code>app.css</code> in the same folder as <code>app.js</code> containing the single style definition used there:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-02/client/components/app.css"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-02</div>
    <div class="filename">File: client/components/app.css</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-css">.app .loading {
  position: absolute;
  top: 10px;
  left: 200px;
  z-index: 2;
  border: thin solid blue;
  background-color: silver;
  padding: 3px;
}</code></pre></div>
<p>To use that style definition, we simply need to import it into <code>app.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-02/client/components/app.js#L4"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-02</div>
    <div class="filename">File: client/components/app.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 4</div>
  </div>
  <pre><code class="language-js">import './app.css';</code></pre></div>
<p>That is all that needs to be done.  We use the plainest form of <code>import</code> since we don't really need to have access to whatever <code>app.css</code> might export.  It is important to explicitly include the <code>.css</code>, <code>.less</code>, <code>.scss</code> or whichever extension your style files are because otherwise WebPack, following NodeJS rules, will default to look for files ending in <code>.js</code>.</p>
<p>Once we moved all the component styles to their separate <code>component.css</code> files <a href="https://github.com/Satyam/book-react-redux/tree/chapter-19-02/client/components/projects">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we may delete the now empty <code>index.css</code> file and drop the reference in <code>index.html</code> <a href="https://github.com/Satyam/book-react-redux/tree/chapter-19-02/public">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>We have solved the management issue of keeping the styles in sync with the components that use them in order to avoid having an ever-growing global CSS file. Or at least we are on our way to solving it, for example, <code>taskList.css</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-02/client/components/projects/taskList.css">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> has a single style that actually should belong to <code>task.css</code> which does not exist yet.  The application works and it looks fine, which comes to prove how difficult it is to find these kind of errors. We might have done the very same by several other means, for example, by creating a script to concatenate the files following a particular naming pattern.</p>
<p>We are still forced to keep the convention to assign the enclosing element in each component a className, and use that className to qualify the styles, for example, in <code>App</code>, we have:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-02/client/components/app.js#L6-L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-02</div>
    <div class="filename">File: client/components/app.js</div>
    <div class="from">From: 6</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-js">export const App = ({ children, pathname, loading, errors, onCloseErrors }) =&gt; (
  &lt;div className="app"&gt;
    &lt;p className="loading" style={{ display: loading ? 'block' : 'none' }}&gt;loading&lt;/p&gt;</code></pre></div>
<p>so that in <code>app.css</code> we do:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-02/client/components/app.css#L1"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-02</div>
    <div class="filename">File: client/components/app.css</div>
    <div class="from">From: 1</div>
    <div class="to">To: 1</div>
  </div>
  <pre><code class="language-css">.app .loading {</code></pre></div>
<p>This discipline of reserving a className for each component so as to qualify its styles is difficult to maintain and hard to enforce is we are to use third party components.   Since the <code>.app</code> className goes into the overall frame for the whole application, any children or deeper descendant having an element with the  <code>.loading</code> className will get a spillover from <code>.app .loading</code>.   This could be solved by applying the <code>.app</code> className to anything but the children:</p>
<pre><code class="language-js">export const App = ({ children, pathname, loading, errors, onCloseErrors }) =&gt; (
  &lt;div&gt;
    &lt;div className=&quot;app&quot;&gt;
      &lt;p className=&quot;loading&quot; style={{ display: loading ? 'block' : 'none' }}&gt;loading&lt;/p&gt;
      &lt;!--  .... --&gt;
    &lt;/div&gt;
    {children}
    &lt;div className=&quot;app&quot;&gt;
      &lt;!--  .... --&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
</code></pre>
<p>The outside <code>&lt;div&gt;</code> has no className and it encloses two further <code>&lt;div&gt;</code>s that do have the <code>.app</code> className and <code>{children}</code> which doesn't.  Another alternative is to enable WebPack support for <a href="https://github.com/css-modules/css-modules">CSS Modules</a>.</p>
<h2><a class="self-ref" id="chapter19-css-modules" href="#chapter19-css-modules"># </a>CSS Modules</h2>
<p>CSS Modules is a proposed mechanism to be able to do with CSS what we already do with JavaScript via NodeJS <code>module.export</code>/<code>require</code> or ES6 <code>export</code>/<code>import</code>, that is, to keep information in separate modules instead of getting everything mixed up in a global context.</p>
<p>To enable CSS modules in WebPack we simply need to add a configuration option to the entry for loading css files:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-03/webpack.config.js#L18-L21"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-03</div>
    <div class="filename">File: webpack.config.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 21</div>
  </div>
  <pre><code class="language-js">{
  test: /\.css$/,
  loader: 'style!css?modules&amp;camelCase'
}</code></pre></div>
<p>The <code>loader</code> setting in WebPack is written as a series of URL-like style series of loader specs, separated by <code>!</code>.  For each of the loaders listed, a series of configuration options can be given as in the query parameters of a URL, with the query string after a <code>?</code> and successive setings separated by <code>&amp;</code>. Each setting might be <code>options=value</code> or <code>option</code>, which is equivalent to <code>option=true</code>.</p>
<p>In the above case, we are telling the <code>css-loader</code> module to use CSS modules and to convert to camel-case.  We will soon see why the latter.</p>
<p>Using CSS modules we don't need to use qualifiers in our CSS files since now the declarations within don't got into the global namespace and they can only be accessed by the modules that explicitly import them. In reality they do go into the only global namespace that the DOM provides, but they are wrapped in such a way as to make it look as if they aren't.</p>
<p>The <code>app.css</code> file looks very much the same, but without the leading <code>.app</code> qualifier:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-03/client/components/app.css"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-03</div>
    <div class="filename">File: client/components/app.css</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-css">.loading {
  position: absolute;
  top: 10px;
  left: 200px;
  z-index: 2;
  border: thin solid blue;
  background-color: silver;
  padding: 3px;
}</code></pre></div>
<p>To use that style, <code>app.js</code> needs to import them into a variable and then use it like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-03/client/components/app.js#L4-L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-03</div>
    <div class="filename">File: client/components/app.js</div>
    <div class="from">From: 4</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-js">import styles from './app.css';

export const App = ({ children, pathname, loading, errors, onCloseErrors }) =&gt; (
  &lt;div className="app"&gt;
    &lt;p className={styles.loading} style={{ display: loading ? 'block' : 'none' }}&gt;loading&lt;/p&gt;</code></pre></div>
<p>The css file is imported into the <code>styles</code> variable which will then contain an object.  To use any of the styles in the css file, we access it by name within that object: <code>{styles.loading}</code>.</p>
<p>We still keep the <code>app</code> className on the enclosing <code>&lt;div className=&quot;app&quot;&gt;</code> mostly as an aid for us when debugging the application and trying to find which component produced which HTML and, perhaps, for some global styling, but otherwise, there is no longer any need for these component classNames.</p>
<p>Any number of styles can be defined in a single CSS file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-03/client/components/projects/task.css"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-03</div>
    <div class="filename">File: client/components/projects/task.css</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-css">.task {
  cursor: pointer;
}
.completed {
  text-decoration: line-through;
  color: silver;
}</code></pre></div>
<p>And combined, even on the same element:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-03/client/components/projects/task.js#L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-03</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-js">className={`task ${completed ? styles.completed : styles.pending} ${styles.task}`}</code></pre></div>
<p>The <code>camelCase</code> option on the <code>css-loader</code> is to convert CSS-style identifiers to JS-style ones, like with <code>disguise-link</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-03/client/components/projects/projectItem.css"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-03</div>
    <div class="filename">File: client/components/projects/projectItem.css</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-css">.disguise-link, .disguise-link:focus, .disguise-link:hover {
  text-decoration: none;
  font-weight: bold;
  color: black;
  cursor: default;
}</code></pre></div>
<p>This allows us to use it like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-03/client/components/projects/projectItem.js#L9"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-03</div>
    <div class="filename">File: client/components/projects/projectItem.js</div>
    <div class="from">From: 9</div>
    <div class="to">To: 9</div>
  </div>
  <pre><code class="language-js">activeClassName={styles.disguiseLink}</code></pre></div>
<p>The <code>css-loader</code> provides us with the <code>disguiseLink</code> alias but also gives us the original <code>disguise-link</code> though, the original is harder to use:</p>
<pre><code class="language-js">activeClassName={styles['disguise-link']}
</code></pre>
<p>Notice how the <code>css-loader</code> does not get confused by code like this:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-03/client/components/projects/projectList.js#L8"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-03</div>
    <div class="filename">File: client/components/projects/projectList.js</div>
    <div class="from">From: 8</div>
    <div class="to">To: 8</div>
  </div>
  <pre><code class="language-js">&lt;div className={`project-list ${styles.projectList}`}&gt;</code></pre></div>
<p>It is quite able to distinguish between the global <code>project-list</code> className and the local <code>style['project-list']</code> (or <code>style.projectList</code>) className.</p>
<p>Somehow, the <a href="https://www.npmjs.com/package/classnames">classnames</a> module we mentioned <a href="#chapter16-class-names">earlier</a> starts making much more sense.  It even allows us to simplify <code>app.js</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-04/client/components/app.js#L9-L17"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-04</div>
    <div class="filename">File: client/components/app.js</div>
    <div class="from">From: 9</div>
    <div class="to">To: 17</div>
  </div>
  <pre><code class="language-js">&lt;p className={classNames(styles.loading, { hide: !loading })}&gt;loading&lt;/p&gt;
&lt;pre
  className={classNames(
    'alert',
    'alert-warning',
    'alert-dismissible',
    { hide: !errors.length }
  )}
&gt;</code></pre></div>
<p>Instead of conditionally setting the <code>display</code> style to <code>block</code> or <code>none</code> to show or hide the loading indicator and the errors list, <code>classnames</code> makes it easy to apply Bootstrap's <a href="http://getbootstrap.com/css/#helper-classes-show-hide">hide</a> helper className.</p>
<h2><a class="self-ref" id="chapter19-composing-styles" href="#chapter19-composing-styles"># </a>Composing styles</h2>
<p>The styling of the HTTP errors list above is not right.  It uses too many of Bootstrap's ready-made styles right from the <code>.js</code> file, instead of the CSS file where it should.  As a matter of fact, the whole <code>App</code> component has too many styling features.  Why would it have a <code>&lt;pre&gt;</code> tag to enclose the errors list?  Wouldn't it be better to have a plain <code>&lt;div&gt;</code> and let the graphic designer how should it look?  That is what we've done in this version:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-05/client/components/app.js#L7-L33"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-05</div>
    <div class="filename">File: client/components/app.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 33</div>
  </div>
  <pre><code class="language-js">export const App = ({ children, pathname, loading, errors, onCloseErrors }) =&gt; (
  &lt;div className="app"&gt;
    &lt;div
      className={classNames(
        styles.loading,
        { hide: !loading }
      )}
    &gt;loading&lt;/div&gt;
    &lt;div
      className={classNames(
        styles.errorsList,
        { hide: !errors.length }
      )}
    &gt;
      &lt;button onClick={onCloseErrors} className={styles.closeButton} /&gt;
      {errors.join('\n')}
    &lt;/div&gt;
    &lt;ul className={styles.tabs}&gt;
      {
        /^\/projects/.test(pathname)
        ? (&lt;li className={styles.active}&gt;&lt;a href="#"&gt;Projects&lt;/a&gt;&lt;/li&gt;)
        : (&lt;li&gt;&lt;Link to="/projects"&gt;Projects&lt;/Link&gt;&lt;/li&gt;)
      }
    &lt;/ul&gt;
    {children}
  &lt;/div&gt;
);</code></pre></div>
<p>Now it has only two sets of tags which are not <code>&lt;div&gt;</code>s, a <code>&lt;button&gt;</code> and a set of <code>&lt;ul&gt;</code>-<code>&lt;li&gt;</code> tags, both of which are exactly what they are semantically meant to be.  In the end, the button will not look like a regular button and the list is going to look like a set of tabs but as for the component, the it simply describes the content, not how it will look.</p>
<p>In all cases, most elements have their <code>className</code> set to styles taken from the <code>app.css</code> import.</p>
<p>The <code>.errors-list</code> style is particularly interesting:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-05/client/components/app.css#L11-L17"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-05</div>
    <div class="filename">File: client/components/app.css</div>
    <div class="from">From: 11</div>
    <div class="to">To: 17</div>
  </div>
  <pre><code class="language-css">.errors-list {
  composes: global(alert);
  composes: global(alert-warning);
  composes: global(alert-dismissible);
  white-space: pre;
  font-family: monospace;
}</code></pre></div>
<p>The <code>css-loader</code> accepts the <code>composes</code> pseudo-attribute that allows a style definition to import the settings from another style. They should always precede any other setting and they can be overridden by later settings.  In this case, we are importing the definitions for <code>alert</code>, <code>alert-warning</code> and <code>alert-dismissible</code>, the very same ones we were using so far, taken from Bootstrap.  Since we are loading Bootstrap's CSS files globally, we enclose their names in <code>global()</code> so <code>css-loader</code> knows where they are.  Then we are making the <code>&lt;div&gt;</code> look like our earlier <code>&lt;pre&gt;</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-05/client/components/app.css#L28-L34"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-19-05</div>
    <div class="filename">File: client/components/app.css</div>
    <div class="from">From: 28</div>
    <div class="to">To: 34</div>
  </div>
  <pre><code class="language-css">.closeButton {
  composes: global(close);
  composes: global(pull-right);
}
.closeButton::before {
  content: "\00D7";
}</code></pre></div>
<p>For the <code>&lt;button&gt;</code> we are using the same classNames from Bootstrap and we are setting the contents via CSS to the Unicode for the <code>&amp;times;</code> HTML entity we had before.  The graphics designer might have as well used an image or icon.</p>
<p>Still, we have Bootstrap loaded globally.  We may avoid this.  The <code>composes</code> pseudo-attribute allows us to reference styles in other files, for example, in <code>bootstrap.css</code>.  For example, it would have been possible to do:</p>
<pre><code class="language-css">.closeButton {
  composes: close from &quot;bootstrap.css&quot;;
  composes: pull-right from &quot;bootstrap.css&quot;;
}
</code></pre>
<p>This assumes that we have created an alias for <code>bootstrap.css</code> in our WebPack configuration file.   If we imported all the styles we compose ours with, we would no longer need to link to them in <code>index.html</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-19-05/public/index.html#L6-L7">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  However, the Bootstrap files are large and even if we import a couple of styles from them, WebPack will load the whole file.  Worst still is that it will try to load the font file for the <em>glyphicons</em> and fail because WebPack doesn't know how to do that.</p>
<p>We have to specify the loaders WebPack has to use for fonts whether the ones from Bootstrap or Font Awesome:</p>
<pre><code class="language-js">{ test: /\.woff2?(\?v=[0-9]\.[0-9]\.[0-9])?$/, loader: &quot;url&quot; },
{ test: /\.(ttf|eot|svg)(\?[\s\S]+)?$/, loader: 'file' },
</code></pre>
<p>And then install them:</p>
<pre><code class="language-bash">npm i -D file-loader url-loader
</code></pre>
<p>It is, however, a bad idea to load the whole of Bootstrap in this way. The size of our bundle will increase significantly.  It is better if done with a smaller, customized version, which is quite easy to produce following Bootstrap <a href="http://getbootstrap.com/customize/#less">instructions</a> or even better to load it globally as we are doing right now.</p>
<p>WebPack can also load and bundle images in various formats provided of the suitable loaders.</p>
<h2><a class="self-ref" id="chapter19-summary" href="#chapter19-summary"># </a>Summary</h2>
<p>We have seen how we can improve the looks of our application by using any of many UI libraries available for free.</p>
<p>We learned how we can deliver a full component, JavaScript, markup and style using WebPack to import CSS files as it does with regular modules and how to keep their definitions private to the module importing them, avoiding conflicts with overlapping selectors.</p>
<p>This has freed us to use plenty more CSS styles than before, certain that we don't risk messing up with other components, packing each component with its own private style definitions.</p>
<p>We have also been able to import css styles from either globally loaded CSS files or external sources.</p>
</section><section id="chapter20"><h1><a class="self-ref" id="chapter20-editing" href="#chapter20-editing"># </a>Editing</h1>
<p>So far we have mostly displayed information with no inserting or deleting and little editing, we have only changed the task completion status and even that was local, it didn't update the database. Basically, we were doing just queries.</p>
<p>We already have our server side REST API so to do all the possible operations on our database, we only need to call them from the client. So far, in <code>projects/actions.js</code> we only have <code>getAllProjects</code> and <code>getProjectById</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/actions.js#L18-L49">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>, we need to add one method for each of the other REST API operations <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/actions.js#L51-L167">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  It is too long and repetitive to show it here, but they all follow the pattern we've seen already.  They all return a function so they get detected by <code>redux-thunk</code> as asynchronous operations.  Each dispatches an initial action ending suffixed with <code>REQUEST</code> and then do the actual request with whatever parameters each one needs.  The Axios request returns a promise which we use to detect its success, upon which we dispatch the action suffixed with <code>SUCCESS</code> with the required data.</p>
<p>Since each of the actions requires three action types and they all follow a pretty similar pattern, we have separated the creation of the action types into a separate file:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/actionTypes.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/store/projects/actionTypes.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">const NAME = 'projects';

const constants = {
  TASK_COMPLETED_CHANGE: 'projects/Task completed changed',
};

[
  'ALL_PROJECTS',
  'PROJECT_BY_ID',
  'ADD_PROJECT',
  'UPDATE_PROJECT',
  'DELETE_PROJECT',
  'ADD_TASK',
  'UPDATE_TASK',
  'DELETE_TASK',
].forEach(operation =&gt; {
  [
    'REQUEST',
    'SUCCESS',
    'FAILURE',
  ].forEach(stage =&gt; {
    constants[`${operation}_${stage}`] = `${NAME}/${operation}/${stage}`;
  });
});

module.exports = constants;</code></pre></div>
<p>We compose both the named constants and the string they represent out of the prefix for the sub-store <code>projects</code>, the operation and the suffix for the stage.  We played a little trick when exporting the constants.  Since the ES6 <code>export</code> statement only allows for static exports, it is not possible to use it to generate named export dynamically so we collected all the exports into an object <code>constants</code> and then used NodeJS-style <code>module.exports</code> because that is what it happens internally.  The following two pieces of code are equivalent:</p>
<pre><code class="language-js">export const foo = 1;
export const bar = 2;
</code></pre>
<pre><code class="language-js">module.exports = {
  foo: 1,
  bar: 2
};
</code></pre>
<p>Since we created the action types dynamically, it is worth considering if we could not create the action creators dynamically as well, after all, they all look very much alike. This is discussed in the <a href="http://redux.js.org/docs/recipes/ReducingBoilerplate.html#async-action-creators">Redux documentation</a> with an example of a possible implementation.  There are many possible implementations and none would teach us anything new.  We have already seen how to dispatch asynchronous actions and how to write middleware so we wouldn't be learning much by showing our own version nor by installing someone else's.</p>
<p>We made one noticeable change, the <code>completedChanged</code> action creator is significantly changed:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/actions.js#L169-L180"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/store/projects/actions.js</div>
    <div class="from">From: 169</div>
    <div class="to">To: 180</div>
  </div>
  <pre><code class="language-js">export const completedChanged = (pid, tid, descr, completed) =&gt;
  dispatch =&gt;
    dispatch(updateTask(pid, tid, descr, completed))
      .then(() =&gt;
        dispatch({
          type: ACTION_TYPES.TASK_COMPLETED_CHANGE,
          pid,
          tid,
          completed,
        })
      )
  ;</code></pre></div>
<p>The original one dated to when we worked all synchronously on the client side.  It didn't update anything in the server.  We have now changed it to an asynchronous one, one the returns a function instead of an object. What sets this one apart from the rest is that instead of handling the REST API itself, it dispatches a separate action, <code>updateTask</code> to do the actual updating.  Since all our asynchronous action creators return a Promise, the one that Axios itself returns, we wait for that Promise to be resolved successfully and only then we dispatch our original action object.  We do this so we can keep an updated <code>pending</code> count locally, without being forced to recalculate it by querying all the tasks in the affected project <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/projectsReducer.js#L18-L28">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.</p>
<p>Both our <code>projectsReducer.js</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/projectsReducer.js#L61-L82">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and <code>tasksReducer</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/tasksReducer.js#L23-L30">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> have grown to process the results of these extra actions. Our <code>projectsReducer</code> benefits from receiving some task-related actions <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/projectsReducer.js#L69-L82">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> since it allows it to update its own list of child <code>tids</code> as well as the <code>pending</code> count.   Redux always sends all the actions to all the reducers.  At first glance, this might seem a waste of processing time, however, this is a clear example of the benefits of that feature.</p>
<h2><a class="self-ref" id="chapter20-dispatching-the-new-actions" href="#chapter20-dispatching-the-new-actions"># </a>Dispatching the new actions</h2>
<p>The <code>Project</code> component has grown from passively displaying information about the project and containing its list of tasks to have two buttons to edit the header information or delete the whole project.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/project.js#L13-L30"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/project.js</div>
    <div class="from">From: 13</div>
    <div class="to">To: 30</div>
  </div>
  <pre><code class="language-js">return name
  ? (
  &lt;div className={classNames('project', styles.project)}&gt;
    &lt;div className="row"&gt;
      &lt;div className="col-md-9"&gt;
        &lt;h1&gt;{name}&lt;/h1&gt;
        &lt;div className={styles.descr}&gt;{descr}&lt;/div&gt;
      &lt;/div&gt;
      &lt;div className="col-md-3"&gt;
        &lt;button className={styles.editButton} onClick={editClickHandler}&gt;Edit Project&lt;/button&gt;
        &lt;button className={styles.deleteButton} onClick={deleteClickHandler}&gt;Delete Project&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;TaskList
      pid={pid}
    /&gt;
  &lt;/div&gt;)
  : (&lt;p&gt;Project {pid} not found&lt;/p&gt;)</code></pre></div>
<p>We have used Bootstrap's <a href="http://getbootstrap.com/css/#grid">grid system</a> to help with the layout.  A <code>&lt;div&gt;</code> element with className <code>row</code> encloses elements that are to go side by side.  Each child element has a <code>col-xs-</code><em>n</em> className to distribute the space in that row.  Each row has 12 slots and the <em>n</em> says how many of those 12ths each section can use.  The virtue of the grid system over using <code>&lt;table&gt;</code> elements as we had to use in earlier times is that it responds much better to screens of different sizes, from large desktop screens to small smartphones.  When the screen gets too narrow, the row folds into multiple lines in a much predictable way.  This is determined by the two letters following the <code>col-</code> prefix, <code>xs</code>, <code>sm</code>,<code>md</code> or <code>lg</code>, with <code>xs</code> never folding.</p>
<p>The project information is now held in the left cell while the right cell is taken by two buttons to edit or delete the project.  Each of them calls its own handler.  A project is expected to have a <code>name</code> so that field is used to signal the project does exist. It might seem the <code>pid</code> would be a better choice but a user might use a saved URL with a <code>pid</code> that points to a project that no longer exists, hence, the page would have a <code>pid</code>, taken from the URL.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/project.js#L7-L12"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/project.js</div>
    <div class="from">From: 7</div>
    <div class="to">To: 12</div>
  </div>
  <pre><code class="language-js">export const Project = ({ pid, name, descr, onEditClick, onDeleteClick }) =&gt; {
  const editClickHandler = ev =&gt; isPlainClick(ev) &amp;&amp; onEditClick({ pid });
  const deleteClickHandler = ev =&gt;
    isPlainClick(ev) &amp;&amp;
    window.confirm('Are you sure?') &amp;&amp; // eslint-disable-line no-alert
    onDeleteClick({ pid });</code></pre></div>
<p>The two action handlers are very much the same.  Both check whether it is a plain click (left button, no modifier keys) and then call the custom component action with the corresponding <code>pid</code>. The <code>pid</code> is passed as an object instead of a single value.  The reason to do that is mostly standardization, DOM events carry the event information in objects so it makes sense for custom events to do the same.  An object also leaves room for growth, extra properties can be added at any time without affecting existing listeners.  Others merge the component properties with the DOM event object:</p>
<pre><code class="language-js">const editClickHandler = ev =&gt;
  isPlainClick(ev) &amp;&amp; onEditClick(Object.assign({ pid }, ev));
</code></pre>
<p>This is fine for a UI component that is meant to be a better DOM element, for example, a <code>&lt;SuperButton&gt;</code> component that enhances the regular <code>&lt;button&gt;</code>, however, is not a good design for an application-oriented component. The rest of the application should not know about the DOM. It is the component that renders the DOM and it is the component that should take care of anything related to it, such as the DOM event.  If there is any other information in the DOM event object that might be of interest to the rest of the application, the component should extract, possibly pre-process any such values and then add them to the custom event object.  Or it might even fire a completely separate custom event, for example, a mouse click with the right button on a task might fire an <code>onContextMenu</code> custom event instead of <code>onCompletedChange</code> as it currently does.</p>
<p>The delete handler uses <code>window.confirm</code> which is quite an awful thing to do.  This is in no way recommended at all, but using any of the available modal overlay alternatives such as the one provided by <a href="http://react-bootstrap.github.io/components.html#overlays">React-Bootstrap</a> would have required loading lots of extra packages and adding code that would not have provided any particular benefit for the purpose of this book.</p>
<p>We now have a <code>mapDispatchToProps</code> object:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/project.js#L56-L61"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/project.js</div>
    <div class="from">From: 56</div>
    <div class="to">To: 61</div>
  </div>
  <pre><code class="language-js">onEditClick: ({ pid }) =&gt; dispatch(push(`/projects/editProject/${pid}`)),
  onDeleteClick: ({ pid }) =&gt;
    dispatch(deleteProject(pid))
      .then(() =&gt; dispatch(push('/projects'))),
});</code></pre></div>
<p>Editing a project requires a completely different page so it dispatches the <code>push</code> action from <code>react-router-redux</code> to navigate to that page.  As a matter of fact, the same could have been achieved by using a <code>&lt;Link&gt;</code> instead of a button:</p>
<pre><code class="language-html">&lt;Link className=&quot;btn btn-default&quot; to={`/project/editProject/${p.pid}`}&gt;
  Edit Project
&lt;/Link&gt;
</code></pre>
<p>The <code>&lt;Link&gt;</code>, however, would have limited our options to just navigating, going through the dispatcher in <code>mapDispatchToProps</code> allows for more flexibility as shown in the <code>onDeleteClick</code> callback.   We have pointed out earlier that all our asynchronous action creators return a Promise, the very same one that Axios returns. Redux doesn't really care about any such returned value, but it lets <code>dispatch</code> return it.  That is what allows us to chain a <code>.then</code> after we <code>dispatch</code> the <code>deleteProject</code> action:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/project.js#L58-L60"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/project.js</div>
    <div class="from">From: 58</div>
    <div class="to">To: 60</div>
  </div>
  <pre><code class="language-js">dispatch(deleteProject(pid))
      .then(() =&gt; dispatch(push('/projects'))),
});</code></pre></div>
<p>Since the project has just been deleted, it would make little sense to return to this very same page to tell the user that the project is missing.  Of course it is missing, it has just been deleted!  So, on a successful <code>deleteProject</code>, we just navigate away from this page. If there had been any error with the <code>deleteProject</code> action, it would have been caught in the action itself <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/actions.js#L93-L103">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and this <code>.then</code> would have not been called.  We might have used this or any Promise returned from the async actions to issue notifications to the user such as a <a href="http://www.material-ui.com/#/components/snackbar">snakcbar</a>.</p>
<p>To handle editing a project, we have added a couple of routes:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/routes.js#L8-L14"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/routes.js</div>
    <div class="from">From: 8</div>
    <div class="to">To: 14</div>
  </div>
  <pre><code class="language-js">export default (
  &lt;Route path="projects" component={ProjectList}&gt;
    &lt;Route path="newProject" component={EditProject} /&gt;
    &lt;Route path="editProject/:pid" component={EditProject} /&gt;
    &lt;Route path=":pid" component={Project} /&gt;
  &lt;/Route&gt;
);</code></pre></div>
<p>We will use the same <code>EditProject</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editProject.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> component to both add, when the route is <code>/projects/newProject</code> or edit an existing one for <code>/projects/editProject/:pid</code>.
After so much insistence on the benefits of stateless components over stateful ones, it seems strange that both editing components are stateful. There is a good reason for that to be so. Input elements such as <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> and <code>&lt;select&gt;</code> keep the user input within the DOM, however, in a dynamic application, the page could be refreshed at any time, perhaps due to an asynchronous action elsewhere.  If these elements are redrawn, they lose whatever the user might have entered so far. Since the DOM is volatile, they need their values to be preserved elsewhere and a stateful component is the perfect place for that.</p>
<h2><a class="self-ref" id="chapter20-rendering-a-stateful-form" href="#chapter20-rendering-a-stateful-form"># </a>Rendering a stateful form</h2>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editProject.js#L24-L57"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/editProject.js</div>
    <div class="from">From: 24</div>
    <div class="to">To: 57</div>
  </div>
  <pre><code class="language-js">render() {
    return (
      &lt;div className={classNames('edit-project', styles.editProject)}&gt;
        &lt;div className={styles.formGroup}&gt;
          &lt;label htmlFor="name"&gt;Name&lt;/label&gt;
          &lt;input
            className={styles.formControl}
            name="name"
            onChange={this.onChangeHandler}
            value={this.state.name}
          /&gt;
        &lt;/div&gt;
        &lt;div className={styles.formGroup}&gt;
          &lt;label htmlFor="descr"&gt;Description&lt;/label&gt;
          &lt;textarea
            className={styles.formControl}
            name="descr"
            onChange={this.onChangeHandler}
            value={this.state.descr}
          /&gt;
        &lt;/div&gt;
        &lt;button
          className={styles.okButton}
          disabled={this.state.name.length === 0}
          onClick={this.onSubmitHandler}
        &gt;Ok&lt;/button&gt;
        &lt;button
          className={styles.cancelButton}
          onClick={this.onCancelHandler}
        &gt;Cancel&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre></div>
<p>We use a couple of input fields and a couple of buttons with classNames imported from <code>editProject.css</code> <a href="">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which in turn point to Bootstrap's styles for form elements and buttons.  We must use the pseudo-attribute <code>htmlFor</code> instead of <code>for</code> in the <code>&lt;label&gt;</code> elements because <code>for</code> is a reserved word in JavaScript and it confuses the JSX pre-compiler (the same happens with <code>className</code> instead of <code>class</code>, another reserved word).</p>
<p>Each <code>&lt;input&gt;</code> element has its <code>name</code> set to the value they represent.  They both have their <code>onChange</code> event set to a listener to detect any changes.  Their <code>value</code>s are taken from <code>this.state.</code><em>whatever</em>.  The <code>onChangeHandler</code> constantly preserves any change in either input element in the component state using the element <code>name</code> property to identify each:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editProject.js#L14-L17"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/editProject.js</div>
    <div class="from">From: 14</div>
    <div class="to">To: 17</div>
  </div>
  <pre><code class="language-js">onChangeHandler(ev) {
  const target = ev.target;
  this.setState({ [target.name]: target.value });
}</code></pre></div>
<p>By preserving the values of the input elements in the component <code>state</code> we ensure that they are not lost if the page is accidentally refreshed.  Admittedly, a change in one section of the page should not refresh components elsewhere, but it may still happen.</p>
<p>Saving the input values in the state has other benefits.  Values could be formatted on the fly, for example, a space could be added every fourth digit in a credit card number. Values could be validated on each keystroke as well, before saving them into the state, for example, a message text could be truncated to the first 140 characters.  Values can be transformed in between their formatted representation to show to the user and the internal representation to be used internally within the application. That is why, on submitting the form, we are sending the values from <code>this.state</code> and not from the input fields:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editProject.js#L18-L20"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/editProject.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 20</div>
  </div>
  <pre><code class="language-js">onSubmitHandler(ev) {
  if (isPlainClick(ev)) this.props.onSubmit(this.state);
}</code></pre></div>
<p>The rest of the application should not be concerned about which kind of element we have used to request the information, whether it is a simple text box or a full-blown calendar component that returns a Date object, it is important that, when the entered values are send out from the component, they are in an application-oriented format.</p>
<p>In our form, we disable the submit button when the <code>name</code> field is empty:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editProject.js#L45-L49"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/editProject.js</div>
    <div class="from">From: 45</div>
    <div class="to">To: 49</div>
  </div>
  <pre><code class="language-html">&lt;button
  className={styles.okButton}
  disabled={this.state.name.length === 0}
  onClick={this.onSubmitHandler}
&gt;Ok&lt;/button&gt;</code></pre></div>
<p>The component is declared as a new class which extends <code>React.Component</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editProject.js#L8-L13"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/editProject.js</div>
    <div class="from">From: 8</div>
    <div class="to">To: 13</div>
  </div>
  <pre><code class="language-js">export class EditProject extends Component {
  constructor(props) {
    super(props);
    this.state = pick(props, 'name', 'descr');
    bindHandlers(this);
  }</code></pre></div>
<p>In the <code>constructor</code> we call <code>super</code> to pass on the <code>props</code> to <code>Component</code> and then set the initial <code>state</code> to the <code>name</code> and <code>descr</code> properties which we <code>pick</code> from <code>props</code> with the <code>lodash</code> utility of that name.  The <code>props</code> contain other values, but we don't want to pointlessly fill up <code>this.state</code> with information we don't really need. For example, since this component is a direct child of a <code>&lt;Route&gt;</code>, it will receive very many properties so we must be choosy.  We only pick the values needed for our input elements.</p>
<p>Calling <code>bindHandlers</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/utils/bindHandlers.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> comes next. The problem is that event handlers such as <code>onChangeHandler</code> are not called in the context of the component, that is, the <code>this</code> for an event handler is usually useless. To solve this, event handlers need to be bound to the context of the component. This should <strong>never</strong> be done in the <code>render</code> method, where the event handler is assigned, because the <code>render</code> method may be called many times (in this example, at least once per keystroke) and on each execution a new bound copy would be created quickly trashing the browser memory with these bound functions until the garbage collector kicks in.</p>
<p><code>bindHandlers</code> is just one of many recipes we can find out there. It looks for any own methods (not inherited) that start with <code>on</code> and end with <code>Handler</code> and binds them all to <code>this</code> just once when the object instance is created.  Thus, it will bind <code>onChangeHandler</code>, <code>onSubmitHandler</code> and <code>onCancelHandler</code>.  Actually, <code>bindHandlers</code> takes a second, optional argument that should be a regular expression with the pattern of the method names to be bound and it defaults to <code>on</code><em>XXXX</em><code>Handler</code> if none is specified.</p>
<p>To submit or quit editing we have the following as handlers for the corresponding buttons:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editProject.js#L18-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/editProject.js</div>
    <div class="from">From: 18</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">onSubmitHandler(ev) {
  if (isPlainClick(ev)) this.props.onSubmit(this.state);
}
onCancelHandler(ev) {
  if (isPlainClick(ev)) this.props.onCancelEdit();
}</code></pre></div>
<p>In both cases we are checking it is a plain left-mouse button click and calling the corresponding custom event listener with the current state if it corresponds.  This is the place to do any final conversion of the data from its external representation, for example, a string representing a date, to its internal one, such as a Date object.</p>
<p>Though <code>EditProject</code> is a stateful React component and it could deal with the store directly, it is still quite convenient to rely on the <code>connect</code> method of <code>react-redux</code>.  Both, <code>EditProject</code> and <code>Project</code> use the same data so it should not be surprising that instead of copying them, we import <code>mapStateToProps</code> and <code>initialDispatch</code> straight from <code>project.js</code> <a href="">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a>.  We modified the originals just a little bit to allow them to provide defaults when a project is about to be added and does not yet exist, but it gives us the benefit of testing and maintaining just one set of functions.</p>
<p>We do have to define a new <code>mapDispatchToProps</code> because the actions to be dispatched from <code>EditProject</code> are clearly different from those in <code>Project</code>.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editProject.js#L71-L87"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/editProject.js</div>
    <div class="from">From: 71</div>
    <div class="to">To: 87</div>
  </div>
  <pre><code class="language-js">export const mapDispatchToProps = (dispatch, { params: { pid } }) =&gt; ({
  onSubmit: ({ name, descr }) =&gt; {
    if (pid) {
      return dispatch(updateProject(pid, name, descr))
        .then(() =&gt; dispatch(push(`/projects/${pid}`)));
    }
    return dispatch(addProject(name, descr))
      .then(response =&gt; dispatch(push(`/projects/${response.data.pid}`)));
  },
  onCancelEdit: () =&gt; {
    dispatch(replace(
      pid
      ? `/projects/${pid}`
      : '/projects'
    ));
  },
});</code></pre></div>
<p>Both have to branch of to different actions depending on whether <code>pid</code> has a value or not.  The first implies an update, the second, an addition.  When canceling, on an update we return to the project that was to be updated, otherwise we simply go to the project list.  We use the <code>replace</code> action from <code>react-router-redux</code> instead of <code>push</code> because, since we canceled, we don't want the browser history to remember we wanted to edit.</p>
<p>In the <code>onSubmit</code> handler we dispatch either <code>updateProject</code> or <code>addProject</code> and upon a successful return we go to show the updated or newly added project.  For the added project, since we didn't have a <code>pid</code>, we read it from <code>respose.data.pid</code> as it is the database that will provide the <code>pid</code> from the newly added record.</p>
<p>The <code>Task</code> component has grown to handle two more actions besides toggling the <code>completed</code> flag. It has two new event handlers, <code>onTaskEditHandler</code> and <code>onTaskDeleteHandler</code></p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/task.js#L6-L23"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 6</div>
    <div class="to">To: 23</div>
  </div>
  <pre><code class="language-js">export const Task = (
  { pid, tid, descr, completed, onCompletedChange, onTaskEdit, onTaskDelete }
) =&gt; {
  const onClickHandler = ev =&gt; isPlainClick(ev) &amp;&amp; onCompletedChange({
    pid,
    tid,
    descr,
    completed: !completed,
  });
  const onTaskEditHandler = ev =&gt; isPlainClick(ev) &amp;&amp; onTaskEdit({ pid, tid });
  const onTaskDeleteHandler = ev =&gt; {
    if (
      isPlainClick(ev) &amp;&amp;
      window.confirm(`Delete: \n${descr}\nAre you sure?`)  // eslint-disable-line no-alert
    ) {
      onTaskDelete({ pid, tid, completed });
    }
  };</code></pre></div>
<p>The new events are fired by clicking on a couple of icons added to each task.  Since tasks can be numerous, it seemed better to use small icons instead of a full-size buttons.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/task.js#L48-L55"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/task.js</div>
    <div class="from">From: 48</div>
    <div class="to">To: 55</div>
  </div>
  <pre><code class="language-html">&lt;span
  className={styles.editIcon}
  onClick={onTaskEditHandler}
&gt;&lt;/span&gt;
&lt;span
  className={styles.deleteIcon}
  onClick={onTaskDeleteHandler}
&gt;&lt;/span&gt;</code></pre></div>
<p>The event handlers call the dispatchers in <code>mapDispatchToProps</code>.  <code>onCompletedChange</code> now sends all the information for the task because it eventually will have to call <code>updateTask</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/actions.js#L169-L180">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and has to give it all the information.</p>
<p><code>onTaskDelete</code> simply dispatches <code>deleteTask</code>.  It has to give it the <code>pid</code> so <code>projectsReducer</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/projects/projectsReducer.js#L76-L82">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> can delete the <code>tid</code> for this task from its <code>tids</code> array. It also needs to provide <code>completed</code> so it can update the <code>pending</code> count.</p>
<p><code>onTaskEdit</code> dispatches <code>setEditTid</code> which is a new action acting on a new reducer:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/misc/index.js"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/store/misc/index.js</div>
    <div class="from">From: start</div>
    <div class="to">To: end</div>
  </div>
  <pre><code class="language-js">export const EDIT_TID = 'Set tid of task to be edited';

export function setEditTid(tid) {
  return {
    type: EDIT_TID,
    tid,
  };
}

import update from 'react-addons-update';

export default (state = { editTid: null }, action) =&gt; {
  switch (action.type) {
    case EDIT_TID:
      return update(state, { editTid: { $set: action.tid } });
    default:
      return state;
  }
};</code></pre></div>
<p>It all adds up to simply adding a <code>editTid</code> property into a new sub-store we call <code>misc</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/store/createStore.js#L7">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> for <em>miscellaneous</em> which eventually might collect some other minor status information that doesn't deserve a whole sub-store.  <code>editTid</code> either contains <code>null</code> if no task is being edited, or the <code>tid</code> of the one being edited. This works along <code>TaskList</code>:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/taskList.js#L5-L16"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/taskList.js</div>
    <div class="from">From: 5</div>
    <div class="to">To: 16</div>
  </div>
  <pre><code class="language-js">export const TaskList = ({ pid, tids, editTid }) =&gt; (
  &lt;div className="task-list"&gt;{
    tids
    ? tids.map(tid =&gt; (
        tid === editTid
        ? &lt;EditTask key={tid} pid={pid} tid={tid} /&gt;
        : &lt;Task key={tid} pid={pid} tid={tid} /&gt;
      ))
    : null}
    {editTid ? null : &lt;EditTask pid={pid} /&gt;}
  &lt;/div&gt;
);</code></pre></div>
<p>If the <code>tid</code> of the task to be listed matches <code>editTid</code>, it uses <code>EditTask</code>, otherwise, it uses <code>Task</code>.  Also, if not task is currently being edited, it adds an <code>EditTask</code> with no <code>tid</code> attribute which allows adding new tasks.</p>
<p>It is important when creating multiple instances of a control such as the <code>Task</code>s in <code>TaskList</code> that each should have a <code>key</code> pseudo-attribute set to a unique value within the list to identify each instance.  React users this <code>key</code> to know whether it needs refreshing.  In <code>TaskList</code> we can clearly see the advantage.  As any of the <code>Task</code> instances can be replaced by <code>EditTask</code>, if they were not individually identified with the <code>key</code>, React would have little alternative but to redraw them all.  With the <code>key</code> it can know which <code>Task</code> instance has been replaced by <code>EditTask</code> and which ones remain and don't need redrawing.</p>
<p>This brings us to <code>EditTask</code> <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editTask.js">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> which follows the same basic structure as <code>EditProject</code>, even to the point of sharing <code>mapStateToProps</code> with <code>Task</code>.  Just a few details deserve highlighting.</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editTask.js#L81-L90"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/editTask.js</div>
    <div class="from">From: 81</div>
    <div class="to">To: 90</div>
  </div>
  <pre><code class="language-js">export const mapDispatchToProps = (dispatch, { pid, tid }) =&gt; ({
  onSubmit: ({ descr, completed }) =&gt; {
    if (tid) {
      return dispatch(updateTask(pid, tid, descr, completed))
        .then(() =&gt; dispatch(setEditTid(null)));
    }
    return dispatch(addTaskToProject(pid, descr, completed));
  },
  onCancelEdit: () =&gt; dispatch(setEditTid(null)),
});</code></pre></div>
<p>We use the <code>tid</code> property to determine if it should update an existing task or add a new one.  It dispatches either <code>updateTask</code> or <code>addTaskToProject</code> depending on that.  We use the same <code>tid</code> to determine if we are in edit mode <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editTask.js#L29">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> and change the style of the submit button <a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editTask.js#L51">(<img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" />)</a> to show either a check-mark or a plus sign (or whatever the graphics designer might choose).</p>
<p>After dispatching any of the actions, we dispatch <code>setEditTid</code> sending it back to <code>null</code> so the edit box goes away.</p>
<p>Finally, in the <code>onSubmitHandler</code> we have:</p>
<div class="code-insert"><div class="header">
    <div class="link"><a href="https://github.com/Satyam/book-react-redux/blob/chapter-20-01/client/components/projects/editTask.js#L17-L24"><img class="emoji" title="See in GitHub" alt="octocat" src="octocat.png" /></a></div>
    <div class="branch">Branch: chapter-20-01</div>
    <div class="filename">File: client/components/projects/editTask.js</div>
    <div class="from">From: 17</div>
    <div class="to">To: 24</div>
  </div>
  <pre><code class="language-js">onSubmitHandler(ev) {
  if (isPlainClick(ev)) {
    this.props.onSubmit(this.state)
    .then(() =&gt; {
      if (! this.props.tid) this.setState({ descr: '' });
    });
  }
}</code></pre></div>
<p>Here it is worth highlighting how important it is to keep returning the Promises returned by the actions dispatched.  We have already chained to the <code>.then</code> part of the Promises to navigate one place or another or to make the task edit box disappear.  Here, we are going one step further.  We have returned the Promise all the way back to the even handler, not just in <code>mapDispatchToProps</code> as we've done so far.  The reason for doing so is that when adding a task, the same instance of <code>EditTask</code> is used over and over again so we want to empty the input box to have it ready for a new task.  We do that with <code>this.setState</code> but  <code>mapDispatchToProps</code> has no access to <code>this</code> so it had to go all the way back to the event handler.</p>
<p>There are two points to make here:</p>
<ul>
<li>Use Promises, you can keep chaining and chaining plenty of useful code into them</li>
<li>Always return Promises in asynchronous actions and keep returning them.  The <code>dispatch</code> method returns them for our benefit and we should keep returning them higher up.</li>
</ul>
<p>Whenever we call <code>dispatch</code> on an asynchronous action we are either explicitly returning whatever it returns or leveraging the <em>fat arrow function</em> implicit return.</p>
</section></div>
  </body>
  <script type="text/javascript" src="index.js"></script>
</html>
